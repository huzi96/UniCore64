From a3c0f4e80b512abf800526d503dbec8ca1d1a8bf Mon Sep 17 00:00:00 2001
From: WangJing <wangjing@mprc.pku.edu.cn>
Date: Tue, 25 Oct 2011 18:00:10 +0800
Subject: [PATCH 030/641] UniCore64: Add function update_mmu_cache

Fixed error:
undefined reference to `update_mmu_cache'

Signed-off-by: WangJing <wangjing@mprc.pku.edu.cn>
---
 arch/unicore64/mm/mmu.c |   27 +++++++++++++++++++++++++++
 1 file changed, 27 insertions(+)

diff --git a/arch/unicore64/mm/mmu.c b/arch/unicore64/mm/mmu.c
index a5ec791..83c2cab 100644
--- a/arch/unicore64/mm/mmu.c
+++ b/arch/unicore64/mm/mmu.c
@@ -1,5 +1,32 @@
+#include <linux/mm.h>
+
 /*
  * empty_zero_page is a special page that is used for
  * zero-initialized data and COW.
  */
 struct page *empty_zero_page;
+
+/**
+ * update_mmu_cache() - checks the page table entry for validity
+ * @vma:
+ * @adddr:
+ * @ptep:
+ *
+ * Take care of architecture specific things when placing a new PTE into
+ * a page table, or changing an existing PTE.  Basically, there are two
+ * things that we need to take care of:
+ *
+ *  1. If PG_dcache_clean is not set for the page, we need to ensure
+ *     that any cache entries for the kernels virtual memory
+ *     range are written back to the page.
+ *  2. If we have multiple shared mappings of the same space in
+ *     an object, we need to deal with the cache aliasing issues.
+ *
+ * Note that the pte lock will be held.
+ */
+void update_mmu_cache(struct vm_area_struct *vma, unsigned long addr,
+	pte_t *ptep)
+{
+	/* FIXME */
+	BUG();
+}
-- 
1.7.9.5

