From efed0263a346202bc5e54122d49b0de5e018718e Mon Sep 17 00:00:00 2001
From: Guan Xuetao <gxt@mprc.pku.edu.cn>
Date: Thu, 31 May 2012 14:41:32 +0800
Subject: [PATCH 355/641] UniCore64: adjust code style in head.S boot.S and
 head-macro.S

Signed-off-by: Guan Xuetao <gxt@mprc.pku.edu.cn>
---
 arch/unicore64/boot/boot.S                |   46 +++++++-------
 arch/unicore64/include/arch/head-macros.S |   42 ++++++------
 arch/unicore64/kernel/head.S              |   99 +++++++++++++++--------------
 3 files changed, 94 insertions(+), 93 deletions(-)

diff --git a/arch/unicore64/boot/boot.S b/arch/unicore64/boot/boot.S
index af95c92..d75d64b 100644
--- a/arch/unicore64/boot/boot.S
+++ b/arch/unicore64/boot/boot.S
@@ -4,50 +4,50 @@
 #include <arch/asm-mmuops.h>
 #include <arch/head-macros.S>
 
-	.section ".start"
-	.globl	_start
+	.section	".start"
+	.globl		_start
 _start:
-	__head_initialize	r0
-	__cache_initialize	r0
+	__head_init	r0
+	__cache_init	r0
 
-	dmovl	sp, #UC64_PM_ZIMAGE_STACKTOP
+	dmovl		sp, #UC64_PM_ZIMAGE_STACKTOP
 
-	__head_clear_bss
+	__clear_bss
 
 #ifdef CONFIG_ARCH_FPGA
 	/*
 	 * Prepare early devtree for fpga board.
 	 */
-	dmovl	r0, #UC64_PM_DTB_START
-	ldd	r1, =dtb_data
-	ldd	r2, =dtb_data_end
-	dsub	r2, r2, r1
-	call	memcpy
+	dmovl		r0, #UC64_PM_DTB_START
+	ldd		r1, =dtb_data
+	ldd		r2, =dtb_data_end
+	dsub		r2, r2, r1
+	call		memcpy
 #endif /* CONFIG_ARCH_FPGA */
 
-	dmovl	r0, #UC64_PM_KIMAGE_START
-	call	decompress_kernel
+	dmovl		r0, #UC64_PM_KIMAGE_START
+	call		decompress_kernel
 
 	/* Re-initialize to system default status */
-	__flush_dcache		r0
-	__head_initialize	r0
+	__flush_dcache	r0
+	__head_init	r0
 
 	/*
 	 * Jump to the start address of kernel image.
 	 */
-	dmovl	r0, #UC64_PM_KIMAGE_START
-	jump	r0
+	dmovl		r0, #UC64_PM_KIMAGE_START
+	jump		r0
 
-	.section .rodata.dtb
+	.section	.rodata.dtb
 	____align64
 dtb_data:
-	.incbin "arch/unicore64/boot/unicore64-fpga.dtb"
+	.incbin		"arch/unicore64/boot/unicore64-fpga.dtb"
 dtb_data_end:
 
-	.section .rodata.piggy
+	.section	.rodata.piggy
 	____align64
-	.globl	input_data
+	.globl		input_data
 input_data:
-	.incbin "arch/unicore64/boot/piggy.bin"
-	.globl	input_data_end
+	.incbin		"arch/unicore64/boot/piggy.bin"
+	.globl		input_data_end
 input_data_end:
diff --git a/arch/unicore64/include/arch/head-macros.S b/arch/unicore64/include/arch/head-macros.S
index 5703dbe..ced150e 100644
--- a/arch/unicore64/include/arch/head-macros.S
+++ b/arch/unicore64/include/arch/head-macros.S
@@ -3,7 +3,7 @@
 #include <arch/asm-common.h>
 
 /*
- * __head_initialize - Initialize asr and coprocessor0.
+ * __head_init - Initialize asr and coprocessor0.
  *
  * Initialize ASR which is in PRIV mode and keep INTR off
  *
@@ -12,26 +12,26 @@
  * .... .... ..BS IDAM
  * .... .... ..10 0000
  */
-.macro	__head_initialize, rt
-	dmovl	&rt, #ASR_MODE_PRIV | ASR_INTR_SELECT
-	dmov	asr, &rt
-	dmov	&rt, #CP0_CTRLREG_DEFAULT
-	movc	CP0_CTRLREG, &rt, #0
+.macro	__head_init, rt
+	dmovl		&rt, #ASR_MODE_PRIV | ASR_INTR_SELECT
+	dmov		asr, &rt
+	dmov		&rt, #CP0_CTRLREG_DEFAULT
+	movc		CP0_CTRLREG, &rt, #0
 .endm
 
 /*
- * __head_clear_bss - Clear bss region
+ * __clear_bss - Clear bss region
  *
  * All GP registers will be destroyed in this macro.
  */
-.macro	__head_clear_bss
-	adr	r1, 1001f
-	ldd	r0, [r1+], #0
-	ldd	r2, [r1+], #8
-	dsub	r2, r2, r0
-	dmov	r1, #0
-	adr	lr, 1002f
-	b	memset
+.macro	__clear_bss
+	adr		r1, 1001f
+	ldd		r0, [r1+], #0
+	ldd		r2, [r1+], #8
+	dsub		r2, r2, r0
+	dmov		r1, #0
+	adr		lr, 1002f
+	b		memset
 
 	____align64
 1001:
@@ -41,18 +41,18 @@
 .endm
 
 /*
- * __cache_initialize - invalid and enable icache and dcache
+ * __cache_init - invalid and enable icache and dcache
  */
-.macro	__cache_initialize, rt
+.macro	__cache_init, rt
 	__invalid_dcache	&rt
 	__invalid_icache	&rt
 
-	movc	&rt, p0.c1, #0;
+	movc		&rt, p0.c1, #0;
 #ifndef CONFIG_CPU_DCACHE_DISABLE
-	dor	&rt, &rt, #4;
+	dor		&rt, &rt, #4;
 #endif
 #ifndef CONFIG_CPU_ICACHE_DISABLE
-	dor	&rt, &rt, #8;
+	dor		&rt, &rt, #8;
 #endif
-	movc	p0.c1, &rt, #0;
+	movc		p0.c1, &rt, #0;
 .endm
diff --git a/arch/unicore64/kernel/head.S b/arch/unicore64/kernel/head.S
index 7be5eda..814aeb2 100644
--- a/arch/unicore64/kernel/head.S
+++ b/arch/unicore64/kernel/head.S
@@ -19,8 +19,8 @@
  * DOC: swapper_pg_dir
  * swapper_pg_dir is the virtual address of the initial page table.
  */
-	.globl	swapper_pg_dir
-	.equ	swapper_pg_dir, UC64_VM_PGTABLE_PGD
+	.globl		swapper_pg_dir
+	.equ		swapper_pg_dir, UC64_VM_PGTABLE_PGD
 
 /**
  * stext - Kernel startup entry point.
@@ -29,99 +29,100 @@
  */
 	__HEAD
 ENTRY(stext)
-	__head_initialize	r0
-	__cache_initialize	r0
+	__head_init	r0
+	__cache_init	r0
 
 	/*
 	 * Enable the MMU.  This completely changes the structure of the visible
 	 * memory space.  You will not be able to trace execution through this.
 	 */
-	dmovl	sp, #UC64_PM_ZIMAGE_STACKTOP
-	call	__head_pgtable_init
+	dmovl		sp, #UC64_PM_ZIMAGE_STACKTOP
+	call		__head_pgtable_init
 
-	__invalid_tlb		r0
+	__invalid_tlb	r0
 
-	movc	r0, CP0_CTRLREG, #0
-	dor	r0, r0, #CP0_CTRLREG_MMU
-	movc	CP0_CTRLREG, r0, #0
+	movc		r0, CP0_CTRLREG, #0
+	dor		r0, r0, #CP0_CTRLREG_MMU
+	movc		CP0_CTRLREG, r0, #0
 
-	ldd	sp, __priv_sp
+	ldd		sp, __priv_sp
 
-	__head_clear_bss
+	__clear_bss
 
 	/* We must get the VA of start_kernel, and avoid using RA. */
-	ldd	r0, =start_kernel
-	jump	r0
+	ldd		r0, =start_kernel
+	jump		r0
 ENDPROC(stext)
 
 	____align64
 __priv_sp:
-	.dword	init_thread_union + (THREAD_SIZE - 8)
+	.dword		init_thread_union + (THREAD_SIZE - 8)
 
 /**
  * __head_pgtable_init - initialize the level one and level two page table
  * it will map the first 64MB of kernel image
  */
 ENTRY(__head_pgtable_init)
-	__push	lr
+	__push		lr
 	/*
 	 * Step one: clear 4k level-one page table for pgd
 	 */
-	dmovl	r0, #UC64_PM_PGTABLE_PGD
-	dmov	r1, #0
-	dmovl	r2, #UC64_PAGE_SIZE
-	call	memset
+	dmovl		r0, #UC64_PM_PGTABLE_PGD
+	dmov		r1, #0
+	dmovl		r2, #UC64_PAGE_SIZE
+	call		memset
 
 	/*
 	 * Step two: write level-one page table
 	 * Level one page table entry value = level two page table base + offset
 	 */
-	dmovl	r1, #UC64_VM_DMAP_START
-	dasr	r1, r1, #UC64_PGD_SHIFT
-	dlsl	r1, r1, #UC64_PGTBL_ENTRY_BITS
-	dmovl	r2, #UC64_PAGE_SELECT
-	dand	r1, r1, r2
-	dmovl	r2, #UC64_PM_PGTABLE_PGD
-	dadd	r1, r1, r2
-	dmovl	r0, #UC64_PM_PGTABLE_PUD_DM00
-	dor	r0, r0, #UC64_PGD_EXIST
-	std	r0, [r1]
-
-	dmovl	r1, #UC64_PM_PGTABLE_PGD
-	dmovl	r0, #UC64_PM_PGTABLE_PUD_DM00
-	dor	r0, r0, #UC64_PGD_EXIST
-	std	r0, [r1]
+	dmovl		r1, #UC64_VM_DMAP_START
+	dasr		r1, r1, #UC64_PGD_SHIFT
+	dlsl		r1, r1, #UC64_PGTBL_ENTRY_BITS
+	dmovl		r2, #UC64_PAGE_SELECT
+	dand		r1, r1, r2
+	dmovl		r2, #UC64_PM_PGTABLE_PGD
+	dadd		r1, r1, r2
+	dmovl		r0, #UC64_PM_PGTABLE_PUD_DM00
+	dor		r0, r0, #UC64_PGD_EXIST
+	std		r0, [r1]
+
+	dmovl		r1, #UC64_PM_PGTABLE_PGD
+	dmovl		r0, #UC64_PM_PGTABLE_PUD_DM00
+	dor		r0, r0, #UC64_PGD_EXIST
+	std		r0, [r1]
 
 	/*
 	 * Step three: clear 4k level-two page table from first
 	 * direct-mapped pmd
 	 */
-	dmovl	r0, #UC64_PM_PGTABLE_PUD_DM00
-	dmov	r1, #0
-	dmovl	r2, #UC64_PAGE_SIZE
-	call	memset
+	dmovl		r0, #UC64_PM_PGTABLE_PUD_DM00
+	dmov		r1, #0
+	dmovl		r2, #UC64_PAGE_SIZE
+	call		memset
 
 	/*
 	 * Step four: direct map 64M PM2VM in level two page table
 	 * Level two page table entry value = physcial frame number + offset
 	 * offset: S=0, MA=10, G=0, RWX=111, M=0, A=0, E=1, US=0, PT=1
 	 */
-	dmovl	r1, #UC64_PM_PGTABLE_PUD_DM00
-	dmovl	r0, UC64_PM_START
-	dor	r0, r0, #UC64_PMD_SPAGE | UC64_PMD_EXIST
-	dor	r0, r0, #UC64_PMD_TYPE_CACHE | UC64_PMD_RWX
-	dmovl	r2, UC64_PMD_SIZE
-	.rep	32
-	std.w	r0, [r1]+, #8
-	dadd	r0, r0, r2
+	dmovl		r1, #UC64_PM_PGTABLE_PUD_DM00
+	dmovl		r0, UC64_PM_START
+	dor		r0, r0, #UC64_PMD_SPAGE | UC64_PMD_EXIST
+	dor		r0, r0, #UC64_PMD_TYPE_CACHE | UC64_PMD_RWX
+	dmovl		r2, UC64_PMD_SIZE
+
+	.rep		32
+	std.w		r0, [r1]+, #8
+	dadd		r0, r0, r2
 	.endr
 
 	/*
 	 * Step five: set pgd register in cp0
 	 */
-	dmovl	r0, #UC64_PM_PGTABLE_PGD
+	dmovl		r0, #UC64_PM_PGTABLE_PGD
 	__set_pgd	r0
 
-	__pop	lr
+	__pop		lr
 	return
 ENDPROC(__head_pgtable_init)
-- 
1.7.9.5

