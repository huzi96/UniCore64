From 0fad4690930ad8a0065402663cba28da4584b023 Mon Sep 17 00:00:00 2001
From: Chang Huaixin <changhuaixin@mprc.pku.edu.cn>
Date: Fri, 12 Oct 2012 10:02:25 +0800
Subject: [PATCH 430/641] UniCore64: Add spinlock

Signed-off-by: Chang Huaixin <changhuaixin@mprc.pku.edu.cn>
---
 arch/unicore64/include/asm/spinlock.h       |  108 +++++++++++++++++++++++++++
 arch/unicore64/include/asm/spinlock_types.h |   20 +++++
 2 files changed, 128 insertions(+)
 create mode 100644 arch/unicore64/include/asm/spinlock.h
 create mode 100644 arch/unicore64/include/asm/spinlock_types.h

diff --git a/arch/unicore64/include/asm/spinlock.h b/arch/unicore64/include/asm/spinlock.h
new file mode 100644
index 0000000..9f91b92
--- /dev/null
+++ b/arch/unicore64/include/asm/spinlock.h
@@ -0,0 +1,108 @@
+#ifndef __UNICORE64_ASM_SPINLOCK_H__
+#define __UNICORE64_ASM_SPINLOCK_H__
+
+#ifndef CONFIG_SMP
+#error <asm/spinlock.h> is used when CONFIG_SMP disabled
+#endif
+
+#include <linux/spinlock_types.h>
+#include <asm/processor.h>
+#include <arch/asm-debug.h>
+
+#define arch_spin_lock_flags(lock, flags) arch_spin_lock(lock)
+
+static inline void arch_spin_lock(arch_spinlock_t *lock)
+{
+	/* FIXME */
+	__asm__(
+		"dmovl r0, 0xdead0001\n\t"
+		"call uc64_debug_putx\n\t"
+	);
+}
+
+static inline void arch_spin_unlock(arch_spinlock_t *lock)
+{
+	/* FIXME */
+	__asm__(
+		"dmovl r0, 0xdead0002\n\t"
+		"call uc64_debug_putx\n\t"
+	);
+}
+
+static inline int arch_spin_trylock(arch_spinlock_t *lock)
+{
+	/* FIXME */
+	__asm__(
+		"dmovl r0, 0xdead0003\n\t"
+		"call uc64_debug_putx\n\t"
+	);
+	return 0;
+}
+
+static inline void arch_read_lock(arch_rwlock_t *rw)
+{
+	/* FIXME */
+	__asm__(
+		"dmovl r0, 0xdead0004\n\t"
+		"call uc64_debug_putx\n\t"
+	);
+}
+
+static inline void arch_read_unlock(arch_rwlock_t *rw)
+{
+	/* FIXME */
+	__asm__(
+		"dmovl r0, 0xdead0005\n\t"
+		"call uc64_debug_putx\n\t"
+	);
+}
+
+static inline int arch_read_trylock(arch_rwlock_t *rw)
+{
+	/* FIXME */
+	__asm__(
+		"dmovl r0, 0xdead0006\n\t"
+		"call uc64_debug_putx\n\t"
+	);
+	return 0;
+}
+
+static inline void arch_write_lock(arch_rwlock_t *rw)
+{
+	/* FIXME */
+	__asm__(
+		"dmovl r0, 0xdead0007\n\t"
+		"call uc64_debug_putx\n\t"
+	);
+}
+
+static inline void arch_write_unlock(arch_rwlock_t *rw)
+{
+	/* FIXME */
+	__asm__(
+		"dmovl r0, 0xdead0008\n\t"
+		"call uc64_debug_putx\n\t"
+	);
+}
+
+static inline int arch_write_trylock(arch_rwlock_t *rw)
+{
+	/* FIXME */
+	__asm__(
+		"dmovl r0, 0xdead0009\n\t"
+		"call uc64_debug_putx\n\t"
+	);
+	return 0;
+}
+
+#define arch_read_lock_flags(lock, flags) arch_read_lock(lock)
+#define arch_write_lock_flags(lock, flags) arch_write_lock(lock)
+#define arch_spin_is_locked(x)			\
+	({					\
+		uc64_debug_putx(0xdead000a);	\
+		((x)->lock != 0);		\
+	})
+#define arch_spin_unlock_wait(lock) \
+	do { while (arch_spin_is_locked(lock)) cpu_relax(); } while (0)
+
+#endif /* __UNICORE64_ASM_SPINLOCK_H__ */
diff --git a/arch/unicore64/include/asm/spinlock_types.h b/arch/unicore64/include/asm/spinlock_types.h
new file mode 100644
index 0000000..b5b995c
--- /dev/null
+++ b/arch/unicore64/include/asm/spinlock_types.h
@@ -0,0 +1,20 @@
+#ifndef __UNICORE64_ASM_SPINLOCK_TYPES_H__
+#define __UNICORE64_ASM_SPINLOCK_TYPES_H__
+
+#ifndef __LINUX_SPINLOCK_TYPES_H
+# error "please don't include this file directly"
+#endif
+
+typedef struct {
+	volatile unsigned int lock;
+} arch_spinlock_t;
+
+#define __ARCH_SPIN_LOCK_UNLOCKED	{ 0 }
+
+typedef struct {
+	volatile unsigned int lock;
+} arch_rwlock_t;
+
+#define __ARCH_RW_LOCK_UNLOCKED		{ 0 }
+
+#endif /* __UNICORE64_ASM_SPINLOCK_TYPES_H__ */
-- 
1.7.9.5

