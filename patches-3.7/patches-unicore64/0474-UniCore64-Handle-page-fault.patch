From 9d2bc665ae17efbab66729c4c120583ebf2ce08e Mon Sep 17 00:00:00 2001
From: Liu Guoli <liuguoli@mprc.pku.edu.cn>
Date: Mon, 19 Nov 2012 16:08:43 +0800
Subject: [PATCH 474/641] UniCore64: Handle page fault

Signed-off-by: Liu Guoli <liuguoli@mprc.pku.edu.cn>
---
 arch/unicore64/mm/fault.c |  109 ++++++++++++++++++++++++++++++++++++++++-----
 1 file changed, 99 insertions(+), 10 deletions(-)

diff --git a/arch/unicore64/mm/fault.c b/arch/unicore64/mm/fault.c
index 6fdeead..74af588 100644
--- a/arch/unicore64/mm/fault.c
+++ b/arch/unicore64/mm/fault.c
@@ -17,20 +17,109 @@ static void __fixup_exception(struct pt_regs *regs)
 		BUG();
 }
 
-static void __do_pagefault(unsigned long addr, struct pt_regs *regs)
+static void __do_ipagefault(unsigned long address, struct pt_regs *regs)
 {
 	struct task_struct *tsk;
 	struct mm_struct *mm;
+	struct vm_area_struct *vma;
+	unsigned long error_code;
+	int fault;
 
 	tsk = current;
 	mm = tsk->mm;
+	error_code = __read_cp_op(p0.c3, 0);
 
 	if (!mm)
 		/* If we have no user context, we must not take the fault.. */
 		__fixup_exception(regs);
 
-	/* FIXME */
-	BUG();
+	vma = find_vma(mm, address);
+	if (!vma)
+		BUG();
+	if (vma->vm_start <= address)
+		goto good_area;
+	if (!(vma->vm_flags & VM_GROWSDOWN))
+		BUG();
+	if (expand_stack(vma, address))
+		BUG();
+
+/*
+ * Ok, we have a good vm_area for this memory access, so
+ * we can handle it..
+ */
+good_area:
+	if (error_code == 6) {
+		if (!(vma->vm_flags & VM_EXEC))
+			BUG();
+	}
+
+	/*
+	 * If for any reason at all we couldn't handle the fault, make
+	 * sure we exit gracefully rather than endlessly redo the fault.
+	 */
+	fault = handle_mm_fault(mm, vma, address, 0);
+	if (unlikely(fault & VM_FAULT_ERROR))
+		BUG();
+
+	if (fault & VM_FAULT_MAJOR)
+		tsk->maj_flt++;
+	else
+		tsk->min_flt++;
+
+	return;
+}
+
+static void __do_dpagefault(unsigned long address, struct pt_regs *regs)
+{
+	struct task_struct *tsk;
+	struct mm_struct *mm;
+	struct vm_area_struct *vma;
+	unsigned long error_code;
+	int fault;
+
+	tsk = current;
+	mm = tsk->mm;
+	error_code = __read_cp_op(p0.c3, 1);
+
+	if (!mm)
+		/* If we have no user context, we must not take the fault.. */
+		__fixup_exception(regs);
+
+	vma = find_vma(mm, address);
+	if (!vma)
+		BUG();
+	if (vma->vm_start <= address)
+		goto good_area;
+	if (!(vma->vm_flags & VM_GROWSDOWN))
+		BUG();
+	if (expand_stack(vma, address))
+		BUG();
+
+/*
+ * Ok, we have a good vm_area for this memory access, so
+ * we can handle it..
+ */
+good_area:
+	if (error_code == 7) {
+		if (!(vma->vm_flags & VM_WRITE))
+			BUG();
+	}
+
+	/*
+	 * If for any reason at all we couldn't handle the fault, make
+	 * sure we exit gracefully rather than endlessly redo the fault.
+	 */
+	fault = handle_mm_fault(mm, vma, address,
+				(error_code == 7) ? FAULT_FLAG_WRITE : 0);
+	if (unlikely(fault & VM_FAULT_ERROR))
+		BUG();
+
+	if (fault & VM_FAULT_MAJOR)
+		tsk->maj_flt++;
+	else
+		tsk->min_flt++;
+
+	return;
 }
 
 #define __itrap_stat()	__read_cp_op(CP0_TRAPSTAT, 0)
@@ -44,9 +133,9 @@ struct __trap_info {
 static struct __trap_info __itrap_info[] = {
 	{ NULL,			"0: no error"				},
 	{ NULL,			"1: access debug-specific area"		},
-	{ NULL,			"2: 2nd level pagetable non-exist"	},
-	{ NULL,			"3: 3rd level pagetable non-exist"	},
-	{ __do_pagefault,	"4: page non-exist"			},
+	{ __do_ipagefault,	"2: 2nd level pagetable non-exist"	},
+	{ __do_ipagefault,	"3: 3rd level pagetable non-exist"	},
+	{ __do_ipagefault,	"4: page non-exist"			},
 	{ NULL,			"5: superpage non-exist"		},
 	{ NULL,			"6: non-executable instruction"		},
 	{ NULL,			"7: access US=0 page in user mode"	},
@@ -63,12 +152,12 @@ static struct __trap_info __itrap_info[] = {
 static struct __trap_info __dtrap_info[] = {
 	{ NULL,			"0: no error"				},
 	{ NULL,			"1: access debug-specific area"		},
-	{ NULL,			"2: 2nd level pagetable non-exist"	},
-	{ NULL,			"3: 3rd level pagetable non-exist"	},
-	{ __do_pagefault,	"4: page non-exist"			},
+	{ __do_dpagefault,	"2: 2nd level pagetable non-exist"	},
+	{ __do_dpagefault,	"3: 3rd level pagetable non-exist"	},
+	{ __do_dpagefault,	"4: page non-exist"			},
 	{ NULL,			"5: superpage non-exist"		},
 	{ NULL,			"6: read unreadable address"		},
-	{ NULL,			"7: write unwritable address"		},
+	{ __do_dpagefault,	"7: write unwritable address"		},
 	{ NULL,			"8: access US=0 page in user mode"	},
 	{ NULL,			"9: unalignment access"			},
 	{ NULL,			"a: memory access error"		},
-- 
1.7.9.5

