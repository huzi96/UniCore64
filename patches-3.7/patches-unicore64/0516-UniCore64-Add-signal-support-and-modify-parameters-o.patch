From 66fa8c3144274acaf62e369588893356551187a9 Mon Sep 17 00:00:00 2001
From: Qin Rui <qinrui@mprc.pku.edu.cn>
Date: Fri, 28 Dec 2012 16:37:32 +0800
Subject: [PATCH 516/641] UniCore64: Add signal support and modify parameters
 of do_notify_resume

Signed-off-by: Qin Rui <qinrui@mprc.pku.edu.cn>
---
 arch/unicore64/kernel/entry.S  |   14 ++---
 arch/unicore64/kernel/signal.c |  125 ++++++++++++++++++++++++++++++++++++++--
 2 files changed, 126 insertions(+), 13 deletions(-)

diff --git a/arch/unicore64/kernel/entry.S b/arch/unicore64/kernel/entry.S
index 8cddf4b..bd0677a 100644
--- a/arch/unicore64/kernel/entry.S
+++ b/arch/unicore64/kernel/entry.S
@@ -81,10 +81,9 @@ ENTRY(ret_from_fork)
 	cmpsub.a	r0, #0
 	adr		lr, 1001b
 	bne		schedule		@ return to 1001b
-	and		r1, r18, #(1 << TIF_NOTIFY_RESUME | 1 << TIF_SIGPENDING)
-	cmpsub.a	r1, #0
-	dmov		r0, sp			@ 'regs'
-	dmov		r2, #0			@ 'syscall'
+	and		r0, r18, #(1 << TIF_NOTIFY_RESUME | 1 << TIF_SIGPENDING)
+	cmpsub.a	r0, #0
+	dmov		r1, #0			@ 'syscall'
 	bne.l		do_notify_resume
 	__thread_info	r17
 	ldw		r18, [r17+], #THREAD_INFO_FLAGS
@@ -141,10 +140,9 @@ ret_syscall:
 	cmpsub.a	r0, #0
 	adr		lr, ret_syscall
 	bne		schedule
-	and		r1, r18, #(1 << TIF_NOTIFY_RESUME | 1 << TIF_SIGPENDING)
-	cmpsub.a	r1, #0
-	dmov		r0, sp			@ 'regs'
-	dmov		r2, #0			@ 'syscall'
+	and		r0, r18, #(1 << TIF_NOTIFY_RESUME | 1 << TIF_SIGPENDING)
+	cmpsub.a	r0, #0
+	dmov		r1, #0                  @ 'syscall'
 	bne.l		do_notify_resume
 	__thread_info	r17
 	ldw		r18, [r17+], #THREAD_INFO_FLAGS
diff --git a/arch/unicore64/kernel/signal.c b/arch/unicore64/kernel/signal.c
index 2fd8a2d1..b173ff7 100644
--- a/arch/unicore64/kernel/signal.c
+++ b/arch/unicore64/kernel/signal.c
@@ -1,22 +1,137 @@
 #include <linux/syscalls.h>
 #include <linux/tracehook.h>
 
+#include <asm-generic/ucontext.h>
+#include <asm/uaccess.h>
+
 SYSCALL_DEFINE3(sigaltstack, const stack_t __user *, uss,
 		stack_t __user *, uoss,	struct pt_regs *, regs)
 {
 	BUG();
 }
 
-SYSCALL_DEFINE1(rt_sigreturn, struct pt_regs *, regs)
+struct rt_sigframe {
+	struct ucontext uc;
+	unsigned long retcode;
+};
+
+SYSCALL_DEFINE0(rt_sigreturn)
+{
+	struct rt_sigframe __user *frame;
+	sigset_t set;
+
+	struct pt_regs *regs = current_pt_regs();
+	frame = (struct rt_sigframe __user *)(regs->UC64_R29);
+
+	if (!access_ok(VERIFY_READ, frame, sizeof(*frame)))
+		goto badframe;
+
+	set_current_blocked(&set);
+
+	if (__copy_from_user(regs, &frame->uc.uc_mcontext.regs,
+				sizeof(struct pt_regs)))
+		goto badframe;
+
+	if (!user_mode(regs))
+		goto badframe;
+
+	return 0;
+
+badframe:
+	force_sig(SIGSEGV, current);
+	return 0;
+}
+
+/* grab and setup a signal frame.
+ *
+ * basically we stack a lot of state info, and arrange for the
+ * user-mode program to return to the kernel using either a
+ * trampoline which performs the syscall sigreturn, or a provided
+ * user-mode trampoline.
+ */
+static int setup_rt_frame(int sig, struct k_sigaction *ka, siginfo_t *info,
+			  sigset_t *set, struct pt_regs *regs)
+{
+	struct rt_sigframe  *frame;
+	int err = 0;
+	unsigned long sp = regs->UC64_R29;
+
+	frame = (void __user *)((sp - sizeof(*frame)) & ~7);
+
+	if (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))
+		return -EFAULT;
+
+	/*FIXME:check SA_SIGINFO*/
+
+	/* Clear all the bits of the ucontext we don't use.  */
+	err |= __clear_user(&frame->uc, offsetof(struct ucontext, uc_mcontext));
+
+	err |= __copy_to_user(&frame->uc.uc_mcontext.regs, regs,
+				sizeof(struct pt_regs));
+
+	/*Save jepriv code in frame->retcode*/
+	err |= __put_user(0xf000008b, &(frame->retcode));
+
+	if (err)
+		return -EFAULT;
+
+	/* Set up registers for signal handler */
+	/*R31 saves what we enter NOW*/
+	regs->UC64_R31 = (unsigned long)ka->sa.sa_handler;
+	/*R30 saves what we enter LATER*/
+	regs->UC64_R30 = (unsigned long)&(frame->retcode);
+	regs->UC64_R00 = (unsigned long)sig;           /* arg 1: signo */
+	/* actually move the usp to reflect the stacked frame */
+	regs->UC64_R29 = (unsigned long)frame;
+
+	return 0;
+}
+
+static void
+handle_signal(unsigned long sig, siginfo_t *info, struct k_sigaction *ka,
+		struct pt_regs *regs, int syscall)
+{
+	int ret;
+
+	/* Are we from a system call? */
+	if (syscall) {
+		/* If so, check system call restarting.. */
+		if (regs->UC64_R00)
+			BUG();
+	}
+
+	ret = setup_rt_frame(sig, ka, info, sigmask_to_save(), regs);
+	if (ret)
+		return;
+
+	/* Update the blocked signals */
+	signal_delivered(sig, info, ka, regs, 0);
+}
+
+void do_signal(struct pt_regs *regs, int syscall)
 {
+	struct k_sigaction ka;
+	siginfo_t info;
+	int signr;
+
+	signr = get_signal_to_deliver(&info, &ka, regs, NULL);
+	if (signr > 0) {
+		/* Whee! Actually deliver the signal.  */
+		handle_signal(signr, &info, &ka, regs, syscall);
+		return;
+	}
+
+	/* FIXME:check did we come from a system call? */
 	BUG();
 }
 
-asmlinkage void do_notify_resume(struct pt_regs *regs,
-		unsigned int thread_flags, int syscall)
+asmlinkage void do_notify_resume(unsigned int thread_flags, int syscall)
 {
-	if (thread_flags & (1 << TIF_SIGPENDING))
-		BUG();
+	struct pt_regs *regs = current_pt_regs();
+
+	if (thread_flags & (1 << TIF_SIGPENDING)) {
+		do_signal(regs, syscall);
+	}
 
 	if (thread_flags & (1 << TIF_NOTIFY_RESUME)) {
 		clear_thread_flag(TIF_NOTIFY_RESUME);
-- 
1.7.9.5

