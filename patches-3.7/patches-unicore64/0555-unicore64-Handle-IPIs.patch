From 0b796a0a827844da99f6ef812b5da024af8c1cb9 Mon Sep 17 00:00:00 2001
From: Chang Huaixin <changhuaixin@mprc.pku.edu.cn>
Date: Fri, 31 May 2013 16:55:24 +0800
Subject: [PATCH 555/641] unicore64: Handle IPIs

Signed-off-by: Chang Huaixin <changhuaixin@mprc.pku.edu.cn>
---
 arch/unicore64/kernel/entry.S |   20 +++++++++++++-
 arch/unicore64/kernel/smp.c   |   58 ++++++++++++++++++++++++++++++++++++++++-
 2 files changed, 76 insertions(+), 2 deletions(-)

diff --git a/arch/unicore64/kernel/entry.S b/arch/unicore64/kernel/entry.S
index c0870f9..fa06fad 100644
--- a/arch/unicore64/kernel/entry.S
+++ b/arch/unicore64/kernel/entry.S
@@ -84,6 +84,24 @@ ENTRY(ret_from_kthread)
 	jump		r18
 ENDPROC(ret_from_kthread)
 
+ENTRY(__vec_int_kernel)
+	__context_save
+
+#ifdef CONFIG_SMP
+	@ void ipi_handler(struct pt_regs *regs)
+	dmov		r0, sp
+	call		ipi_handler
+#endif
+
+	ldd		r17, [sp+], #240	@ get bsr
+	dand		r17, r17, #7
+	cmpsub.a	r17, #1
+	beq		ret_to_user
+
+	__context_restore
+	eret
+ENDPROC(__vec_int_kernel)
+
 ENTRY(__vec_invalid)
 	dmovl		r0, 0xdeaddeaddeaddead
 	__putdata	r0
@@ -211,7 +229,7 @@ ENTRY(__vectors_table)
 	b		__vec_itrap			@ 0x0c: ITRAP
 	b		__vec_dtrap			@ 0x10: DTRAP
 	call		__vec_invalid			@ 0x14: FPU_EXC
-	call		__vec_invalid			@ 0x18: INT_KERNEL
+	b		__vec_int_kernel		@ 0x18: INT_KERNEL
 	call		__vec_invalid			@ 0x1c: INT_FAULT
 	b		__vec_int_itimer		@ 0x20: INT_TIMER
 	b		__vec_int_puv4			@ 0x24: INT_PUV4
diff --git a/arch/unicore64/kernel/smp.c b/arch/unicore64/kernel/smp.c
index 2c0519e..01634bb 100644
--- a/arch/unicore64/kernel/smp.c
+++ b/arch/unicore64/kernel/smp.c
@@ -3,11 +3,12 @@
 #include <linux/sched.h>
 #include <linux/delay.h>
 #include <linux/cpu.h>
+#include <linux/interrupt.h>
 
 #include <arch/hwdef-cp0-sysctrl.h>
 
 #define __ipi_disable()	\
-	__write_uc64(__read_uc64(asr) | ASR_INTR_SMP)
+	__write_uc64(__read_uc64(asr) | ASR_INTR_SMP, asr)
 #define __ipi_clear()		\
 	__write_cp(__read_cp(CP0_INTR) & ~CP0_INTR_SMP, CP0_INTR)
 
@@ -82,6 +83,61 @@ static void send_ipi_message(const struct cpumask *to_whom,
 		send_ipi(i);
 }
 
+/* This function handlers all IPIs. */
+void ipi_handler(struct pt_regs *regs)
+{
+	struct pt_regs *old_regs = set_irq_regs(regs);
+	int cpu = smp_processor_id();
+	unsigned long *pending_ipis = &ipi_data[cpu].bits;
+	unsigned long ops;
+
+	/* IPI bits should be cleared before checking pending IPIs.*/
+	__ipi_disable();
+	__ipi_clear();
+
+	/* Order interrupt and bit testing. */
+	mb();
+	while ((ops = xchg(pending_ipis, 0)) != 0) {
+		/* Order bit clearing and data access. */
+		mb();
+		do {
+			unsigned long which;
+
+			which = ops & -ops;
+			ops &= ~which;
+			which = __ffs(which);
+
+			switch (which) {
+			case IPI_RESCHEDULE:
+				scheduler_ipi();
+				break;
+
+			case IPI_CALL_FUNC:
+				irq_enter();
+				generic_smp_call_function_interrupt();
+				irq_exit();
+				break;
+
+			case IPI_CALL_FUNC_SINGLE:
+				irq_enter();
+				generic_smp_call_function_single_interrupt();
+				irq_exit();
+				break;
+
+			default:
+				printk(KERN_CRIT "Unknown IPI on CPU %d: %lu\n",
+					cpu, which);
+				break;
+			}
+		} while (ops);
+
+		/* Order data access and bit testing. */
+		mb();
+	}
+
+	set_irq_regs(old_regs);
+}
+
 void smp_send_reschedule(int cpu)
 {
 	send_ipi_message(cpumask_of(cpu), IPI_RESCHEDULE);
-- 
1.7.9.5

