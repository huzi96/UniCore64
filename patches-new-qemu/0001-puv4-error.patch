From e4b7183969ae367622bbb9ca4ed6a33f172d4031 Mon Sep 17 00:00:00 2001
From: Michael Hoo <huyy@pku.edu.cn>
Date: Wed, 21 Dec 2016 02:23:20 +0800
Subject: [PATCH 1/2] puv4 error

---
 arch_init.c                              |    2 +
 config.h                                 |  404 +++
 configure                                |    2 +
 default-configs/unicore64-linux-user.mak |    2 +
 default-configs/unicore64-softmmu.mak    |    5 +
 fpu/softfloat.h                          |  754 +++++
 hw/gpio/puv4_io_ctl.c                    |   79 +
 hw/intc/puv4_intc.c                      |  140 +
 hw/puv4.h                                |   22 +
 hw/puv4_csr.c                            |   93 +
 hw/puv4_intc.c                           |  140 +
 hw/puv4_io_ctl.c                         |   79 +
 hw/puv4_ost.c                            |  142 +
 hw/timer/puv4_ost.c                      |  142 +
 hw/unicore64/Makefile.objs               |    8 +
 hw/unicore64/cp0_intc.c                  |  105 +
 hw/unicore64/cp0_itm.c                   |   56 +
 hw/unicore64/puv4.c                      |  116 +
 include/elf.h                            |    2 +-
 include/hw/unicore64/puv4.h              |   22 +
 include/sysemu/arch_init.h               |    1 +
 linux-user/elfload.c                     |   28 +
 linux-user/main.c                        |   17 +
 linux-user/syscall_defs.h                |    8 +-
 linux-user/unicore64/syscall_nr.h        |  311 ++
 linux-user/unicore64/target_cpu.h        |  238 ++
 linux-user/unicore64/target_signal.h     |   22 +
 linux-user/unicore64/target_structs.h    |   52 +
 linux-user/unicore64/target_syscall.h    |   52 +
 linux-user/unicore64/termbits.h          |    2 +
 qemu-char.c                              | 4678 ------------------------------
 target-unicore64/Makefile.objs           |    3 +
 target-unicore64/cpu-qom.h               |   52 +
 target-unicore64/cpu.c                   |   92 +
 target-unicore64/cpu.h                   |  238 ++
 target-unicore64/helper.c                |  515 ++++
 target-unicore64/helper.h                |   67 +
 target-unicore64/machine.c               |   23 +
 target-unicore64/softmmu.c               |  322 ++
 target-unicore64/translate.c             | 1714 +++++++++++
 target-unicore64/ucf64_helper.c          |  399 +++
 target-unicore64/ucf64_trans.h           |  439 +++
 42 files changed, 6906 insertions(+), 4682 deletions(-)
 create mode 100644 config.h
 create mode 100644 default-configs/unicore64-linux-user.mak
 create mode 100644 default-configs/unicore64-softmmu.mak
 create mode 100644 fpu/softfloat.h
 create mode 100644 hw/gpio/puv4_io_ctl.c
 create mode 100644 hw/intc/puv4_intc.c
 create mode 100644 hw/puv4.h
 create mode 100644 hw/puv4_csr.c
 create mode 100644 hw/puv4_intc.c
 create mode 100644 hw/puv4_io_ctl.c
 create mode 100644 hw/puv4_ost.c
 create mode 100644 hw/timer/puv4_ost.c
 create mode 100644 hw/unicore64/Makefile.objs
 create mode 100644 hw/unicore64/cp0_intc.c
 create mode 100644 hw/unicore64/cp0_itm.c
 create mode 100644 hw/unicore64/puv4.c
 create mode 100644 include/hw/unicore64/puv4.h
 create mode 100644 linux-user/unicore64/syscall_nr.h
 create mode 100644 linux-user/unicore64/target_cpu.h
 create mode 100644 linux-user/unicore64/target_signal.h
 create mode 100644 linux-user/unicore64/target_structs.h
 create mode 100644 linux-user/unicore64/target_syscall.h
 create mode 100644 linux-user/unicore64/termbits.h
 delete mode 100644 qemu-char.c
 create mode 100644 target-unicore64/Makefile.objs
 create mode 100644 target-unicore64/cpu-qom.h
 create mode 100644 target-unicore64/cpu.c
 create mode 100644 target-unicore64/cpu.h
 create mode 100644 target-unicore64/helper.c
 create mode 100644 target-unicore64/helper.h
 create mode 100644 target-unicore64/machine.c
 create mode 100644 target-unicore64/softmmu.c
 create mode 100644 target-unicore64/translate.c
 create mode 100644 target-unicore64/ucf64_helper.c
 create mode 100644 target-unicore64/ucf64_trans.h

diff --git a/arch_init.c b/arch_init.c
index fa05973..36d0dab 100644
--- a/arch_init.c
+++ b/arch_init.c
@@ -78,6 +78,8 @@ int graphic_depth = 32;
 #define QEMU_ARCH QEMU_ARCH_XTENSA
 #elif defined(TARGET_UNICORE32)
 #define QEMU_ARCH QEMU_ARCH_UNICORE32
+#elif defined(TARGET_UNICORE64)
+#define QEMU_ARCH QEMU_ARCH_UNICORE64
 #elif defined(TARGET_TRICORE)
 #define QEMU_ARCH QEMU_ARCH_TRICORE
 #endif
diff --git a/config.h b/config.h
new file mode 100644
index 0000000..9e9fa61
--- /dev/null
+++ b/config.h
@@ -0,0 +1,404 @@
+/*
+ * OS includes and handling of OS dependencies
+ *
+ * This header exists to pull in some common system headers that
+ * most code in QEMU will want, and to fix up some possible issues with
+ * it (missing defines, Windows weirdness, and so on).
+ *
+ * To avoid getting into possible circular include dependencies, this
+ * file should not include any other QEMU headers, with the exceptions
+ * of config-host.h, config-target.h, qemu/compiler.h,
+ * sysemu/os-posix.h, sysemu/os-win32.h, glib-compat.h and
+ * qemu/typedefs.h, all of which are doing a similar job to this file
+ * and are under similar constraints.
+ *
+ * This header also contains prototypes for functions defined in
+ * os-*.c and util/oslib-*.c; those would probably be better split
+ * out into separate header files.
+ *
+ * In an ideal world this header would contain only:
+ *  (1) things which everybody needs
+ *  (2) things without which code would work on most platforms but
+ *      fail to compile or misbehave on a minority of host OSes
+ *
+ * This work is licensed under the terms of the GNU GPL, version 2 or later.
+ * See the COPYING file in the top-level directory.
+ */
+#ifndef QEMU_OSDEP_H
+#define QEMU_OSDEP_H
+
+#include "config-host.h"
+#ifdef NEED_CPU_H
+#include "config-target.h"
+#else
+#include "exec/poison.h"
+#endif
+#include "qemu/compiler.h"
+
+/* Older versions of C++ don't get definitions of various macros from
+ * stdlib.h unless we define these macros before first inclusion of
+ * that system header.
+ */
+#ifndef __STDC_CONSTANT_MACROS
+#define __STDC_CONSTANT_MACROS
+#endif
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS
+#endif
+#ifndef __STDC_FORMAT_MACROS
+#define __STDC_FORMAT_MACROS
+#endif
+
+/* The following block of code temporarily renames the daemon() function so the
+ * compiler does not see the warning associated with it in stdlib.h on OSX
+ */
+#ifdef __APPLE__
+#define daemon qemu_fake_daemon_function
+#include <stdlib.h>
+#undef daemon
+extern int daemon(int, int);
+#endif
+
+#include <stdarg.h>
+#include <stddef.h>
+#include <stdbool.h>
+#include <stdint.h>
+#include <sys/types.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <strings.h>
+#include <inttypes.h>
+#include <limits.h>
+/* Put unistd.h before time.h as that triggers localtime_r/gmtime_r
+ * function availability on recentish Mingw-w64 platforms. */
+#include <unistd.h>
+#include <time.h>
+#include <ctype.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <sys/time.h>
+#include <assert.h>
+/* setjmp must be declared before sysemu/os-win32.h
+ * because it is redefined there. */
+#include <setjmp.h>
+#include <signal.h>
+
+#ifdef __OpenBSD__
+#include <sys/signal.h>
+#endif
+
+#ifndef _WIN32
+#include <sys/wait.h>
+#else
+#define WIFEXITED(x)   1
+#define WEXITSTATUS(x) (x)
+#endif
+
+#ifdef _WIN32
+#include "sysemu/os-win32.h"
+#endif
+
+#ifdef CONFIG_POSIX
+#include "sysemu/os-posix.h"
+#endif
+
+#include "glib-compat.h"
+#include "qemu/typedefs.h"
+
+#ifndef O_LARGEFILE
+#define O_LARGEFILE 0
+#endif
+#ifndef O_BINARY
+#define O_BINARY 0
+#endif
+#ifndef MAP_ANONYMOUS
+#define MAP_ANONYMOUS MAP_ANON
+#endif
+#ifndef ENOMEDIUM
+#define ENOMEDIUM ENODEV
+#endif
+#if !defined(ENOTSUP)
+#define ENOTSUP 4096
+#endif
+#if !defined(ECANCELED)
+#define ECANCELED 4097
+#endif
+#if !defined(EMEDIUMTYPE)
+#define EMEDIUMTYPE 4098
+#endif
+#ifndef TIME_MAX
+#define TIME_MAX LONG_MAX
+#endif
+
+/* HOST_LONG_BITS is the size of a native pointer in bits. */
+#if UINTPTR_MAX == UINT32_MAX
+# define HOST_LONG_BITS 32
+#elif UINTPTR_MAX == UINT64_MAX
+# define HOST_LONG_BITS 64
+#else
+# error Unknown pointer size
+#endif
+
+#ifndef MIN
+#define MIN(a, b) (((a) < (b)) ? (a) : (b))
+#endif
+#ifndef MAX
+#define MAX(a, b) (((a) > (b)) ? (a) : (b))
+#endif
+
+/* Minimum function that returns zero only iff both values are zero.
+ * Intended for use with unsigned values only. */
+#ifndef MIN_NON_ZERO
+#define MIN_NON_ZERO(a, b) ((a) == 0 ? (b) : \
+                                ((b) == 0 ? (a) : (MIN(a, b))))
+#endif
+
+/* Round number down to multiple */
+#define QEMU_ALIGN_DOWN(n, m) ((n) / (m) * (m))
+
+/* Round number up to multiple. Safe when m is not a power of 2 (see
+ * ROUND_UP for a faster version when a power of 2 is guaranteed) */
+#define QEMU_ALIGN_UP(n, m) QEMU_ALIGN_DOWN((n) + (m) - 1, (m))
+
+/* Check if n is a multiple of m */
+#define QEMU_IS_ALIGNED(n, m) (((n) % (m)) == 0)
+
+/* n-byte align pointer down */
+#define QEMU_ALIGN_PTR_DOWN(p, n) \
+    ((typeof(p))QEMU_ALIGN_DOWN((uintptr_t)(p), (n)))
+
+/* n-byte align pointer up */
+#define QEMU_ALIGN_PTR_UP(p, n) \
+    ((typeof(p))QEMU_ALIGN_UP((uintptr_t)(p), (n)))
+
+/* Check if pointer p is n-bytes aligned */
+#define QEMU_PTR_IS_ALIGNED(p, n) QEMU_IS_ALIGNED((uintptr_t)(p), (n))
+
+/* Round number up to multiple. Requires that d be a power of 2 (see
+ * QEMU_ALIGN_UP for a safer but slower version on arbitrary
+ * numbers) */
+#ifndef ROUND_UP
+#define ROUND_UP(n,d) (((n) + (d) - 1) & -(d))
+#endif
+
+#ifndef DIV_ROUND_UP
+#define DIV_ROUND_UP(n,d) (((n) + (d) - 1) / (d))
+#endif
+
+#ifndef ARRAY_SIZE
+#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
+#endif
+
+int qemu_daemon(int nochdir, int noclose);
+void *qemu_try_memalign(size_t alignment, size_t size);
+void *qemu_memalign(size_t alignment, size_t size);
+void *qemu_anon_ram_alloc(size_t size, uint64_t *align);
+void qemu_vfree(void *ptr);
+void qemu_anon_ram_free(void *ptr, size_t size);
+
+#define QEMU_MADV_INVALID -1
+
+#if defined(CONFIG_MADVISE)
+
+#define QEMU_MADV_WILLNEED  MADV_WILLNEED
+#define QEMU_MADV_DONTNEED  MADV_DONTNEED
+#ifdef MADV_DONTFORK
+#define QEMU_MADV_DONTFORK  MADV_DONTFORK
+#else
+#define QEMU_MADV_DONTFORK  QEMU_MADV_INVALID
+#endif
+#ifdef MADV_MERGEABLE
+#define QEMU_MADV_MERGEABLE MADV_MERGEABLE
+#else
+#define QEMU_MADV_MERGEABLE QEMU_MADV_INVALID
+#endif
+#ifdef MADV_UNMERGEABLE
+#define QEMU_MADV_UNMERGEABLE MADV_UNMERGEABLE
+#else
+#define QEMU_MADV_UNMERGEABLE QEMU_MADV_INVALID
+#endif
+#ifdef MADV_DODUMP
+#define QEMU_MADV_DODUMP MADV_DODUMP
+#else
+#define QEMU_MADV_DODUMP QEMU_MADV_INVALID
+#endif
+#ifdef MADV_DONTDUMP
+#define QEMU_MADV_DONTDUMP MADV_DONTDUMP
+#else
+#define QEMU_MADV_DONTDUMP QEMU_MADV_INVALID
+#endif
+#ifdef MADV_HUGEPAGE
+#define QEMU_MADV_HUGEPAGE MADV_HUGEPAGE
+#else
+#define QEMU_MADV_HUGEPAGE QEMU_MADV_INVALID
+#endif
+#ifdef MADV_NOHUGEPAGE
+#define QEMU_MADV_NOHUGEPAGE MADV_NOHUGEPAGE
+#else
+#define QEMU_MADV_NOHUGEPAGE QEMU_MADV_INVALID
+#endif
+
+#elif defined(CONFIG_POSIX_MADVISE)
+
+#define QEMU_MADV_WILLNEED  POSIX_MADV_WILLNEED
+#define QEMU_MADV_DONTNEED  POSIX_MADV_DONTNEED
+#define QEMU_MADV_DONTFORK  QEMU_MADV_INVALID
+#define QEMU_MADV_MERGEABLE QEMU_MADV_INVALID
+#define QEMU_MADV_UNMERGEABLE QEMU_MADV_INVALID
+#define QEMU_MADV_DODUMP QEMU_MADV_INVALID
+#define QEMU_MADV_DONTDUMP QEMU_MADV_INVALID
+#define QEMU_MADV_HUGEPAGE  QEMU_MADV_INVALID
+#define QEMU_MADV_NOHUGEPAGE  QEMU_MADV_INVALID
+
+#else /* no-op */
+
+#define QEMU_MADV_WILLNEED  QEMU_MADV_INVALID
+#define QEMU_MADV_DONTNEED  QEMU_MADV_INVALID
+#define QEMU_MADV_DONTFORK  QEMU_MADV_INVALID
+#define QEMU_MADV_MERGEABLE QEMU_MADV_INVALID
+#define QEMU_MADV_UNMERGEABLE QEMU_MADV_INVALID
+#define QEMU_MADV_DODUMP QEMU_MADV_INVALID
+#define QEMU_MADV_DONTDUMP QEMU_MADV_INVALID
+#define QEMU_MADV_HUGEPAGE  QEMU_MADV_INVALID
+#define QEMU_MADV_NOHUGEPAGE  QEMU_MADV_INVALID
+
+#endif
+
+#if defined(__linux__) && \
+    (defined(__x86_64__) || defined(__arm__) || defined(__aarch64__))
+   /* Use 2 MiB alignment so transparent hugepages can be used by KVM.
+      Valgrind does not support alignments larger than 1 MiB,
+      therefore we need special code which handles running on Valgrind. */
+#  define QEMU_VMALLOC_ALIGN (512 * 4096)
+#elif defined(__linux__) && defined(__s390x__)
+   /* Use 1 MiB (segment size) alignment so gmap can be used by KVM. */
+#  define QEMU_VMALLOC_ALIGN (256 * 4096)
+#else
+#  define QEMU_VMALLOC_ALIGN getpagesize()
+#endif
+
+int qemu_madvise(void *addr, size_t len, int advice);
+
+int qemu_open(const char *name, int flags, ...);
+int qemu_close(int fd);
+#ifndef _WIN32
+int qemu_dup(int fd);
+#endif
+
+#if defined(__HAIKU__) && defined(__i386__)
+#define FMT_pid "%ld"
+#elif defined(WIN64)
+#define FMT_pid "%" PRId64
+#else
+#define FMT_pid "%d"
+#endif
+
+int qemu_create_pidfile(const char *filename);
+int qemu_get_thread_id(void);
+
+#ifndef CONFIG_IOVEC
+struct iovec {
+    void *iov_base;
+    size_t iov_len;
+};
+/*
+ * Use the same value as Linux for now.
+ */
+#define IOV_MAX 1024
+
+ssize_t readv(int fd, const struct iovec *iov, int iov_cnt);
+ssize_t writev(int fd, const struct iovec *iov, int iov_cnt);
+#else
+#include <sys/uio.h>
+#endif
+
+#ifdef _WIN32
+static inline void qemu_timersub(const struct timeval *val1,
+                                 const struct timeval *val2,
+                                 struct timeval *res)
+{
+    res->tv_sec = val1->tv_sec - val2->tv_sec;
+    if (val1->tv_usec < val2->tv_usec) {
+        res->tv_sec--;
+        res->tv_usec = val1->tv_usec - val2->tv_usec + 1000 * 1000;
+    } else {
+        res->tv_usec = val1->tv_usec - val2->tv_usec;
+    }
+}
+#else
+#define qemu_timersub timersub
+#endif
+
+void qemu_set_cloexec(int fd);
+
+/* Starting on QEMU 2.5, qemu_hw_version() returns "2.5+" by default
+ * instead of QEMU_VERSION, so setting hw_version on MachineClass
+ * is no longer mandatory.
+ *
+ * Do NOT change this string, or it will break compatibility on all
+ * machine classes that don't set hw_version.
+ */
+#define QEMU_HW_VERSION "2.5+"
+
+/* QEMU "hardware version" setting. Used to replace code that exposed
+ * QEMU_VERSION to guests in the past and need to keep compatibility.
+ * Do not use qemu_hw_version() in new code.
+ */
+void qemu_set_hw_version(const char *);
+const char *qemu_hw_version(void);
+
+void fips_set_state(bool requested);
+bool fips_get_state(void);
+
+/* Return a dynamically allocated pathname denoting a file or directory that is
+ * appropriate for storing local state.
+ *
+ * @relative_pathname need not start with a directory separator; one will be
+ * added automatically.
+ *
+ * The caller is responsible for releasing the value returned with g_free()
+ * after use.
+ */
+char *qemu_get_local_state_pathname(const char *relative_pathname);
+
+/* Find program directory, and save it for later usage with
+ * qemu_get_exec_dir().
+ * Try OS specific API first, if not working, parse from argv0. */
+void qemu_init_exec_dir(const char *argv0);
+
+/* Get the saved exec dir.
+ * Caller needs to release the returned string by g_free() */
+char *qemu_get_exec_dir(void);
+
+/**
+ * qemu_getauxval:
+ * @type: the auxiliary vector key to lookup
+ *
+ * Search the auxiliary vector for @type, returning the value
+ * or 0 if @type is not present.
+ */
+unsigned long qemu_getauxval(unsigned long type);
+
+void qemu_set_tty_echo(int fd, bool echo);
+
+void os_mem_prealloc(int fd, char *area, size_t sz, Error **errp);
+
+int qemu_read_password(char *buf, int buf_size);
+
+/**
+ * qemu_fork:
+ *
+ * A version of fork that avoids signal handler race
+ * conditions that can lead to child process getting
+ * signals that are otherwise only expected by the
+ * parent. It also resets all signal handlers to the
+ * default settings.
+ *
+ * Returns 0 to child process, pid number to parent
+ * or -1 on failure.
+ */
+pid_t qemu_fork(Error **errp);
+
+#endif
diff --git a/configure b/configure
index 4b808f9..52a0e74 100755
--- a/configure
+++ b/configure
@@ -5746,6 +5746,8 @@ case "$target_name" in
   ;;
   unicore32)
   ;;
+  unicore64)
+  ;;
   xtensa|xtensaeb)
     TARGET_ARCH=xtensa
   ;;
diff --git a/default-configs/unicore64-linux-user.mak b/default-configs/unicore64-linux-user.mak
new file mode 100644
index 0000000..eab8961
--- /dev/null
+++ b/default-configs/unicore64-linux-user.mak
@@ -0,0 +1,2 @@
+# Default configuration for unicore32-linux-user
+CONFIG_GDBSTUB_XML=y
diff --git a/default-configs/unicore64-softmmu.mak b/default-configs/unicore64-softmmu.mak
new file mode 100644
index 0000000..9f6f19b
--- /dev/null
+++ b/default-configs/unicore64-softmmu.mak
@@ -0,0 +1,5 @@
+# Default configuration for unicore64-softmmu
+CONFIG_PUV4=y
+CONFIG_PTIMER=y
+CONFIG_PCKBD=y
+CONFIG_GDBSTUB_XML=y
diff --git a/fpu/softfloat.h b/fpu/softfloat.h
new file mode 100644
index 0000000..1bde349
--- /dev/null
+++ b/fpu/softfloat.h
@@ -0,0 +1,754 @@
+/*
+ * QEMU float support
+ *
+ * The code in this source file is derived from release 2a of the SoftFloat
+ * IEC/IEEE Floating-point Arithmetic Package. Those parts of the code (and
+ * some later contributions) are provided under that license, as detailed below.
+ * It has subsequently been modified by contributors to the QEMU Project,
+ * so some portions are provided under:
+ *  the SoftFloat-2a license
+ *  the BSD license
+ *  GPL-v2-or-later
+ *
+ * Any future contributions to this file after December 1st 2014 will be
+ * taken to be licensed under the Softfloat-2a license unless specifically
+ * indicated otherwise.
+ */
+
+/*
+===============================================================================
+This C header file is part of the SoftFloat IEC/IEEE Floating-point
+Arithmetic Package, Release 2a.
+
+Written by John R. Hauser.  This work was made possible in part by the
+International Computer Science Institute, located at Suite 600, 1947 Center
+Street, Berkeley, California 94704.  Funding was partially provided by the
+National Science Foundation under grant MIP-9311980.  The original version
+of this code was written as part of a project to build a fixed-point vector
+processor in collaboration with the University of California at Berkeley,
+overseen by Profs. Nelson Morgan and John Wawrzynek.  More information
+is available through the Web page `http://HTTP.CS.Berkeley.EDU/~jhauser/
+arithmetic/SoftFloat.html'.
+
+THIS SOFTWARE IS DISTRIBUTED AS IS, FOR FREE.  Although reasonable effort
+has been made to avoid it, THIS SOFTWARE MAY CONTAIN FAULTS THAT WILL AT
+TIMES RESULT IN INCORRECT BEHAVIOR.  USE OF THIS SOFTWARE IS RESTRICTED TO
+PERSONS AND ORGANIZATIONS WHO CAN AND WILL TAKE FULL RESPONSIBILITY FOR ANY
+AND ALL LOSSES, COSTS, OR OTHER PROBLEMS ARISING FROM ITS USE.
+
+Derivative works are acceptable, even for commercial purposes, so long as
+(1) they include prominent notice that the work is derivative, and (2) they
+include prominent notice akin to these four paragraphs for those parts of
+this code that are retained.
+
+===============================================================================
+*/
+
+/* BSD licensing:
+ * Copyright (c) 2006, Fabrice Bellard
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* Portions of this work are licensed under the terms of the GNU GPL,
+ * version 2 or later. See the COPYING file in the top-level directory.
+ */
+
+#ifndef SOFTFLOAT_H
+#define SOFTFLOAT_H
+
+#if defined(CONFIG_SOLARIS) && defined(CONFIG_NEEDS_LIBSUNMATH)
+#include <sunmath.h>
+#endif
+
+
+/* This 'flag' type must be able to hold at least 0 and 1. It should
+ * probably be replaced with 'bool' but the uses would need to be audited
+ * to check that they weren't accidentally relying on it being a larger type.
+ */
+typedef uint8_t flag;
+
+#define LIT64( a ) a##LL
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE floating-point ordering relations
+*----------------------------------------------------------------------------*/
+enum {
+    float_relation_less      = -1,
+    float_relation_equal     =  0,
+    float_relation_greater   =  1,
+    float_relation_unordered =  2
+};
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE floating-point types.
+*----------------------------------------------------------------------------*/
+/* Use structures for soft-float types.  This prevents accidentally mixing
+   them with native int/float types.  A sufficiently clever compiler and
+   sane ABI should be able to see though these structs.  However
+   x86/gcc 3.x seems to struggle a bit, so leave them disabled by default.  */
+//#define USE_SOFTFLOAT_STRUCT_TYPES
+#ifdef USE_SOFTFLOAT_STRUCT_TYPES
+typedef struct {
+    uint16_t v;
+} float16;
+#define float16_val(x) (((float16)(x)).v)
+#define make_float16(x) __extension__ ({ float16 f16_val = {x}; f16_val; })
+#define const_float16(x) { x }
+typedef struct {
+    uint32_t v;
+} float32;
+/* The cast ensures an error if the wrong type is passed.  */
+#define float32_val(x) (((float32)(x)).v)
+#define make_float32(x) __extension__ ({ float32 f32_val = {x}; f32_val; })
+#define const_float32(x) { x }
+typedef struct {
+    uint64_t v;
+} float64;
+#define float64_val(x) (((float64)(x)).v)
+#define make_float64(x) __extension__ ({ float64 f64_val = {x}; f64_val; })
+#define const_float64(x) { x }
+#else
+typedef uint16_t float16;
+typedef uint32_t float32;
+typedef uint64_t float64;
+#define float16_val(x) (x)
+#define float32_val(x) (x)
+#define float64_val(x) (x)
+#define make_float16(x) (x)
+#define make_float32(x) (x)
+#define make_float64(x) (x)
+#define const_float16(x) (x)
+#define const_float32(x) (x)
+#define const_float64(x) (x)
+#endif
+typedef struct {
+    uint64_t low;
+    uint16_t high;
+} floatx80;
+#define make_floatx80(exp, mant) ((floatx80) { mant, exp })
+#define make_floatx80_init(exp, mant) { .low = mant, .high = exp }
+typedef struct {
+#ifdef HOST_WORDS_BIGENDIAN
+    uint64_t high, low;
+#else
+    uint64_t low, high;
+#endif
+} float128;
+#define make_float128(high_, low_) ((float128) { .high = high_, .low = low_ })
+#define make_float128_init(high_, low_) { .high = high_, .low = low_ }
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE floating-point underflow tininess-detection mode.
+*----------------------------------------------------------------------------*/
+enum {
+    float_tininess_after_rounding  = 0,
+    float_tininess_before_rounding = 1
+};
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE floating-point rounding mode.
+*----------------------------------------------------------------------------*/
+enum {
+    float_round_nearest_even = 0,
+    float_round_down         = 1,
+    float_round_up           = 2,
+    float_round_to_zero      = 3,
+    float_round_ties_away    = 4,
+};
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE floating-point exception flags.
+*----------------------------------------------------------------------------*/
+enum {
+    float_flag_invalid   =  1,
+    float_flag_divbyzero =  4,
+    float_flag_overflow  =  8,
+    float_flag_underflow = 16,
+    float_flag_inexact   = 32,
+    float_flag_input_denormal = 64,
+    float_flag_output_denormal = 128
+};
+
+typedef struct float_status {
+    signed char float_detect_tininess;
+    signed char float_rounding_mode;
+    uint8_t     float_exception_flags;
+    signed char floatx80_rounding_precision;
+    /* should denormalised results go to zero and set the inexact flag? */
+    flag flush_to_zero;
+    /* should denormalised inputs go to zero and set the input_denormal flag? */
+    flag flush_inputs_to_zero;
+    flag default_nan_mode;
+    flag snan_bit_is_one;
+} float_status;
+
+static inline void set_float_detect_tininess(int val, float_status *status)
+{
+    status->float_detect_tininess = val;
+}
+static inline void set_float_rounding_mode(int val, float_status *status)
+{
+    status->float_rounding_mode = val;
+}
+static inline void set_float_exception_flags(int val, float_status *status)
+{
+    status->float_exception_flags = val;
+}
+static inline void set_floatx80_rounding_precision(int val,
+                                                   float_status *status)
+{
+    status->floatx80_rounding_precision = val;
+}
+static inline void set_flush_to_zero(flag val, float_status *status)
+{
+    status->flush_to_zero = val;
+}
+static inline void set_flush_inputs_to_zero(flag val, float_status *status)
+{
+    status->flush_inputs_to_zero = val;
+}
+static inline void set_default_nan_mode(flag val, float_status *status)
+{
+    status->default_nan_mode = val;
+}
+static inline void set_snan_bit_is_one(flag val, float_status *status)
+{
+    status->snan_bit_is_one = val;
+}
+static inline int get_float_detect_tininess(float_status *status)
+{
+    return status->float_detect_tininess;
+}
+static inline int get_float_rounding_mode(float_status *status)
+{
+    return status->float_rounding_mode;
+}
+static inline int get_float_exception_flags(float_status *status)
+{
+    return status->float_exception_flags;
+}
+static inline int get_floatx80_rounding_precision(float_status *status)
+{
+    return status->floatx80_rounding_precision;
+}
+static inline flag get_flush_to_zero(float_status *status)
+{
+    return status->flush_to_zero;
+}
+static inline flag get_flush_inputs_to_zero(float_status *status)
+{
+    return status->flush_inputs_to_zero;
+}
+static inline flag get_default_nan_mode(float_status *status)
+{
+    return status->default_nan_mode;
+}
+
+/*----------------------------------------------------------------------------
+| Routine to raise any or all of the software IEC/IEEE floating-point
+| exception flags.
+*----------------------------------------------------------------------------*/
+void float_raise(uint8_t flags, float_status *status);
+
+/*----------------------------------------------------------------------------
+| If `a' is denormal and we are in flush-to-zero mode then set the
+| input-denormal exception and return zero. Otherwise just return the value.
+*----------------------------------------------------------------------------*/
+float32 float32_squash_input_denormal(float32 a, float_status *status);
+float64 float64_squash_input_denormal(float64 a, float_status *status);
+
+/*----------------------------------------------------------------------------
+| Options to indicate which negations to perform in float*_muladd()
+| Using these differs from negating an input or output before calling
+| the muladd function in that this means that a NaN doesn't have its
+| sign bit inverted before it is propagated.
+| We also support halving the result before rounding, as a special
+| case to support the ARM fused-sqrt-step instruction FRSQRTS.
+*----------------------------------------------------------------------------*/
+enum {
+    float_muladd_negate_c = 1,
+    float_muladd_negate_product = 2,
+    float_muladd_negate_result = 4,
+    float_muladd_halve_result = 8,
+};
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE integer-to-floating-point conversion routines.
+*----------------------------------------------------------------------------*/
+float32 int32_to_float32(int32_t, float_status *status);
+float64 int32_to_float64(int32_t, float_status *status);
+float32 uint32_to_float32(uint32_t, float_status *status);
+float64 uint32_to_float64(uint32_t, float_status *status);
+floatx80 int32_to_floatx80(int32_t, float_status *status);
+float128 int32_to_float128(int32_t, float_status *status);
+float32 int64_to_float32(int64_t, float_status *status);
+float64 int64_to_float64(int64_t, float_status *status);
+floatx80 int64_to_floatx80(int64_t, float_status *status);
+float128 int64_to_float128(int64_t, float_status *status);
+float32 uint64_to_float32(uint64_t, float_status *status);
+float64 uint64_to_float64(uint64_t, float_status *status);
+float128 uint64_to_float128(uint64_t, float_status *status);
+
+/* We provide the int16 versions for symmetry of API with float-to-int */
+static inline float32 int16_to_float32(int16_t v, float_status *status)
+{
+    return int32_to_float32(v, status);
+}
+
+static inline float32 uint16_to_float32(uint16_t v, float_status *status)
+{
+    return uint32_to_float32(v, status);
+}
+
+static inline float64 int16_to_float64(int16_t v, float_status *status)
+{
+    return int32_to_float64(v, status);
+}
+
+static inline float64 uint16_to_float64(uint16_t v, float_status *status)
+{
+    return uint32_to_float64(v, status);
+}
+
+/*----------------------------------------------------------------------------
+| Software half-precision conversion routines.
+*----------------------------------------------------------------------------*/
+float16 float32_to_float16(float32, flag, float_status *status);
+float32 float16_to_float32(float16, flag, float_status *status);
+float16 float64_to_float16(float64 a, flag ieee, float_status *status);
+float64 float16_to_float64(float16 a, flag ieee, float_status *status);
+
+/*----------------------------------------------------------------------------
+| Software half-precision operations.
+*----------------------------------------------------------------------------*/
+int float16_is_quiet_nan(float16, float_status *status);
+int float16_is_signaling_nan(float16, float_status *status);
+float16 float16_maybe_silence_nan(float16, float_status *status);
+
+static inline int float16_is_any_nan(float16 a)
+{
+    return ((float16_val(a) & ~0x8000) > 0x7c00);
+}
+
+/*----------------------------------------------------------------------------
+| The pattern for a default generated half-precision NaN.
+*----------------------------------------------------------------------------*/
+float16 float16_default_nan(float_status *status);
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE single-precision conversion routines.
+*----------------------------------------------------------------------------*/
+int16_t float32_to_int16(float32, float_status *status);
+uint16_t float32_to_uint16(float32, float_status *status);
+int16_t float32_to_int16_round_to_zero(float32, float_status *status);
+uint16_t float32_to_uint16_round_to_zero(float32, float_status *status);
+int32_t float32_to_int32(float32, float_status *status);
+int32_t float32_to_int32_round_to_zero(float32, float_status *status);
+uint32_t float32_to_uint32(float32, float_status *status);
+uint32_t float32_to_uint32_round_to_zero(float32, float_status *status);
+int64_t float32_to_int64(float32, float_status *status);
+uint64_t float32_to_uint64(float32, float_status *status);
+uint64_t float32_to_uint64_round_to_zero(float32, float_status *status);
+int64_t float32_to_int64_round_to_zero(float32, float_status *status);
+float64 float32_to_float64(float32, float_status *status);
+floatx80 float32_to_floatx80(float32, float_status *status);
+float128 float32_to_float128(float32, float_status *status);
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE single-precision operations.
+*----------------------------------------------------------------------------*/
+float32 float32_round_to_int(float32, float_status *status);
+float32 float32_add(float32, float32, float_status *status);
+float32 float32_sub(float32, float32, float_status *status);
+float32 float32_mul(float32, float32, float_status *status);
+float32 float32_div(float32, float32, float_status *status);
+float32 float32_rem(float32, float32, float_status *status);
+float32 float32_muladd(float32, float32, float32, int, float_status *status);
+float32 float32_sqrt(float32, float_status *status);
+float32 float32_exp2(float32, float_status *status);
+float32 float32_log2(float32, float_status *status);
+int float32_eq(float32, float32, float_status *status);
+int float32_le(float32, float32, float_status *status);
+int float32_lt(float32, float32, float_status *status);
+int float32_unordered(float32, float32, float_status *status);
+int float32_eq_quiet(float32, float32, float_status *status);
+int float32_le_quiet(float32, float32, float_status *status);
+int float32_lt_quiet(float32, float32, float_status *status);
+int float32_unordered_quiet(float32, float32, float_status *status);
+int float32_compare(float32, float32, float_status *status);
+int float32_compare_quiet(float32, float32, float_status *status);
+float32 float32_min(float32, float32, float_status *status);
+float32 float32_max(float32, float32, float_status *status);
+float32 float32_minnum(float32, float32, float_status *status);
+float32 float32_maxnum(float32, float32, float_status *status);
+float32 float32_minnummag(float32, float32, float_status *status);
+float32 float32_maxnummag(float32, float32, float_status *status);
+int float32_is_quiet_nan(float32, float_status *status);
+int float32_is_signaling_nan(float32, float_status *status);
+float32 float32_maybe_silence_nan(float32, float_status *status);
+float32 float32_scalbn(float32, int, float_status *status);
+
+static inline float32 float32_abs(float32 a)
+{
+    /* Note that abs does *not* handle NaN specially, nor does
+     * it flush denormal inputs to zero.
+     */
+    return make_float32(float32_val(a) & 0x7fffffff);
+}
+
+static inline float32 float32_chs(float32 a)
+{
+    /* Note that chs does *not* handle NaN specially, nor does
+     * it flush denormal inputs to zero.
+     */
+    return make_float32(float32_val(a) ^ 0x80000000);
+}
+
+static inline int float32_is_infinity(float32 a)
+{
+    return (float32_val(a) & 0x7fffffff) == 0x7f800000;
+}
+
+static inline int float32_is_neg(float32 a)
+{
+    return float32_val(a) >> 31;
+}
+
+static inline int float32_is_zero(float32 a)
+{
+    return (float32_val(a) & 0x7fffffff) == 0;
+}
+
+static inline int float32_is_any_nan(float32 a)
+{
+    return ((float32_val(a) & ~(1 << 31)) > 0x7f800000UL);
+}
+
+static inline int float32_is_zero_or_denormal(float32 a)
+{
+    return (float32_val(a) & 0x7f800000) == 0;
+}
+
+static inline float32 float32_set_sign(float32 a, int sign)
+{
+    return make_float32((float32_val(a) & 0x7fffffff) | (sign << 31));
+}
+
+#define float32_zero make_float32(0)
+#define float32_one make_float32(0x3f800000)
+#define float32_ln2 make_float32(0x3f317218)
+#define float32_pi make_float32(0x40490fdb)
+#define float32_half make_float32(0x3f000000)
+#define float32_infinity make_float32(0x7f800000)
+
+
+/*----------------------------------------------------------------------------
+| The pattern for a default generated single-precision NaN.
+*----------------------------------------------------------------------------*/
+float32 float32_default_nan(float_status *status);
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE double-precision conversion routines.
+*----------------------------------------------------------------------------*/
+int16_t float64_to_int16(float64, float_status *status);
+uint16_t float64_to_uint16(float64, float_status *status);
+int16_t float64_to_int16_round_to_zero(float64, float_status *status);
+uint16_t float64_to_uint16_round_to_zero(float64, float_status *status);
+int32_t float64_to_int32(float64, float_status *status);
+int32_t float64_to_int32_round_to_zero(float64, float_status *status);
+uint32_t float64_to_uint32(float64, float_status *status);
+uint32_t float64_to_uint32_round_to_zero(float64, float_status *status);
+int64_t float64_to_int64(float64, float_status *status);
+int64_t float64_to_int64_round_to_zero(float64, float_status *status);
+uint64_t float64_to_uint64(float64 a, float_status *status);
+uint64_t float64_to_uint64_round_to_zero(float64 a, float_status *status);
+float32 float64_to_float32(float64, float_status *status);
+floatx80 float64_to_floatx80(float64, float_status *status);
+float128 float64_to_float128(float64, float_status *status);
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE double-precision operations.
+*----------------------------------------------------------------------------*/
+float64 float64_round_to_int(float64, float_status *status);
+float64 float64_trunc_to_int(float64, float_status *status);
+float64 float64_add(float64, float64, float_status *status);
+float64 float64_sub(float64, float64, float_status *status);
+float64 float64_mul(float64, float64, float_status *status);
+float64 float64_div(float64, float64, float_status *status);
+float64 float64_rem(float64, float64, float_status *status);
+float64 float64_muladd(float64, float64, float64, int, float_status *status);
+float64 float64_sqrt(float64, float_status *status);
+float64 float64_log2(float64, float_status *status);
+int float64_eq(float64, float64, float_status *status);
+int float64_le(float64, float64, float_status *status);
+int float64_lt(float64, float64, float_status *status);
+int float64_unordered(float64, float64, float_status *status);
+int float64_eq_quiet(float64, float64, float_status *status);
+int float64_le_quiet(float64, float64, float_status *status);
+int float64_lt_quiet(float64, float64, float_status *status);
+int float64_unordered_quiet(float64, float64, float_status *status);
+int float64_compare(float64, float64, float_status *status);
+int float64_compare_quiet(float64, float64, float_status *status);
+float64 float64_min(float64, float64, float_status *status);
+float64 float64_max(float64, float64, float_status *status);
+float64 float64_minnum(float64, float64, float_status *status);
+float64 float64_maxnum(float64, float64, float_status *status);
+float64 float64_minnummag(float64, float64, float_status *status);
+float64 float64_maxnummag(float64, float64, float_status *status);
+int float64_is_quiet_nan(float64 a, float_status *status);
+int float64_is_signaling_nan(float64, float_status *status);
+float64 float64_maybe_silence_nan(float64, float_status *status);
+float64 float64_scalbn(float64, int, float_status *status);
+
+static inline float64 float64_abs(float64 a)
+{
+    /* Note that abs does *not* handle NaN specially, nor does
+     * it flush denormal inputs to zero.
+     */
+    return make_float64(float64_val(a) & 0x7fffffffffffffffLL);
+}
+
+static inline float64 float64_chs(float64 a)
+{
+    /* Note that chs does *not* handle NaN specially, nor does
+     * it flush denormal inputs to zero.
+     */
+    return make_float64(float64_val(a) ^ 0x8000000000000000LL);
+}
+
+static inline int float64_is_infinity(float64 a)
+{
+    return (float64_val(a) & 0x7fffffffffffffffLL ) == 0x7ff0000000000000LL;
+}
+
+static inline int float64_is_neg(float64 a)
+{
+    return float64_val(a) >> 63;
+}
+
+static inline int float64_is_zero(float64 a)
+{
+    return (float64_val(a) & 0x7fffffffffffffffLL) == 0;
+}
+
+static inline int float64_is_any_nan(float64 a)
+{
+    return ((float64_val(a) & ~(1ULL << 63)) > 0x7ff0000000000000ULL);
+}
+
+static inline int float64_is_zero_or_denormal(float64 a)
+{
+    return (float64_val(a) & 0x7ff0000000000000LL) == 0;
+}
+
+static inline float64 float64_set_sign(float64 a, int sign)
+{
+    return make_float64((float64_val(a) & 0x7fffffffffffffffULL)
+                        | ((int64_t)sign << 63));
+}
+
+#define float64_zero make_float64(0)
+#define float64_one make_float64(0x3ff0000000000000LL)
+#define float64_ln2 make_float64(0x3fe62e42fefa39efLL)
+#define float64_pi make_float64(0x400921fb54442d18LL)
+#define float64_half make_float64(0x3fe0000000000000LL)
+#define float64_infinity make_float64(0x7ff0000000000000LL)
+
+/*----------------------------------------------------------------------------
+| The pattern for a default generated double-precision NaN.
+*----------------------------------------------------------------------------*/
+float64 float64_default_nan(float_status *status);
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE extended double-precision conversion routines.
+*----------------------------------------------------------------------------*/
+int32_t floatx80_to_int32(floatx80, float_status *status);
+int32_t floatx80_to_int32_round_to_zero(floatx80, float_status *status);
+int64_t floatx80_to_int64(floatx80, float_status *status);
+int64_t floatx80_to_int64_round_to_zero(floatx80, float_status *status);
+float32 floatx80_to_float32(floatx80, float_status *status);
+float64 floatx80_to_float64(floatx80, float_status *status);
+float128 floatx80_to_float128(floatx80, float_status *status);
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE extended double-precision operations.
+*----------------------------------------------------------------------------*/
+floatx80 floatx80_round_to_int(floatx80, float_status *status);
+floatx80 floatx80_add(floatx80, floatx80, float_status *status);
+floatx80 floatx80_sub(floatx80, floatx80, float_status *status);
+floatx80 floatx80_mul(floatx80, floatx80, float_status *status);
+floatx80 floatx80_div(floatx80, floatx80, float_status *status);
+floatx80 floatx80_rem(floatx80, floatx80, float_status *status);
+floatx80 floatx80_sqrt(floatx80, float_status *status);
+int floatx80_eq(floatx80, floatx80, float_status *status);
+int floatx80_le(floatx80, floatx80, float_status *status);
+int floatx80_lt(floatx80, floatx80, float_status *status);
+int floatx80_unordered(floatx80, floatx80, float_status *status);
+int floatx80_eq_quiet(floatx80, floatx80, float_status *status);
+int floatx80_le_quiet(floatx80, floatx80, float_status *status);
+int floatx80_lt_quiet(floatx80, floatx80, float_status *status);
+int floatx80_unordered_quiet(floatx80, floatx80, float_status *status);
+int floatx80_compare(floatx80, floatx80, float_status *status);
+int floatx80_compare_quiet(floatx80, floatx80, float_status *status);
+int floatx80_is_quiet_nan(floatx80, float_status *status);
+int floatx80_is_signaling_nan(floatx80, float_status *status);
+floatx80 floatx80_maybe_silence_nan(floatx80, float_status *status);
+floatx80 floatx80_scalbn(floatx80, int, float_status *status);
+
+static inline floatx80 floatx80_abs(floatx80 a)
+{
+    a.high &= 0x7fff;
+    return a;
+}
+
+static inline floatx80 floatx80_chs(floatx80 a)
+{
+    a.high ^= 0x8000;
+    return a;
+}
+
+static inline int floatx80_is_infinity(floatx80 a)
+{
+    return (a.high & 0x7fff) == 0x7fff && a.low == 0x8000000000000000LL;
+}
+
+static inline int floatx80_is_neg(floatx80 a)
+{
+    return a.high >> 15;
+}
+
+static inline int floatx80_is_zero(floatx80 a)
+{
+    return (a.high & 0x7fff) == 0 && a.low == 0;
+}
+
+static inline int floatx80_is_zero_or_denormal(floatx80 a)
+{
+    return (a.high & 0x7fff) == 0;
+}
+
+static inline int floatx80_is_any_nan(floatx80 a)
+{
+    return ((a.high & 0x7fff) == 0x7fff) && (a.low<<1);
+}
+
+#define floatx80_zero make_floatx80(0x0000, 0x0000000000000000LL)
+#define floatx80_one make_floatx80(0x3fff, 0x8000000000000000LL)
+#define floatx80_ln2 make_floatx80(0x3ffe, 0xb17217f7d1cf79acLL)
+#define floatx80_pi make_floatx80(0x4000, 0xc90fdaa22168c235LL)
+#define floatx80_half make_floatx80(0x3ffe, 0x8000000000000000LL)
+#define floatx80_infinity make_floatx80(0x7fff, 0x8000000000000000LL)
+
+/*----------------------------------------------------------------------------
+| The pattern for a default generated extended double-precision NaN.
+*----------------------------------------------------------------------------*/
+floatx80 floatx80_default_nan(float_status *status);
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE quadruple-precision conversion routines.
+*----------------------------------------------------------------------------*/
+int32_t float128_to_int32(float128, float_status *status);
+int32_t float128_to_int32_round_to_zero(float128, float_status *status);
+int64_t float128_to_int64(float128, float_status *status);
+int64_t float128_to_int64_round_to_zero(float128, float_status *status);
+float32 float128_to_float32(float128, float_status *status);
+float64 float128_to_float64(float128, float_status *status);
+floatx80 float128_to_floatx80(float128, float_status *status);
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE quadruple-precision operations.
+*----------------------------------------------------------------------------*/
+float128 float128_round_to_int(float128, float_status *status);
+float128 float128_add(float128, float128, float_status *status);
+float128 float128_sub(float128, float128, float_status *status);
+float128 float128_mul(float128, float128, float_status *status);
+float128 float128_div(float128, float128, float_status *status);
+float128 float128_rem(float128, float128, float_status *status);
+float128 float128_sqrt(float128, float_status *status);
+int float128_eq(float128, float128, float_status *status);
+int float128_le(float128, float128, float_status *status);
+int float128_lt(float128, float128, float_status *status);
+int float128_unordered(float128, float128, float_status *status);
+int float128_eq_quiet(float128, float128, float_status *status);
+int float128_le_quiet(float128, float128, float_status *status);
+int float128_lt_quiet(float128, float128, float_status *status);
+int float128_unordered_quiet(float128, float128, float_status *status);
+int float128_compare(float128, float128, float_status *status);
+int float128_compare_quiet(float128, float128, float_status *status);
+int float128_is_quiet_nan(float128, float_status *status);
+int float128_is_signaling_nan(float128, float_status *status);
+float128 float128_maybe_silence_nan(float128, float_status *status);
+float128 float128_scalbn(float128, int, float_status *status);
+
+static inline float128 float128_abs(float128 a)
+{
+    a.high &= 0x7fffffffffffffffLL;
+    return a;
+}
+
+static inline float128 float128_chs(float128 a)
+{
+    a.high ^= 0x8000000000000000LL;
+    return a;
+}
+
+static inline int float128_is_infinity(float128 a)
+{
+    return (a.high & 0x7fffffffffffffffLL) == 0x7fff000000000000LL && a.low == 0;
+}
+
+static inline int float128_is_neg(float128 a)
+{
+    return a.high >> 63;
+}
+
+static inline int float128_is_zero(float128 a)
+{
+    return (a.high & 0x7fffffffffffffffLL) == 0 && a.low == 0;
+}
+
+static inline int float128_is_zero_or_denormal(float128 a)
+{
+    return (a.high & 0x7fff000000000000LL) == 0;
+}
+
+static inline int float128_is_any_nan(float128 a)
+{
+    return ((a.high >> 48) & 0x7fff) == 0x7fff &&
+        ((a.low != 0) || ((a.high & 0xffffffffffffLL) != 0));
+}
+
+#define float128_zero make_float128(0, 0)
+
+/*----------------------------------------------------------------------------
+| The pattern for a default generated quadruple-precision NaN.
+*----------------------------------------------------------------------------*/
+float128 float128_default_nan(float_status *status);
+
+#endif /* SOFTFLOAT_H */
diff --git a/hw/gpio/puv4_io_ctl.c b/hw/gpio/puv4_io_ctl.c
new file mode 100644
index 0000000..cc2118b
--- /dev/null
+++ b/hw/gpio/puv4_io_ctl.c
@@ -0,0 +1,79 @@
+#include "cpu.h"
+#include "sysbus.h"
+
+#undef DEBUG_PUV4
+#include "puv4.h"
+
+typedef struct {
+    SysBusDevice busdev;
+    MemoryRegion iomem;
+    uint32_t reg_IO;    /* IO share reg */
+} UC64IOState;
+uint32_t share_io_reg;  /* Fake share IO reg */
+
+static uint64_t uc64_io_ctl_read(void *opaque, target_phys_addr_t offset,
+        unsigned size)
+{
+    UC64IOState *s = opaque;
+
+    if (offset == 0x00) {
+        return (uint64_t)s->reg_IO;
+    } else {
+        DPRINTF("Bad offset %x\n", (int)offset);
+    }
+    return 0;
+}
+
+static void uc64_io_ctl_write(void *opaque, target_phys_addr_t offset,
+        uint64_t value, unsigned size)
+{
+    UC64IOState *s = opaque;
+    if (offset == 0x00) {
+        s->reg_IO = value;
+        share_io_reg = value;  /* update share_io_reg for do_interrupt */
+    } else {
+        DPRINTF("Bad offset %x\n", (int)offset);
+    }
+}
+
+static const MemoryRegionOps uc64_io_ctl_ops = {
+    .read = uc64_io_ctl_read,
+    .write = uc64_io_ctl_write,
+    .impl = {
+        .min_access_size = 4,
+        .max_access_size = 4,
+    },
+    .endianness = DEVICE_NATIVE_ENDIAN,
+};
+
+static int uc64_io_ctl_init(SysBusDevice *dev)
+{
+    UC64IOState *s = FROM_SYSBUS(UC64IOState, dev);
+
+    memory_region_init_io(&s->iomem, &uc64_io_ctl_ops, s, "uc64_io_ctl",
+            PUV4_REGS_OFFSET);
+    sysbus_init_mmio(dev, &s->iomem);
+
+    return 0;
+}
+
+static void uc64_io_ctl_class_init(ObjectClass *klass, void *data)
+{
+    SysBusDeviceClass *sdc = SYS_BUS_DEVICE_CLASS(klass);
+
+    sdc->init = uc64_io_ctl_init;
+}
+
+static const TypeInfo uc64_io_ctl_info = {
+    .name = "uc64_io_ctl",
+    .parent = TYPE_SYS_BUS_DEVICE,
+    .instance_size = sizeof(UC64IOState),
+    .class_init = uc64_io_ctl_class_init,
+};
+
+static void uc64_io_ctl_register_type(void)
+{
+    type_register_static(&uc64_io_ctl_info);
+}
+
+type_init(uc64_io_ctl_register_type)
diff --git a/hw/intc/puv4_intc.c b/hw/intc/puv4_intc.c
new file mode 100644
index 0000000..34bd2dd
--- /dev/null
+++ b/hw/intc/puv4_intc.c
@@ -0,0 +1,140 @@
+/*
+ * INTC device simulation in PKUnity SoC
+ *
+ * Copyright (C) 2010-2012 Guan Xuetao
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation, or any later version.
+ * See the COPYING file in the top-level directory.
+ */
+#include "sysbus.h"
+
+#undef DEBUG_PUV4
+#include "puv4.h"
+
+typedef struct {
+    SysBusDevice busdev;
+    MemoryRegion iomem;
+    qemu_irq parent_irq;
+
+    uint32_t reg_ICMR;
+    uint32_t reg_ICPR;
+} PUV4INTCState;
+
+/* Update interrupt status after enabled or pending bits have been changed.  */
+static void puv4_intc_update(PUV4INTCState *s)
+{
+    if (s->reg_ICMR & s->reg_ICPR) {
+        qemu_irq_raise(s->parent_irq);
+    } else {
+        qemu_irq_lower(s->parent_irq);
+    }
+}
+
+/* Process a change in an external INTC input. */
+static void puv4_intc_handler(void *opaque, int irq, int level)
+{
+    PUV4INTCState *s = opaque;
+
+    DPRINTF("irq 0x%x, level 0x%x\n", irq, level);
+    if (level) {
+        s->reg_ICPR |= (1 << irq);
+    } else {
+        s->reg_ICPR &= ~(1 << irq);
+    }
+
+    if (level) {
+        qemu_irq_raise(s->parent_irq);
+    } else {
+        qemu_irq_lower(s->parent_irq);
+    }
+}
+
+static uint64_t puv4_intc_read(void *opaque, target_phys_addr_t offset,
+        unsigned size)
+{
+    PUV4INTCState *s = opaque;
+    uint32_t ret = 0;
+
+    switch (offset) {
+    case 0x04: /* INTC_ICMR */
+        ret = s->reg_ICMR;
+        break;
+    case 0x0c: /* INTC_ICIP */
+        ret = s->reg_ICPR; /* the same value with ICPR */
+        break;
+    default:
+        DPRINTF("Bad offset %x\n", (int)offset);
+    }
+    DPRINTF("offset 0x%x, value 0x%x\n", offset, ret);
+    return ret;
+}
+
+static void puv4_intc_write(void *opaque, target_phys_addr_t offset,
+        uint64_t value, unsigned size)
+{
+    PUV4INTCState *s = opaque;
+
+    DPRINTF("offset 0x%x, value 0x%x\n", offset, value);
+    switch (offset) {
+    case 0x00: /* INTC_ICLR */
+    case 0x14: /* INTC_ICCR */
+        break;
+    case 0x04: /* INTC_ICMR */
+        s->reg_ICMR = value;
+        break;
+    default:
+        DPRINTF("Bad offset 0x%x\n", (int)offset);
+        return;
+    }
+    puv4_intc_update(s);
+}
+
+static const MemoryRegionOps puv4_intc_ops = {
+    .read = puv4_intc_read,
+    .write = puv4_intc_write,
+    .impl = {
+        .min_access_size = 4,
+        .max_access_size = 4,
+    },
+    .endianness = DEVICE_NATIVE_ENDIAN,
+};
+
+static int puv4_intc_init(SysBusDevice *dev)
+{
+    PUV4INTCState *s = FROM_SYSBUS(PUV4INTCState, dev);
+
+    qdev_init_gpio_in(&s->busdev.qdev, puv4_intc_handler, PUV4_IRQS_NR);
+    sysbus_init_irq(&s->busdev, &s->parent_irq);
+
+    s->reg_ICMR = 0;
+    s->reg_ICPR = 0;
+
+    memory_region_init_io(&s->iomem, &puv4_intc_ops, s, "uc64_soc_intc",
+            PUV4_REGS_OFFSET);
+    sysbus_init_mmio(dev, &s->iomem);
+
+    return 0;
+}
+
+static void puv4_intc_class_init(ObjectClass *klass, void *data)
+{
+    SysBusDeviceClass *sdc = SYS_BUS_DEVICE_CLASS(klass);
+
+    sdc->init = puv4_intc_init;
+}
+
+static const TypeInfo puv4_intc_info = {
+    .name = "uc64_soc_intc",
+    .parent = TYPE_SYS_BUS_DEVICE,
+    .instance_size = sizeof(PUV4INTCState),
+    .class_init = puv4_intc_class_init,
+};
+
+static void puv4_intc_register_type(void)
+{
+    type_register_static(&puv4_intc_info);
+}
+
+type_init(puv4_intc_register_type)
diff --git a/hw/puv4.h b/hw/puv4.h
new file mode 100644
index 0000000..9d8fedb
--- /dev/null
+++ b/hw/puv4.h
@@ -0,0 +1,22 @@
+#ifndef QEMU_HW_PUV4_H
+#define QEMU_HW_PUV4_H
+
+/* All puv4_*.c use DPRINTF for debug. */
+#ifdef DEBUG_PUV4
+#define DPRINTF(fmt, ...) printf("%s: " fmt , __func__, ## __VA_ARGS__)
+#else
+#define DPRINTF(fmt, ...) do {} while (0)
+#endif
+
+#define PUV4_REGS_OFFSET        (0x1000) /* 4K is reasonable */
+#define PUV4_IRQS_NR            (32)
+#define PUV4_IRQS_PS2_KBD       (22)
+#define PUV4_INTC_BASE          (0xfee600000ULL)
+#define PUV4_PS2_BASE           (0xfef100000ULL)
+#define UC64_CSR_BASE           (0xff6200000ULL)
+#define UC64_IO_CTL_BASE        (0xff6100000ULL)
+#define UC64_OST_BASE           (0xfee800000ULL)
+
+extern qemu_irq *uc64_cpu0_intc;
+extern qemu_irq *uc64_cpu1_intc;
+#endif /* !QEMU_HW_PUV4_H */
diff --git a/hw/puv4_csr.c b/hw/puv4_csr.c
new file mode 100644
index 0000000..071e810
--- /dev/null
+++ b/hw/puv4_csr.c
@@ -0,0 +1,93 @@
+#include "cpu.h"
+#include "sysbus.h"
+
+#undef DEBUG_PUV4
+#include "puv4.h"
+
+/* Core Share Reg */
+typedef struct {
+    SysBusDevice busdev;
+    MemoryRegion iomem;
+    uint32_t csr_core0_r1; /* Core0 Reg 1 */
+    uint32_t csr_core1_r1; /* Core1 Reg 1 */
+    uint32_t csr_core0_r2; /* Core0 Reg 2 */
+    uint32_t csr_core1_r2; /* Core1 Reg 2 */
+} UC64CSRState;
+
+static uint64_t uc64_csr_read(void *opaque, target_phys_addr_t offset,
+        unsigned size)
+{
+    UC64CSRState *s = opaque;
+
+    if (offset == 0x00) {
+        return (uint64_t)s->csr_core0_r1;
+    } else if (offset == 0x08) {
+        return (uint64_t)s->csr_core1_r1;
+    } else if (offset == 0x10) {
+        return (uint64_t)s->csr_core0_r2;
+    } else if (offset == 0x18) {
+        return (uint64_t)s->csr_core1_r2;
+    } else {
+        DPRINTF("Bad offset %x\n", (int)offset);
+    }
+    return 0;
+}
+
+static void uc64_csr_write(void *opaque, target_phys_addr_t offset,
+        uint64_t value, unsigned size)
+{
+    UC64CSRState *s = opaque;
+    if (offset == 0x00) {
+        s->csr_core0_r1 = value;
+    } else if (offset == 0x08) {
+        s->csr_core1_r1 = value;
+    } else if (offset == 0x10) {
+        s->csr_core0_r2 = value;
+    } else if (offset == 0x18) {
+        s->csr_core1_r2 = value;
+    } else {
+        DPRINTF("Bad offset %x\n", (int)offset);
+    }
+}
+
+static const MemoryRegionOps uc64_csr_ops = {
+    .read = uc64_csr_read,
+    .write = uc64_csr_write,
+    .impl = {
+        .min_access_size = 4,
+        .max_access_size = 4,
+    },
+    .endianness = DEVICE_NATIVE_ENDIAN,
+};
+
+static int uc64_csr_init(SysBusDevice *dev)
+{
+    UC64CSRState *s = FROM_SYSBUS(UC64CSRState, dev);
+
+    memory_region_init_io(&s->iomem, &uc64_csr_ops, s, "uc64_csr",
+            PUV4_REGS_OFFSET);
+    sysbus_init_mmio(dev, &s->iomem);
+
+    return 0;
+}
+
+static void uc64_csr_class_init(ObjectClass *klass, void *data)
+{
+    SysBusDeviceClass *sdc = SYS_BUS_DEVICE_CLASS(klass);
+
+    sdc->init = uc64_csr_init;
+}
+
+static const TypeInfo uc64_csr_info = {
+    .name = "uc64_csr",
+    .parent = TYPE_SYS_BUS_DEVICE,
+    .instance_size = sizeof(UC64CSRState),
+    .class_init = uc64_csr_class_init,
+};
+
+static void uc64_csr_register_type(void)
+{
+    type_register_static(&uc64_csr_info);
+}
+
+type_init(uc64_csr_register_type)
diff --git a/hw/puv4_intc.c b/hw/puv4_intc.c
new file mode 100644
index 0000000..34bd2dd
--- /dev/null
+++ b/hw/puv4_intc.c
@@ -0,0 +1,140 @@
+/*
+ * INTC device simulation in PKUnity SoC
+ *
+ * Copyright (C) 2010-2012 Guan Xuetao
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation, or any later version.
+ * See the COPYING file in the top-level directory.
+ */
+#include "sysbus.h"
+
+#undef DEBUG_PUV4
+#include "puv4.h"
+
+typedef struct {
+    SysBusDevice busdev;
+    MemoryRegion iomem;
+    qemu_irq parent_irq;
+
+    uint32_t reg_ICMR;
+    uint32_t reg_ICPR;
+} PUV4INTCState;
+
+/* Update interrupt status after enabled or pending bits have been changed.  */
+static void puv4_intc_update(PUV4INTCState *s)
+{
+    if (s->reg_ICMR & s->reg_ICPR) {
+        qemu_irq_raise(s->parent_irq);
+    } else {
+        qemu_irq_lower(s->parent_irq);
+    }
+}
+
+/* Process a change in an external INTC input. */
+static void puv4_intc_handler(void *opaque, int irq, int level)
+{
+    PUV4INTCState *s = opaque;
+
+    DPRINTF("irq 0x%x, level 0x%x\n", irq, level);
+    if (level) {
+        s->reg_ICPR |= (1 << irq);
+    } else {
+        s->reg_ICPR &= ~(1 << irq);
+    }
+
+    if (level) {
+        qemu_irq_raise(s->parent_irq);
+    } else {
+        qemu_irq_lower(s->parent_irq);
+    }
+}
+
+static uint64_t puv4_intc_read(void *opaque, target_phys_addr_t offset,
+        unsigned size)
+{
+    PUV4INTCState *s = opaque;
+    uint32_t ret = 0;
+
+    switch (offset) {
+    case 0x04: /* INTC_ICMR */
+        ret = s->reg_ICMR;
+        break;
+    case 0x0c: /* INTC_ICIP */
+        ret = s->reg_ICPR; /* the same value with ICPR */
+        break;
+    default:
+        DPRINTF("Bad offset %x\n", (int)offset);
+    }
+    DPRINTF("offset 0x%x, value 0x%x\n", offset, ret);
+    return ret;
+}
+
+static void puv4_intc_write(void *opaque, target_phys_addr_t offset,
+        uint64_t value, unsigned size)
+{
+    PUV4INTCState *s = opaque;
+
+    DPRINTF("offset 0x%x, value 0x%x\n", offset, value);
+    switch (offset) {
+    case 0x00: /* INTC_ICLR */
+    case 0x14: /* INTC_ICCR */
+        break;
+    case 0x04: /* INTC_ICMR */
+        s->reg_ICMR = value;
+        break;
+    default:
+        DPRINTF("Bad offset 0x%x\n", (int)offset);
+        return;
+    }
+    puv4_intc_update(s);
+}
+
+static const MemoryRegionOps puv4_intc_ops = {
+    .read = puv4_intc_read,
+    .write = puv4_intc_write,
+    .impl = {
+        .min_access_size = 4,
+        .max_access_size = 4,
+    },
+    .endianness = DEVICE_NATIVE_ENDIAN,
+};
+
+static int puv4_intc_init(SysBusDevice *dev)
+{
+    PUV4INTCState *s = FROM_SYSBUS(PUV4INTCState, dev);
+
+    qdev_init_gpio_in(&s->busdev.qdev, puv4_intc_handler, PUV4_IRQS_NR);
+    sysbus_init_irq(&s->busdev, &s->parent_irq);
+
+    s->reg_ICMR = 0;
+    s->reg_ICPR = 0;
+
+    memory_region_init_io(&s->iomem, &puv4_intc_ops, s, "uc64_soc_intc",
+            PUV4_REGS_OFFSET);
+    sysbus_init_mmio(dev, &s->iomem);
+
+    return 0;
+}
+
+static void puv4_intc_class_init(ObjectClass *klass, void *data)
+{
+    SysBusDeviceClass *sdc = SYS_BUS_DEVICE_CLASS(klass);
+
+    sdc->init = puv4_intc_init;
+}
+
+static const TypeInfo puv4_intc_info = {
+    .name = "uc64_soc_intc",
+    .parent = TYPE_SYS_BUS_DEVICE,
+    .instance_size = sizeof(PUV4INTCState),
+    .class_init = puv4_intc_class_init,
+};
+
+static void puv4_intc_register_type(void)
+{
+    type_register_static(&puv4_intc_info);
+}
+
+type_init(puv4_intc_register_type)
diff --git a/hw/puv4_io_ctl.c b/hw/puv4_io_ctl.c
new file mode 100644
index 0000000..cc2118b
--- /dev/null
+++ b/hw/puv4_io_ctl.c
@@ -0,0 +1,79 @@
+#include "cpu.h"
+#include "sysbus.h"
+
+#undef DEBUG_PUV4
+#include "puv4.h"
+
+typedef struct {
+    SysBusDevice busdev;
+    MemoryRegion iomem;
+    uint32_t reg_IO;    /* IO share reg */
+} UC64IOState;
+uint32_t share_io_reg;  /* Fake share IO reg */
+
+static uint64_t uc64_io_ctl_read(void *opaque, target_phys_addr_t offset,
+        unsigned size)
+{
+    UC64IOState *s = opaque;
+
+    if (offset == 0x00) {
+        return (uint64_t)s->reg_IO;
+    } else {
+        DPRINTF("Bad offset %x\n", (int)offset);
+    }
+    return 0;
+}
+
+static void uc64_io_ctl_write(void *opaque, target_phys_addr_t offset,
+        uint64_t value, unsigned size)
+{
+    UC64IOState *s = opaque;
+    if (offset == 0x00) {
+        s->reg_IO = value;
+        share_io_reg = value;  /* update share_io_reg for do_interrupt */
+    } else {
+        DPRINTF("Bad offset %x\n", (int)offset);
+    }
+}
+
+static const MemoryRegionOps uc64_io_ctl_ops = {
+    .read = uc64_io_ctl_read,
+    .write = uc64_io_ctl_write,
+    .impl = {
+        .min_access_size = 4,
+        .max_access_size = 4,
+    },
+    .endianness = DEVICE_NATIVE_ENDIAN,
+};
+
+static int uc64_io_ctl_init(SysBusDevice *dev)
+{
+    UC64IOState *s = FROM_SYSBUS(UC64IOState, dev);
+
+    memory_region_init_io(&s->iomem, &uc64_io_ctl_ops, s, "uc64_io_ctl",
+            PUV4_REGS_OFFSET);
+    sysbus_init_mmio(dev, &s->iomem);
+
+    return 0;
+}
+
+static void uc64_io_ctl_class_init(ObjectClass *klass, void *data)
+{
+    SysBusDeviceClass *sdc = SYS_BUS_DEVICE_CLASS(klass);
+
+    sdc->init = uc64_io_ctl_init;
+}
+
+static const TypeInfo uc64_io_ctl_info = {
+    .name = "uc64_io_ctl",
+    .parent = TYPE_SYS_BUS_DEVICE,
+    .instance_size = sizeof(UC64IOState),
+    .class_init = uc64_io_ctl_class_init,
+};
+
+static void uc64_io_ctl_register_type(void)
+{
+    type_register_static(&uc64_io_ctl_info);
+}
+
+type_init(uc64_io_ctl_register_type)
diff --git a/hw/puv4_ost.c b/hw/puv4_ost.c
new file mode 100644
index 0000000..d4e4479
--- /dev/null
+++ b/hw/puv4_ost.c
@@ -0,0 +1,142 @@
+/*
+ * PUV4 OST device simulation in PKUnity SoC
+ *
+ * Copyright (C) 2012 Guan Xuetao
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation, or any later version.
+ * See the COPYING file in the top-level directory.
+ */
+#include "ptimer.h"
+#include "sysbus.h"
+
+#undef DEBUG_PUV4
+#include "puv4.h"
+
+/* UniCore64 ostimer implementation. */
+typedef struct {
+    SysBusDevice busdev;
+    MemoryRegion iomem;
+    QEMUBH *bh;
+    qemu_irq irq_otimer;
+    ptimer_state *ptimer;
+
+    uint32_t reg_OSCR;
+    uint32_t reg_OSMR0;
+    uint32_t reg_OSSR;
+} UC64OTMState;
+
+static uint64_t uc64_ost_read(void *opaque, target_phys_addr_t offset,
+        unsigned size)
+{
+    UC64OTMState *s = opaque;
+    uint32_t ret = 0;
+
+    static int ost_init;
+    switch (offset) {
+    case 0x10: /* Counter Register */
+        if (!ost_init) {
+            ptimer_set_limit(s->ptimer, 0xffffffff, 0);
+            ptimer_set_count(s->ptimer, 0);
+            ptimer_run(s->ptimer, 0);
+            ost_init = 1;
+        }
+        ret = s->reg_OSMR0 - (uint32_t)ptimer_get_count(s->ptimer);
+        break;
+    case 0x14:
+        ret = s->reg_OSSR;
+        break;
+    default:
+        DPRINTF("Bad offset %x\n", (int)offset);
+    }
+
+    return ret;
+}
+
+static void uc64_ost_write(void *opaque, target_phys_addr_t offset,
+        uint64_t value, unsigned size)
+{
+    UC64OTMState *s = opaque;
+
+    switch (offset) {
+    case 0x00: /* Match Register */
+        s->reg_OSMR0 = (uint32_t)value;
+        if (s->reg_OSMR0 > s->reg_OSCR) {
+            ptimer_set_count(s->ptimer, s->reg_OSMR0 - s->reg_OSCR);
+        } else {
+            ptimer_set_count(s->ptimer, s->reg_OSMR0
+                    + (0xffffffff - s->reg_OSCR));
+        }
+        ptimer_run(s->ptimer, 0);
+        break;
+    case 0x14:
+        s->reg_OSSR = (uint32_t)value;
+        if (!(s->reg_OSSR & 0x1)) {
+            qemu_irq_lower(s->irq_otimer);
+        }
+        break;
+    default:
+        DPRINTF("Bad offset %x\n", (int)offset);
+    }
+}
+
+static const MemoryRegionOps uc64_ost_ops = {
+    .read = uc64_ost_read,
+    .write = uc64_ost_write,
+    .impl = {
+        .min_access_size = 4,
+        .max_access_size = 4,
+    },
+    .endianness = DEVICE_NATIVE_ENDIAN,
+};
+
+static void uc64_ost_tick(void *opaque)
+{
+    UC64OTMState *s = opaque;
+
+    s->reg_OSCR = s->reg_OSMR0;
+    s->reg_OSSR |= 0x1;
+}
+
+static int uc64_ost_init(SysBusDevice *dev)
+{
+    UC64OTMState *s = FROM_SYSBUS(UC64OTMState, dev);
+
+    s->reg_OSMR0 = 0;
+    s->reg_OSCR = 0;
+    s->reg_OSSR = 0;
+
+    sysbus_init_irq(dev, &s->irq_otimer);
+
+    s->bh = qemu_bh_new(uc64_ost_tick, s);
+    s->ptimer = ptimer_init(s->bh);
+    ptimer_set_freq(s->ptimer, 4 * 1024 * 1024);
+
+    memory_region_init_io(&s->iomem, &uc64_ost_ops,
+            s, "uc64_ost", PUV4_REGS_OFFSET);
+    sysbus_init_mmio(dev, &s->iomem);
+
+    return 0;
+}
+
+static void uc64_ost_class_init(ObjectClass *klass, void *data)
+{
+    SysBusDeviceClass *sdc = SYS_BUS_DEVICE_CLASS(klass);
+
+    sdc->init = uc64_ost_init;
+}
+
+static const TypeInfo uc64_ost_info = {
+    .name = "uc64_ost",
+    .parent = TYPE_SYS_BUS_DEVICE,
+    .instance_size = sizeof(UC64OTMState),
+    .class_init = uc64_ost_class_init,
+};
+
+static void uc64_ost_register_type(void)
+{
+    type_register_static(&uc64_ost_info);
+}
+
+type_init(uc64_ost_register_type)
diff --git a/hw/timer/puv4_ost.c b/hw/timer/puv4_ost.c
new file mode 100644
index 0000000..d4e4479
--- /dev/null
+++ b/hw/timer/puv4_ost.c
@@ -0,0 +1,142 @@
+/*
+ * PUV4 OST device simulation in PKUnity SoC
+ *
+ * Copyright (C) 2012 Guan Xuetao
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation, or any later version.
+ * See the COPYING file in the top-level directory.
+ */
+#include "ptimer.h"
+#include "sysbus.h"
+
+#undef DEBUG_PUV4
+#include "puv4.h"
+
+/* UniCore64 ostimer implementation. */
+typedef struct {
+    SysBusDevice busdev;
+    MemoryRegion iomem;
+    QEMUBH *bh;
+    qemu_irq irq_otimer;
+    ptimer_state *ptimer;
+
+    uint32_t reg_OSCR;
+    uint32_t reg_OSMR0;
+    uint32_t reg_OSSR;
+} UC64OTMState;
+
+static uint64_t uc64_ost_read(void *opaque, target_phys_addr_t offset,
+        unsigned size)
+{
+    UC64OTMState *s = opaque;
+    uint32_t ret = 0;
+
+    static int ost_init;
+    switch (offset) {
+    case 0x10: /* Counter Register */
+        if (!ost_init) {
+            ptimer_set_limit(s->ptimer, 0xffffffff, 0);
+            ptimer_set_count(s->ptimer, 0);
+            ptimer_run(s->ptimer, 0);
+            ost_init = 1;
+        }
+        ret = s->reg_OSMR0 - (uint32_t)ptimer_get_count(s->ptimer);
+        break;
+    case 0x14:
+        ret = s->reg_OSSR;
+        break;
+    default:
+        DPRINTF("Bad offset %x\n", (int)offset);
+    }
+
+    return ret;
+}
+
+static void uc64_ost_write(void *opaque, target_phys_addr_t offset,
+        uint64_t value, unsigned size)
+{
+    UC64OTMState *s = opaque;
+
+    switch (offset) {
+    case 0x00: /* Match Register */
+        s->reg_OSMR0 = (uint32_t)value;
+        if (s->reg_OSMR0 > s->reg_OSCR) {
+            ptimer_set_count(s->ptimer, s->reg_OSMR0 - s->reg_OSCR);
+        } else {
+            ptimer_set_count(s->ptimer, s->reg_OSMR0
+                    + (0xffffffff - s->reg_OSCR));
+        }
+        ptimer_run(s->ptimer, 0);
+        break;
+    case 0x14:
+        s->reg_OSSR = (uint32_t)value;
+        if (!(s->reg_OSSR & 0x1)) {
+            qemu_irq_lower(s->irq_otimer);
+        }
+        break;
+    default:
+        DPRINTF("Bad offset %x\n", (int)offset);
+    }
+}
+
+static const MemoryRegionOps uc64_ost_ops = {
+    .read = uc64_ost_read,
+    .write = uc64_ost_write,
+    .impl = {
+        .min_access_size = 4,
+        .max_access_size = 4,
+    },
+    .endianness = DEVICE_NATIVE_ENDIAN,
+};
+
+static void uc64_ost_tick(void *opaque)
+{
+    UC64OTMState *s = opaque;
+
+    s->reg_OSCR = s->reg_OSMR0;
+    s->reg_OSSR |= 0x1;
+}
+
+static int uc64_ost_init(SysBusDevice *dev)
+{
+    UC64OTMState *s = FROM_SYSBUS(UC64OTMState, dev);
+
+    s->reg_OSMR0 = 0;
+    s->reg_OSCR = 0;
+    s->reg_OSSR = 0;
+
+    sysbus_init_irq(dev, &s->irq_otimer);
+
+    s->bh = qemu_bh_new(uc64_ost_tick, s);
+    s->ptimer = ptimer_init(s->bh);
+    ptimer_set_freq(s->ptimer, 4 * 1024 * 1024);
+
+    memory_region_init_io(&s->iomem, &uc64_ost_ops,
+            s, "uc64_ost", PUV4_REGS_OFFSET);
+    sysbus_init_mmio(dev, &s->iomem);
+
+    return 0;
+}
+
+static void uc64_ost_class_init(ObjectClass *klass, void *data)
+{
+    SysBusDeviceClass *sdc = SYS_BUS_DEVICE_CLASS(klass);
+
+    sdc->init = uc64_ost_init;
+}
+
+static const TypeInfo uc64_ost_info = {
+    .name = "uc64_ost",
+    .parent = TYPE_SYS_BUS_DEVICE,
+    .instance_size = sizeof(UC64OTMState),
+    .class_init = uc64_ost_class_init,
+};
+
+static void uc64_ost_register_type(void)
+{
+    type_register_static(&uc64_ost_info);
+}
+
+type_init(uc64_ost_register_type)
diff --git a/hw/unicore64/Makefile.objs b/hw/unicore64/Makefile.objs
new file mode 100644
index 0000000..921f790
--- /dev/null
+++ b/hw/unicore64/Makefile.objs
@@ -0,0 +1,8 @@
+# For UniCore64 machines and boards
+
+# PKUnity-v4 SoC and board information
+obj-${CONFIG_PUV4} += ../puv4.o
+obj-${CONFIG_PUV4} += ../puv4_io_ctl.o
+obj-${CONFIG_PUV4} += ../puv4_csr.o
+obj-y += cp0_itm.o
+obj-y += cp0_intc.o
diff --git a/hw/unicore64/cp0_intc.c b/hw/unicore64/cp0_intc.c
new file mode 100644
index 0000000..2c36f32
--- /dev/null
+++ b/hw/unicore64/cp0_intc.c
@@ -0,0 +1,105 @@
+/*
+ * CP0 INTC device simulation in PKUnity SoC
+ *
+ * Copyright (C) 2012 Guan Xuetao
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation, or any later version.
+ * See the COPYING file in the top-level directory.
+ */
+#include "cpu.h"
+#include "trace.h"
+#include "../irq.h"
+
+#define UC64_CP0_INTRTYPE_ITM   (1 << 7)
+#define UC64_CP0_INTRTYPE_IPI   (0x600) /* Inter Processor Interrupt */
+
+qemu_irq *uc64_cpu0_intc;
+qemu_irq *uc64_cpu1_intc;
+
+void uc64_cp0_intc_irq_lower(CPUUniCore64State *env, int val)
+{
+    if ((~val & UC64_CP0_INTRTYPE_ITM) &&
+            (env->cp0.c10_intrtype & UC64_CP0_INTRTYPE_ITM)) {
+        if (env->cpu_index == 0) {
+            qemu_irq_lower(uc64_cpu0_intc[2]);
+        } else {
+            qemu_irq_lower(uc64_cpu1_intc[2]);
+        }
+    } else if ((~val & UC64_CP0_INTRTYPE_IPI) &&
+            (env->cp0.c10_intrtype & UC64_CP0_INTRTYPE_IPI)) {
+        if (env->cpu_index == 0) {
+            qemu_irq_lower(uc64_cpu0_intc[0]);
+        } else {
+            qemu_irq_lower(uc64_cpu1_intc[0]);
+        }
+    }
+}
+
+void uc64_cp0_intc_irq_raise(CPUUniCore64State *env, int irq)
+{
+    if (env->cpu_index == 1) {
+        qemu_irq_raise(uc64_cpu1_intc[irq]);
+    } else {
+        qemu_irq_raise(uc64_cpu0_intc[irq]);
+    }
+}
+
+/* Process a change in an external INTC input. */
+static void uc64_intc_cpu_handler(void *opaque, int irq, int level)
+{
+    CPUUniCore64State *env = (CPUUniCore64State *)opaque;
+
+    trace_uc64_intc_cpu_handler(irq, level);
+    int irq_value = 0;
+
+    if (irq == UC64_INTR_ITM) { /* ITIMER */
+        irq_value = UC64_CP0_INTRTYPE_ITM;
+    } else if (irq == UC64_INTR_DEV) {
+        irq_value = 0;
+    } else if (irq == UC64_INTR_SMP) {
+        irq_value = UC64_CP0_INTRTYPE_IPI;
+    } else if (irq == UC64_INTR_OTM) {
+        irq_value = 0;
+    } else {
+        abort();
+    }
+
+    if (level) {
+        if (irq_value) {
+            env->cp0.c10_intrtype |= irq_value;
+        }
+        if (irq == UC64_INTR_ITM) {
+            cpu_interrupt(env, CPU_INTERRUPT_ITM);
+        } else if (irq == UC64_INTR_DEV) {
+            cpu_interrupt(env, CPU_INTERRUPT_HARD);
+        } else if (irq == UC64_INTR_SMP) {
+            cpu_interrupt(env, CPU_INTERRUPT_SMP);
+        } else if (irq == UC64_INTR_OTM) {
+            cpu_interrupt(env, CPU_INTERRUPT_OTM);
+        }
+    } else {
+        if (irq_value) {
+            env->cp0.c10_intrtype &= ~irq_value;
+        }
+        if (irq == UC64_INTR_ITM) {
+            cpu_reset_interrupt(env, CPU_INTERRUPT_ITM);
+        } else if (irq == UC64_INTR_DEV) {
+            cpu_reset_interrupt(env, CPU_INTERRUPT_HARD);
+        } else if (irq == UC64_INTR_SMP) {
+            cpu_reset_interrupt(env, CPU_INTERRUPT_SMP);
+        } else if (irq == UC64_INTR_OTM) {
+            cpu_reset_interrupt(env, CPU_INTERRUPT_OTM);
+        }
+    }
+}
+
+void  uc64_cp0_intc_init(CPUUniCore64State *env)
+{
+    if (env->cpu_index == 0) {
+        uc64_cpu0_intc = qemu_allocate_irqs(uc64_intc_cpu_handler, env, 6);
+    } else {
+        uc64_cpu1_intc = qemu_allocate_irqs(uc64_intc_cpu_handler, env, 6);
+    }
+}
diff --git a/hw/unicore64/cp0_itm.c b/hw/unicore64/cp0_itm.c
new file mode 100644
index 0000000..a6f9e8b
--- /dev/null
+++ b/hw/unicore64/cp0_itm.c
@@ -0,0 +1,56 @@
+/*
+ * CP0 ITM device simulation in PKUnity SoC
+ *
+ * Copyright (C) 2012 Guan Xuetao
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation, or any later version.
+ * See the COPYING file in the top-level directory.
+ */
+#include "cpu.h"
+#include "trace.h"
+#include "../ptimer.h"
+#include "../irq.h"
+
+/* UniCore64 itimer implementation. */
+typedef struct {
+    QEMUBH *bh;
+    ptimer_state *ptimer;
+} UC64CP0ITMState;
+
+static UC64CP0ITMState *uc64_cp0_timer[2];
+
+uint64_t uc64_cp0_itimer_get_delta(int coreid)
+{
+    return (uint64_t)ptimer_get_count(uc64_cp0_timer[coreid]->ptimer);
+}
+
+void uc64_cp0_itimer_set_count(int coreid, uint64_t value)
+{
+    ptimer_set_count(uc64_cp0_timer[coreid]->ptimer, value);
+    ptimer_run(uc64_cp0_timer[coreid]->ptimer, 1);
+}
+
+static void uc64_cp0_itm_tick(void *opaque)
+{
+    CPUUniCore64State *env = (CPUUniCore64State *)opaque;
+
+    trace_uc64_cp0_itm_tick(env->cp0.c10_itimercr, env->cp0.c10_itimermr);
+
+    env->cp0.c10_itimercr = env->cp0.c10_itimermr;
+    uc64_cp0_intc_irq_raise(env, 2);
+}
+
+void uc64_cp0_itm_init(CPUUniCore64State *env)
+{
+    env->cp0.c10_itimercr = 0;
+    env->cp0.c10_itimermr = 0;
+
+    int coreid = env->cpu_index;
+    uc64_cp0_timer[coreid] =
+        (UC64CP0ITMState *)g_malloc0(sizeof(UC64CP0ITMState));
+    uc64_cp0_timer[coreid]->bh = qemu_bh_new(uc64_cp0_itm_tick, env);
+    uc64_cp0_timer[coreid]->ptimer = ptimer_init(uc64_cp0_timer[coreid]->bh);
+    ptimer_set_freq(uc64_cp0_timer[coreid]->ptimer, 480 * 1024 * 1024);
+}
diff --git a/hw/unicore64/puv4.c b/hw/unicore64/puv4.c
new file mode 100644
index 0000000..e72f102
--- /dev/null
+++ b/hw/unicore64/puv4.c
@@ -0,0 +1,116 @@
+#include "ui/console.h"
+#include "elf.h"
+#include "qemu/osdep.h"
+#include "qemu-common.h"
+#include "exec/address-spaces.h"
+#include "hw/sysbus.h"
+#include "hw/boards.h"
+#include "hw/loader.h"
+#include "hw/i386/pc.h"
+#include "qemu/error-report.h"
+#include "sysemu/qtest.h"
+/*#include "exec-memory.h"
+#include "boards.h"
+#include "sysbus.h"
+#include "loader.h"
+#include "pc.h"
+#include "sysemu.h"
+#include "cpu.h"
+*/
+#undef DEBUG_PUV4
+#include "hw/unicore64/puv4.h"
+
+#define KERNEL_LOAD_ADDR        0x03000000
+#define KERNEL_MAX_SIZE         0x00800000 /* Just a guess */
+
+static void puv4_soc_init(CPUUniCore64State *env)
+{
+    qemu_irq intc_irqs[PUV4_IRQS_NR];
+    DeviceState *dev;
+    MemoryRegion *i8042 = g_new(MemoryRegion, 1);
+    int i;
+
+    sysbus_create_varargs("uc64_io_ctl", UC64_IO_CTL_BASE);
+    sysbus_create_varargs("uc64_csr", UC64_CSR_BASE);
+    sysbus_create_simple("uc64_ost", UC64_OST_BASE,
+            uc64_cpu0_intc[UC64_INTR_OTM]);
+    dev = sysbus_create_simple("uc64_soc_intc", PUV4_INTC_BASE,
+            uc64_cpu0_intc[UC64_INTR_DEV]);
+    for (i = 0; i < PUV4_IRQS_NR; i++) {
+        intc_irqs[i] = qdev_get_gpio_in(dev, i);
+    }
+
+    i8042_mm_init(intc_irqs[PUV4_IRQS_PS2_KBD], NULL, i8042,
+            (0x68 << 2), 0x10); /* PS2_CNT reg (0x68<<2) should be excluded */
+    memory_region_add_subregion(get_system_memory(), PUV4_PS2_BASE, i8042);
+}
+
+static void puv4_board_init(CPUUniCore64State *env, ram_addr_t ram_size)
+{
+    MemoryRegion *ram_memory = g_new(MemoryRegion, 1);
+
+    /* SDRAM at address zero.  */
+    memory_region_init_ram(ram_memory, "puv4.ram", ram_size);
+    vmstate_register_ram_global(ram_memory);
+    memory_region_add_subregion(get_system_memory(), 0, ram_memory);
+}
+
+static void puv4_load_kernel(const char *kernel_filename)
+{
+    int size;
+
+    assert(kernel_filename != NULL);
+
+    /* only zImage format supported */
+    size = load_image_targphys(kernel_filename, KERNEL_LOAD_ADDR,
+            KERNEL_MAX_SIZE);
+    if (size < 0) {
+        hw_error("Load kernel error: '%s'\n", kernel_filename);
+    }
+
+    /* cheat curses that we have a graphic console, only under ocd console */
+    graphic_console_init(NULL, NULL, NULL, NULL, NULL);
+}
+
+static void puv4_init(ram_addr_t ram_size, const char *boot_device,
+                     const char *kernel_filename, const char *kernel_cmdline,
+                     const char *initrd_filename, const char *cpu_model)
+{
+    CPUUniCore64State *env;
+
+    if (initrd_filename) {
+        hw_error("Please use kernel built-in initramdisk.\n");
+    }
+
+    if (!cpu_model) {
+        cpu_model = "UniCore-III";
+    }
+
+    int i;
+    for (i = 0; i < smp_cpus; i++) {
+        env = cpu_init(cpu_model);
+        if (!env) {
+            hw_error("Unable to find CPU definition\n");
+        }
+     }
+
+    puv4_soc_init(first_cpu);
+    puv4_board_init(first_cpu, ram_size);
+    puv4_load_kernel(kernel_filename);
+}
+
+static QEMUMachine puv4_machine = {
+    .name = "puv4",
+    .desc = "PKUnity Version-4 based on UniCore64",
+    .init = puv4_init,
+    .is_default = 1,
+    .use_scsi = 0,
+    .max_cpus = 2,
+};
+
+static void puv4_machine_init(void)
+{
+    qemu_register_machine(&puv4_machine);
+}
+
+machine_init(puv4_machine_init)
diff --git a/include/elf.h b/include/elf.h
index 1c2975d..4ef2fd6 100644
--- a/include/elf.h
+++ b/include/elf.h
@@ -111,7 +111,7 @@ typedef int64_t  Elf64_Sxword;
 #define EM_OPENRISC     92        /* OpenCores OpenRISC */
 
 #define EM_UNICORE32    110     /* UniCore32 */
-
+#define EM_UNICORE64    200
 /*
  * This is an interim value that we will use until the committee comes
  * up with a final number.
diff --git a/include/hw/unicore64/puv4.h b/include/hw/unicore64/puv4.h
new file mode 100644
index 0000000..9d8fedb
--- /dev/null
+++ b/include/hw/unicore64/puv4.h
@@ -0,0 +1,22 @@
+#ifndef QEMU_HW_PUV4_H
+#define QEMU_HW_PUV4_H
+
+/* All puv4_*.c use DPRINTF for debug. */
+#ifdef DEBUG_PUV4
+#define DPRINTF(fmt, ...) printf("%s: " fmt , __func__, ## __VA_ARGS__)
+#else
+#define DPRINTF(fmt, ...) do {} while (0)
+#endif
+
+#define PUV4_REGS_OFFSET        (0x1000) /* 4K is reasonable */
+#define PUV4_IRQS_NR            (32)
+#define PUV4_IRQS_PS2_KBD       (22)
+#define PUV4_INTC_BASE          (0xfee600000ULL)
+#define PUV4_PS2_BASE           (0xfef100000ULL)
+#define UC64_CSR_BASE           (0xff6200000ULL)
+#define UC64_IO_CTL_BASE        (0xff6100000ULL)
+#define UC64_OST_BASE           (0xfee800000ULL)
+
+extern qemu_irq *uc64_cpu0_intc;
+extern qemu_irq *uc64_cpu1_intc;
+#endif /* !QEMU_HW_PUV4_H */
diff --git a/include/sysemu/arch_init.h b/include/sysemu/arch_init.h
index d690dfa..3929848 100644
--- a/include/sysemu/arch_init.h
+++ b/include/sysemu/arch_init.h
@@ -23,6 +23,7 @@ enum {
     QEMU_ARCH_UNICORE32 = (1 << 14),
     QEMU_ARCH_MOXIE = (1 << 15),
     QEMU_ARCH_TRICORE = (1 << 16),
+    QEMU_ARCH_UNICORE64 = (1<<15),
 };
 
 extern const uint32_t arch_type;
diff --git a/linux-user/elfload.c b/linux-user/elfload.c
index f807baf..c37accf 100644
--- a/linux-user/elfload.c
+++ b/linux-user/elfload.c
@@ -612,6 +612,34 @@ static void elf_core_copy_regs(target_elf_gregset_t *regs, const CPUUniCore32Sta
 
 #endif
 
+#ifdef TARGET_UNICORE64
+
+#define ELF_START_MMAP          0ULL
+
+#define elf_check_arch(x)       ((x) == EM_UNICORE64)
+
+#define ELF_CLASS               ELFCLASS64
+#define ELF_ARCH                EM_UNICORE64
+
+static inline void init_thread(struct target_pt_regs *regs,
+        struct image_info *infop)
+{
+    regs->UC64_R31 = infop->entry;
+    regs->UC64_R29 = infop->start_stack;
+}
+
+#define ELF_NREG                UC64_REGS_NUM
+typedef target_elf_greg_t  target_elf_gregset_t[ELF_NREG];
+
+/* UNICORE64 FIXME:
+ * static void elf_core_copy_regs(target_elf_gregset_t *regs,
+ *         const CPUUniCore64State *env)
+ *         {
+ *             abort();
+ *             }
+ */
+#endif
+
 #ifdef TARGET_SPARC
 #ifdef TARGET_SPARC64
 
diff --git a/linux-user/main.c b/linux-user/main.c
index f2f4d2f..dae4e64 100644
--- a/linux-user/main.c
+++ b/linux-user/main.c
@@ -1232,6 +1232,14 @@ error:
 }
 #endif
 
+#ifdef TARGET_UNICORE64
+void cpu_loop(CPUUniCore64State *env)
+{
+	    abort();
+}
+#endif
+
+
 #ifdef TARGET_SPARC
 #define SPARC64_STACK_BIAS 2047
 
@@ -4282,6 +4290,8 @@ int main(int argc, char **argv, char **envp)
         cpu_model = "any";
 #elif defined(TARGET_UNICORE32)
         cpu_model = "any";
+#elif defined(TARGET_UNICORE64)
+	cpu_model = "any";
 #elif defined(TARGET_M68K)
         cpu_model = "any";
 #elif defined(TARGET_SPARC)
@@ -4610,6 +4620,13 @@ int main(int argc, char **argv, char **envp)
             env->regs[i] = regs->uregs[i];
         }
     }
+#elif defined(TARGET_UNICORE64)
+    {
+        int i;
+        for (i = 0; i < 32; i++) {
+            env->regs[i] = regs->uc64_regs[i];
+        }
+    }
 #elif defined(TARGET_SPARC)
     {
         int i;
diff --git a/linux-user/syscall_defs.h b/linux-user/syscall_defs.h
index 7835654..c7de293 100644
--- a/linux-user/syscall_defs.h
+++ b/linux-user/syscall_defs.h
@@ -68,7 +68,8 @@
 #if defined(TARGET_I386) || defined(TARGET_ARM) || defined(TARGET_SH4) \
     || defined(TARGET_M68K) || defined(TARGET_CRIS) \
     || defined(TARGET_UNICORE32) || defined(TARGET_S390X) \
-    || defined(TARGET_OPENRISC) || defined(TARGET_TILEGX)
+    || defined(TARGET_OPENRISC) || defined(TARGET_TILEGX) \
+    || defined(TARGET_UNICORE64)
 
 #define TARGET_IOC_SIZEBITS	14
 #define TARGET_IOC_DIRBITS	2
@@ -387,7 +388,7 @@ int do_sigaction(int sig, const struct target_sigaction *act,
     || defined(TARGET_M68K) || defined(TARGET_ALPHA) || defined(TARGET_CRIS) \
     || defined(TARGET_MICROBLAZE) || defined(TARGET_UNICORE32) \
     || defined(TARGET_S390X) || defined(TARGET_OPENRISC) \
-    || defined(TARGET_TILEGX)
+    || defined(TARGET_TILEGX) || defined(TARGET_UNICORE64)
 
 #if defined(TARGET_SPARC)
 #define TARGET_SA_NOCLDSTOP    8u
@@ -1250,7 +1251,8 @@ struct target_winsize {
 
 #if (defined(TARGET_I386) && defined(TARGET_ABI32)) \
     || (defined(TARGET_ARM) && defined(TARGET_ABI32)) \
-    || defined(TARGET_CRIS) || defined(TARGET_UNICORE32)
+    || defined(TARGET_CRIS) || defined(TARGET_UNICORE32) \
+    || defined(TARGET_UNICORE64)
 struct target_stat {
 	unsigned short st_dev;
 	unsigned short __pad1;
diff --git a/linux-user/unicore64/syscall_nr.h b/linux-user/unicore64/syscall_nr.h
new file mode 100644
index 0000000..92ae27e
--- /dev/null
+++ b/linux-user/unicore64/syscall_nr.h
@@ -0,0 +1,311 @@
+/*
+ * This file contains the system call numbers for UniCore64 oldabi.
+ *
+ * Copyright (C) 2012 Guan Xuetao
+ */
+#define TARGET_NR_io_setup 0
+#define TARGET_NR_io_destroy 1
+#define TARGET_NR_io_submit 2
+#define TARGET_NR_io_cancel 3
+#define TARGET_NR_io_getevents 4
+#define TARGET_NR_setxattr 5
+#define TARGET_NR_lsetxattr 6
+#define TARGET_NR_fsetxattr 7
+#define TARGET_NR_getxattr 8
+#define TARGET_NR_lgetxattr 9
+#define TARGET_NR_fgetxattr 10
+#define TARGET_NR_listxattr 11
+#define TARGET_NR_llistxattr 12
+#define TARGET_NR_flistxattr 13
+#define TARGET_NR_removexattr 14
+#define TARGET_NR_lremovexattr 15
+#define TARGET_NR_fremovexattr 16
+#define TARGET_NR_getcwd 17
+#define TARGET_NR_lookup_dcookie 18
+#define TARGET_NR_eventfd2 19
+#define TARGET_NR_epoll_create1 20
+#define TARGET_NR_epoll_ctl 21
+#define TARGET_NR_epoll_pwait 22
+#define TARGET_NR_dup 23
+#define TARGET_NR_dup3 24
+#define TARGET_NR_fcntl 25
+#define TARGET_NR_inotify_init1 26
+#define TARGET_NR_inotify_add_watch 27
+#define TARGET_NR_inotify_rm_watch 28
+#define TARGET_NR_ioctl 29
+#define TARGET_NR_ioprio_set 30
+#define TARGET_NR_ioprio_get 31
+#define TARGET_NR_flock 32
+#define TARGET_NR_mknodat 33
+#define TARGET_NR_mkdirat 34
+#define TARGET_NR_unlinkat 35
+#define TARGET_NR_symlinkat 36
+#define TARGET_NR_linkat 37
+#define TARGET_NR_renameat 38
+#define TARGET_NR_umount2 39
+#define TARGET_NR_mount 40
+#define TARGET_NR_pivot_root 41
+#define TARGET_NR_nfsservctl 42
+#define TARGET_NR_statfs 43
+#define TARGET_NR_fstatfs 44
+#define TARGET_NR_truncate 45
+#define TARGET_NR_ftruncate 46
+#define TARGET_NR_fallocate 47
+#define TARGET_NR_faccessat 48
+#define TARGET_NR_chdir 49
+#define TARGET_NR_fchdir 50
+#define TARGET_NR_chroot 51
+#define TARGET_NR_fchmod 52
+#define TARGET_NR_fchmodat 53
+#define TARGET_NR_fchownat 54
+#define TARGET_NR_fchown 55
+#define TARGET_NR_openat 56
+#define TARGET_NR_close 57
+#define TARGET_NR_vhangup 58
+#define TARGET_NR_pipe 59 /* pipe2 */
+#define TARGET_NR_quotactl 60
+#define TARGET_NR_getdents64 61
+#define TARGET_NR_lseek 62
+#define TARGET_NR_read 63
+#define TARGET_NR_write 64
+#define TARGET_NR_readv 65
+#define TARGET_NR_writev 66
+#define TARGET_NR_pread64 67
+#define TARGET_NR_pwrite64 68
+#define TARGET_NR_preadv 69
+#define TARGET_NR_pwritev 70
+#define TARGET_NR_sendfile 71
+#define TARGET_NR_pselect6 72
+#define TARGET_NR_ppoll 73
+#define TARGET_NR_signalfd4 74
+#define TARGET_NR_vmsplice 75
+#define TARGET_NR_splice 76
+#define TARGET_NR_tee 77
+#define TARGET_NR_readlinkat 78
+#define TARGET_NR_fstatat 79
+#define TARGET_NR_fstat 80
+#define TARGET_NR_sync 81
+#define TARGET_NR_fsync 82
+#define TARGET_NR_fdatasync 83
+#define TARGET_NR_sync_file_range2 84
+#define TARGET_NR_timerfd_create 85
+#define TARGET_NR_timerfd_settime 86
+#define TARGET_NR_timerfd_gettime 87
+#define TARGET_NR_utimensat 88
+#define TARGET_NR_acct 89
+#define TARGET_NR_capget 90
+#define TARGET_NR_capset 91
+#define TARGET_NR_personality 92
+#define TARGET_NR_exit 93
+#define TARGET_NR_exit_group 94
+#define TARGET_NR_waitid 95
+#define TARGET_NR_set_tid_address 96
+#define TARGET_NR_unshare 97
+#define TARGET_NR_futex 98
+#define TARGET_NR_set_robust_list 99
+#define TARGET_NR_get_robust_list 100
+#define TARGET_NR_nanosleep 101
+#define TARGET_NR_getitimer 102
+#define TARGET_NR_setitimer 103
+#define TARGET_NR_kexec_load 104
+#define TARGET_NR_init_module 105
+#define TARGET_NR_delete_module 106
+#define TARGET_NR_timer_create 107
+#define TARGET_NR_timer_gettime 108
+#define TARGET_NR_timer_getoverrun 109
+#define TARGET_NR_timer_settime 110
+#define TARGET_NR_timer_delete 111
+#define TARGET_NR_clock_settime 112
+#define TARGET_NR_clock_gettime 113
+#define TARGET_NR_clock_getres 114
+#define TARGET_NR_clock_nanosleep 115
+#define TARGET_NR_syslog 116
+#define TARGET_NR_ptrace 117
+#define TARGET_NR_sched_setparam 118
+#define TARGET_NR_sched_setscheduler 119
+#define TARGET_NR_sched_getscheduler 120
+#define TARGET_NR_sched_getparam 121
+#define TARGET_NR_sched_setaffinity 122
+#define TARGET_NR_sched_getaffinity 123
+#define TARGET_NR_sched_yield 124
+#define TARGET_NR_sched_get_priority_max 125
+#define TARGET_NR_sched_get_priority_min 126
+#define TARGET_NR_sched_rr_get_interval 127
+#define TARGET_NR_restart_syscall 128
+#define TARGET_NR_kill 129
+#define TARGET_NR_tkill 130
+#define TARGET_NR_tgkill 131
+#define TARGET_NR_sigaltstack 132
+#define TARGET_NR_rt_sigsuspend 133
+#define TARGET_NR_rt_sigaction 134
+#define TARGET_NR_rt_sigprocmask 135
+#define TARGET_NR_rt_sigpending 136
+#define TARGET_NR_rt_sigtimedwait 137
+#define TARGET_NR_rt_sigqueueinfo 138
+#define TARGET_NR_rt_sigreturn 139
+#define TARGET_NR_setpriority 140
+#define TARGET_NR_getpriority 141
+#define TARGET_NR_reboot 142
+#define TARGET_NR_setregid 143
+#define TARGET_NR_setgid 144
+#define TARGET_NR_setreuid 145
+#define TARGET_NR_setuid 146
+#define TARGET_NR_setresuid 147
+#define TARGET_NR_getresuid 148
+#define TARGET_NR_setresgid 149
+#define TARGET_NR_getresgid 150
+#define TARGET_NR_setfsuid 151
+#define TARGET_NR_setfsgid 152
+#define TARGET_NR_times 153
+#define TARGET_NR_setpgid 154
+#define TARGET_NR_getpgid 155
+#define TARGET_NR_getsid 156
+#define TARGET_NR_setsid 157
+#define TARGET_NR_getgroups 158
+#define TARGET_NR_setgroups 159
+#define TARGET_NR_uname 160
+#define TARGET_NR_sethostname 161
+#define TARGET_NR_setdomainname 162
+#define TARGET_NR_getrlimit 163
+#define TARGET_NR_setrlimit 164
+#define TARGET_NR_getrusage 165
+#define TARGET_NR_umask 166
+#define TARGET_NR_prctl 167
+#define TARGET_NR_getcpu 168
+#define TARGET_NR_gettimeofday 169
+#define TARGET_NR_settimeofday 170
+#define TARGET_NR_adjtimex 171
+#define TARGET_NR_getpid 172
+#define TARGET_NR_getppid 173
+#define TARGET_NR_getuid 174
+#define TARGET_NR_geteuid 175
+#define TARGET_NR_getgid 176
+#define TARGET_NR_getegid 177
+#define TARGET_NR_gettid 178
+#define TARGET_NR_sysinfo 179
+#define TARGET_NR_mq_open 180
+#define TARGET_NR_mq_unlink 181
+#define TARGET_NR_mq_timedsend 182
+#define TARGET_NR_mq_timedreceive 183
+#define TARGET_NR_mq_notify 184
+#define TARGET_NR_mq_getsetattr 185
+#define TARGET_NR_msgget 186
+#define TARGET_NR_msgctl 187
+#define TARGET_NR_msgrcv 188
+#define TARGET_NR_msgsnd 189
+#define TARGET_NR_semget 190
+#define TARGET_NR_semctl 191
+#define TARGET_NR_semtimedop 192
+#define TARGET_NR_semop 193
+#define TARGET_NR_shmget 194
+#define TARGET_NR_shmctl 195
+#define TARGET_NR_shmat 196
+#define TARGET_NR_shmdt 197
+#define TARGET_NR_socket 198
+#define TARGET_NR_socketpair 199
+#define TARGET_NR_bind 200
+#define TARGET_NR_listen 201
+#define TARGET_NR_accept 202
+#define TARGET_NR_connect 203
+#define TARGET_NR_getsockname 204
+#define TARGET_NR_getpeername 205
+#define TARGET_NR_sendto 206
+#define TARGET_NR_recvfrom 207
+#define TARGET_NR_setsockopt 208
+#define TARGET_NR_getsockopt 209
+#define TARGET_NR_shutdown 210
+#define TARGET_NR_sendmsg 211
+#define TARGET_NR_recvmsg 212
+#define TARGET_NR_readahead 213
+#define TARGET_NR_brk 214
+#define TARGET_NR_munmap 215
+#define TARGET_NR_mremap 216
+#define TARGET_NR_add_key 217
+#define TARGET_NR_request_key 218
+#define TARGET_NR_keyctl 219
+#define TARGET_NR_clone 220
+#define TARGET_NR_execve 221
+#define TARGET_NR_mmap 222
+#define TARGET_NR_fadvise64_64 223
+#define TARGET_NR_swapon 224
+#define TARGET_NR_swapoff 225
+#define TARGET_NR_mprotect 226
+#define TARGET_NR_msync 227
+#define TARGET_NR_mlock 228
+#define TARGET_NR_munlock 229
+#define TARGET_NR_mlockall 230
+#define TARGET_NR_munlockall 231
+#define TARGET_NR_mincore 232
+#define TARGET_NR_madvise 233
+#define TARGET_NR_remap_file_pages 234
+#define TARGET_NR_mbind 235
+#define TARGET_NR_get_mempolicy 236
+#define TARGET_NR_set_mempolicy 237
+#define TARGET_NR_migrate_pages 238
+#define TARGET_NR_move_pages 239
+#define TARGET_NR_rt_tgsigqueueinfo 240
+#define TARGET_NR_perf_event_open 241
+#define TARGET_NR_accept4 242
+#define TARGET_NR_recvmmsg 243
+
+/* arch_specific_syscall */
+#define TARGET_NR_arch_specific_syscall 244
+
+#define TARGET_NR_wait4 260
+#define TARGET_NR_prlimit64 261
+#define TARGET_NR_fanotify_init 262
+#define TARGET_NR_fanotify_mark 263
+#define TARGET_NR_name_to_handle_at         264
+#define TARGET_NR_open_by_handle_at         265
+#define TARGET_NR_clock_adjtime 266
+#define TARGET_NR_syncfs 267
+#define TARGET_NR_setns 268
+#define TARGET_NR_sendmmsg 269
+#define TARGET_NR_process_vm_readv 270
+#define TARGET_NR_process_vm_writev 271
+#define TARGET_NR_syscalls 272
+
+/* FIXME: Obsolete syscalls */
+#define TARGET_NR_open 1024
+#define TARGET_NR_link 1025
+#define TARGET_NR_unlink 1026
+#define TARGET_NR_mknod 1027
+#define TARGET_NR_chmod 1028
+#define TARGET_NR_chown 1029
+#define TARGET_NR_mkdir 1030
+#define TARGET_NR_rmdir 1031
+#define TARGET_NR_lchown 1032
+#define TARGET_NR_access 1033
+#define TARGET_NR_rename 1034
+#define TARGET_NR_readlink 1035
+#define TARGET_NR_symlink 1036
+#define TARGET_NR_utimes 1037
+#define TARGET_NR_stat 1038
+#define TARGET_NR_lstat 1039
+
+/* FIXME: Deprecated syscalls */
+#define TARGET_NR_alarm 1059
+#define TARGET_NR_getpgrp 1060
+#define TARGET_NR_pause 1061
+#define TARGET_NR_time 1062
+#define TARGET_NR_utime 1063
+#define TARGET_NR_creat 1064
+#define TARGET_NR_getdents 1065
+#define TARGET_NR_futimesat 1066
+#define TARGET_NR_select 1067
+#define TARGET_NR_poll 1068
+#define TARGET_NR_epoll_wait 1069
+#define TARGET_NR_ustat 1070
+#define TARGET_NR_vfork 1071
+#define TARGET_NR_oldwait4 1072
+#define TARGET_NR_recv 1073
+#define TARGET_NR_send 1074
+#define TARGET_NR_bdflush 1075
+#define TARGET_NR_umount 1076
+#define TARGET_NR_uselib 1077
+#define TARGET_NR__sysctl 1078
+#define TARGET_NR_fork 1079
+
+/* FIXME: Just required by QEMU definitions */
+#define TARGET_NR_dup2 1041
+#define TARGET_NR_newfstatat 1054
diff --git a/linux-user/unicore64/target_cpu.h b/linux-user/unicore64/target_cpu.h
new file mode 100644
index 0000000..3bec3aa
--- /dev/null
+++ b/linux-user/unicore64/target_cpu.h
@@ -0,0 +1,238 @@
+/*
+ * UniCore64 virtual CPU header
+ *
+ * Copyright (C) 2012 Guan Xuetao
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation, or (at your option) any
+ * later version. See the COPYING file in the top-level directory.
+ */
+#ifndef QEMU_UNICORE64_CPU_H
+#define QEMU_UNICORE64_CPU_H
+
+#define TARGET_LONG_BITS                64
+#define TARGET_PAGE_BITS                12
+
+#define TARGET_PHYS_ADDR_SPACE_BITS     64
+#define TARGET_VIRT_ADDR_SPACE_BITS     64
+
+#define ELF_MACHINE                     EM_UNICORE64
+
+#define CPUArchState                    struct CPUUniCore64State
+
+#define NB_MMU_MODES                     2
+#define TARGET_HAS_ICE                   1
+
+#include "config.h"
+#include "qemu-common.h"
+#include "cpu-qom.h"
+#include "exec/cpu-defs.h"
+#include "fpu/softfloat.h"
+
+typedef struct CPUUniCore64State {
+    /* Regs for current mode.  */
+    uint64_t regs[32];
+    /* Frequently accessed ASR bits are stored separately for efficiently.
+       This contains all the other bits.  Use asr_{read,write} to access
+       the whole ASR.  */
+    uint64_t uncached_asr;
+    uint64_t uncached_afr;
+    uint64_t bsr;
+    uint64_t bfr;
+
+    /* Banked registers. */
+    uint64_t banked_r29[3];
+    uint64_t banked_r30[3];
+
+    /* AFR cache for faster execution */
+    uint64_t VF; /* V is the bit 31. All other bits are undefined */
+    uint64_t CF; /* 0 or 1 */
+    uint64_t ZF; /* Z set if zero.  */
+    uint64_t NF; /* N is bit 31. All other bits are undefined.  */
+
+    /* Addr for LL-SC */
+    uint64_t llsc_exclusive_addr;
+    /* lock for LL-SC */
+    uint64_t llsc_exclusive_lock;
+    /* value for LL-SC */
+    uint64_t llsc_exclusive_val;
+
+    /* System control coprocessor (cp0) */
+    struct {
+        uint64_t c0_cpuid;
+        uint64_t c0_cachetype;
+        uint64_t c1_sys; /* System control register.  */
+        uint64_t c2_base; /* MMU translation table base.  */
+        uint64_t c3_ifaultstatus; /* Instruction fault status register.  */
+        uint64_t c3_dfaultstatus; /* Data fault status register.  */
+        uint64_t c4_dtrapaddr; /* Fault address registers.  */
+        uint64_t c4_epc; /* Exception address register.*/
+        uint64_t c8_mrar[16]; /* Memory region configuration registers */
+        uint64_t c9_excpbase; /* Exception base register. */
+        uint64_t c10_intrtype; /* Interrupt type register. */
+        uint64_t c10_itimercr; /* Itimer count register. */
+        uint64_t c10_itimermr; /* Itimer match register. */
+        uint64_t c11_rwmargin; /* Read/Write margin control register */
+        uint64_t c12_sysu[8]; /* SysU registers. */
+    } cp0;
+
+    /* UniCore-F64 coprocessor state.  */
+    struct {
+        float64 regs[16];
+        uint64_t fpsr; /* float point status reg */
+        uint64_t fpfr; /* float point flag reg */
+        float_status qemu_fp_status; /* QEMU emulator float status */
+    } ucf64;
+
+    CPU_COMMON
+
+} CPUUniCore64State;
+
+struct UniCore64CPU {
+        CPUState parent_obj;
+        CPUUniCore64State env;
+};
+
+static inline UniCore64CPU *uc64_env_get_cpu(CPUUniCore64State *env)
+{
+        return container_of(env, UniCore64CPU, env);
+}
+#define ENV_GET_CPU(e) CPU(uc64_env_get_cpu(e))
+#define ENV_OFFSET offsetof(UniCore64CPU, env)
+
+
+void uc32_cpu_do_interrupt(CPUState *cpu);
+bool uc32_cpu_exec_interrupt(CPUState *cpu, int int_req);
+void uc32_cpu_dump_state(CPUState *cpu, FILE *f,
+                fprintf_function cpu_fprintf, int flags);
+hwaddr uc32_cpu_get_phys_page_debug(CPUState *cpu, vaddr addr);
+
+#define ASR_IDX_USER            (0)
+#define ASR_IDX_PRIV            (1)
+#define ASR_IDX_DEBUG           (2)
+#define ASR_MODE_SELECT         (ASR_MODE_USER | ASR_MODE_PRIV | ASR_MODE_DEBUG)
+#define ASR_MODE_USER           (1 << ASR_IDX_USER)
+#define ASR_MODE_PRIV           (1 << ASR_IDX_PRIV)
+#define ASR_MODE_DEBUG          (1 << ASR_IDX_DEBUG)
+#define ASR_INTR_SELECT         (0x3f << 5)
+#define AFR_V                   (1 << 0)
+#define AFR_C                   (1 << 1)
+#define AFR_Z                   (1 << 2)
+#define AFR_N                   (1 << 3)
+
+#define AFR_READ(env)   (((env->NF >> 63) << 3) | ((env->ZF == 0) << 2) | \
+                        (env->CF << 1) | (env->VF >> 63))
+
+#define UC64_EXCP_PRIV          0x08
+#define UC64_EXCP_ITRAP         0x0c
+#define UC64_EXCP_DTRAP         0x10
+#define UC64_INTR_IPI           0x18
+#define UC64_INTR_ITIMER        0x20
+#define UC64_INTR_PUV4          0x24
+#define UC64_INTR_OTIMER        0x28
+
+/* Return the current ASR value.  */
+target_ulong cpu_asr_read(CPUUniCore64State *env1);
+/* Set the ASR.  Note that some bits of mask must be all-set or all-clear.  */
+void cpu_asr_write(CPUUniCore64State *env, target_ulong val, target_ulong msk);
+
+
+/* Return the current AFR value.  */
+target_ulong cpu_afr_read(CPUUniCore64State *env1);
+/* Set the AFR.  Note that some bits of mask must be all-set or all-clear.  */
+void cpu_afr_write(CPUUniCore64State *env, target_ulong val, target_ulong msk);
+
+#define cpu_init                        uc64_cpu_init
+//#define cpu_exec                        uc64_cpu_exec
+#define cpu_signal_handler              uc64_cpu_signal_handler
+#define cpu_handle_mmu_fault            uc64_cpu_handle_mmu_fault
+
+/* UniCore64-specific interrupt pending bits. */
+#define CPU_INTERRUPT_ITM    CPU_INTERRUPT_TGT_INT_0
+#define CPU_INTERRUPT_SMP    CPU_INTERRUPT_TGT_INT_1
+#define CPU_INTERRUPT_OTM    CPU_INTERRUPT_TGT_INT_2
+
+CPUUniCore64State *uc64_cpu_init(const char *cpu_model);
+//int uc64_cpu_exec(CPUUniCore64State *s);
+int uc64_cpu_signal_handler(int host_signum, void *pinfo, void *puc);
+int uc64_cpu_handle_mmu_fault(CPUUniCore64State *env, target_ulong address,
+        int rw, int mmu_idx);
+
+void uc64_translate_init(void);
+void switch_mode(CPUUniCore64State *, int);
+
+//#define CPU_SAVE_VERSION       2
+
+/* MMU modes definitions */
+#define MMU_MODE0_SUFFIX       _kernel
+#define MMU_MODE1_SUFFIX       _user
+#define MMU_USER_IDX           1
+
+static inline int cpu_mmu_index(CPUUniCore64State *env, bool ifetch)
+{
+    return (env->uncached_asr & ASR_MODE_SELECT) == ASR_MODE_USER ? 1 : 0;
+}
+/*
+static inline void cpu_clone_regs(CPUUniCore64State *env, target_ulong newsp)
+{
+    if (newsp) {
+        env->regs[29] = newsp;
+    }
+    env->regs[0] = 0;
+}
+
+static inline void cpu_set_tls(CPUUniCore64State *env, target_ulong newtls)
+{
+    abort();
+}
+*/
+#include "exec/cpu-all.h"
+#include "cpu-qom.h"
+//#include "exec/exec-all.h"
+/*
+static inline void cpu_pc_from_tb(CPUUniCore64State *env, TranslationBlock *tb)
+{
+    env->regs[31] = tb->pc;
+}
+*/
+static inline void cpu_get_tb_cpu_state(CPUUniCore64State *env,
+        target_ulong *pc, target_ulong *cs_base, int *flags)
+{
+    *pc = env->regs[31];
+    *cs_base = 0;
+    *flags = 0;
+    if ((env->uncached_asr & ASR_MODE_SELECT) != ASR_MODE_USER) {
+        *flags |= (1 << 6);
+    }
+}
+/*
+static inline bool cpu_has_work(CPUState *cpu)
+{
+    return cpu->interrupt_request & (CPU_INTERRUPT_HARD
+                                   | CPU_INTERRUPT_SMP
+                                   | CPU_INTERRUPT_EXITTB);
+}
+*/
+/* Hardware interrupts */
+#define UC64_INTR_NUM           (7)
+#define UC64_INTR_SMP           (0)
+#define UC64_INTR_LSU           (1)
+#define UC64_INTR_ITM           (2)
+#define UC64_INTR_OTM           (3)
+#define UC64_INTR_DEV           (4)
+#define UC64_INTR_PFM           (5)
+
+extern uint32_t share_io_reg;   /* Fake share IO reg */
+
+/* cp0_itm.c */
+void uc64_cp0_itm_init(CPUUniCore64State *env);
+uint64_t uc64_cp0_itimer_get_delta(int);
+void uc64_cp0_itimer_set_count(int, uint64_t value);
+
+/* cp0_intc.c */
+void uc64_cp0_intc_init(CPUUniCore64State *env);
+void uc64_cp0_intc_irq_lower(CPUUniCore64State *env, int);
+void uc64_cp0_intc_irq_raise(CPUUniCore64State *env, int);
+
+#endif /* QEMU_UNICORE64_CPU_H */
diff --git a/linux-user/unicore64/target_signal.h b/linux-user/unicore64/target_signal.h
new file mode 100644
index 0000000..be95053
--- /dev/null
+++ b/linux-user/unicore64/target_signal.h
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2012 Guan Xuetao
+ */
+#ifndef TARGET_SIGNAL_H
+#define TARGET_SIGNAL_H
+
+/* this struct defines a stack used during syscall handling */
+typedef struct target_sigaltstack {
+    abi_ulong ss_sp;
+    abi_ulong ss_flags;
+    abi_ulong ss_size;
+} target_stack_t;
+
+/*
+ * sigaltstack controls
+ */
+#define TARGET_SS_ONSTACK               1
+#define TARGET_SS_DISABLE               2
+
+#define get_sp_from_cpustate(cpustate)  (cpustate->regs[29])
+
+#endif /* TARGET_SIGNAL_H */
diff --git a/linux-user/unicore64/target_structs.h b/linux-user/unicore64/target_structs.h
new file mode 100644
index 0000000..79fe498
--- /dev/null
+++ b/linux-user/unicore64/target_structs.h
@@ -0,0 +1,52 @@
+/*
+ * UniCore32 specific structures for linux-user
+ *
+ * Copyright (c) 2013 Fabrice Bellard
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+#ifndef UNICORE64_TARGET_STRUCTS_H
+#define UNICORE64_TARGET_STRUCTS_H
+
+struct target_ipc_perm {
+    abi_int __key;                      /* Key.  */
+    abi_uint uid;                       /* Owner's user ID.  */
+    abi_uint gid;                       /* Owner's group ID.  */
+    abi_uint cuid;                      /* Creator's user ID.  */
+    abi_uint cgid;                      /* Creator's group ID.  */
+    abi_ushort mode;                    /* Read/write permission.  */
+    abi_ushort __pad1;
+    abi_ushort __seq;                   /* Sequence number.  */
+    abi_ushort __pad2;
+    abi_ulong __unused1;
+    abi_ulong __unused2;
+};
+
+struct target_shmid_ds {
+    struct target_ipc_perm shm_perm;    /* operation permission struct */
+    abi_long shm_segsz;                 /* size of segment in bytes */
+    abi_ulong shm_atime;                /* time of last shmat() */
+    abi_ulong __unused1;
+    abi_ulong shm_dtime;                /* time of last shmdt() */
+    abi_ulong __unused2;
+    abi_ulong shm_ctime;                /* time of last change by shmctl() */
+    abi_ulong __unused3;
+    abi_int shm_cpid;                   /* pid of creator */
+    abi_int shm_lpid;                   /* pid of last shmop */
+    abi_ulong shm_nattch;               /* number of current attaches */
+    abi_ulong __unused4;
+    abi_ulong __unused5;
+};
+
+#endif
diff --git a/linux-user/unicore64/target_syscall.h b/linux-user/unicore64/target_syscall.h
new file mode 100644
index 0000000..3ba0bcc
--- /dev/null
+++ b/linux-user/unicore64/target_syscall.h
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2012 Guan Xuetao
+ */
+#ifndef QEMU_UC64_SYSCALL_H
+#define QEMU_UC64_SYSCALL_H
+
+#define UC64_REGS_NUM           36
+
+struct target_pt_regs {
+    abi_ulong uc64_regs[UC64_REGS_NUM];
+};
+
+#define UC64_R00                uc64_regs[0]
+#define UC64_R01                uc64_regs[1]
+#define UC64_R02                uc64_regs[2]
+#define UC64_R03                uc64_regs[3]
+#define UC64_R04                uc64_regs[4]
+#define UC64_R05                uc64_regs[5]
+#define UC64_R06                uc64_regs[6]
+#define UC64_R07                uc64_regs[7]
+#define UC64_R08                uc64_regs[8]
+#define UC64_R09                uc64_regs[9]
+#define UC64_R10                uc64_regs[10]
+#define UC64_R11                uc64_regs[11]
+#define UC64_R12                uc64_regs[12]
+#define UC64_R13                uc64_regs[13]
+#define UC64_R14                uc64_regs[14]
+#define UC64_R15                uc64_regs[15]
+#define UC64_R16                uc64_regs[16]
+#define UC64_R17                uc64_regs[17]
+#define UC64_R18                uc64_regs[18]
+#define UC64_R19                uc64_regs[19]
+#define UC64_R20                uc64_regs[20]
+#define UC64_R21                uc64_regs[21]
+#define UC64_R22                uc64_regs[22]
+#define UC64_R23                uc64_regs[23]
+#define UC64_R24                uc64_regs[24]
+#define UC64_R25                uc64_regs[25]
+#define UC64_R26                uc64_regs[26]
+#define UC64_R27                uc64_regs[27]
+#define UC64_R28                uc64_regs[28]
+#define UC64_R29                uc64_regs[29]
+#define UC64_R30                uc64_regs[30]
+#define UC64_R31                uc64_regs[31]
+#define UC64_ASR                uc64_regs[32]
+#define UC64_AFR                uc64_regs[33]
+#define UC64_SW0                uc64_regs[34] /* CP0_SYSU #0 */
+#define UC64_O00                uc64_regs[35] /* Orig R00 */
+
+#define UNAME_MACHINE           "UniCore64"
+
+#endif /* QEMU_UC64_SYSCALL_H */
diff --git a/linux-user/unicore64/termbits.h b/linux-user/unicore64/termbits.h
new file mode 100644
index 0000000..a5fcd64
--- /dev/null
+++ b/linux-user/unicore64/termbits.h
@@ -0,0 +1,2 @@
+/* NOTE: exactly the same as i386 */
+#include "../i386/termbits.h"
diff --git a/qemu-char.c b/qemu-char.c
deleted file mode 100644
index 5f82ebb..0000000
--- a/qemu-char.c
+++ /dev/null
@@ -1,4678 +0,0 @@
-/*
- * QEMU System Emulator
- *
- * Copyright (c) 2003-2008 Fabrice Bellard
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- */
-#include "qemu/osdep.h"
-#include "qemu-common.h"
-#include "qemu/cutils.h"
-#include "monitor/monitor.h"
-#include "sysemu/sysemu.h"
-#include "sysemu/block-backend.h"
-#include "qemu/error-report.h"
-#include "qemu/timer.h"
-#include "sysemu/char.h"
-#include "hw/usb.h"
-#include "qmp-commands.h"
-#include "qapi/clone-visitor.h"
-#include "qapi-visit.h"
-#include "qemu/base64.h"
-#include "io/channel-socket.h"
-#include "io/channel-file.h"
-#include "io/channel-tls.h"
-#include "sysemu/replay.h"
-
-#include <zlib.h>
-
-#ifndef _WIN32
-#include <sys/times.h>
-#include <sys/wait.h>
-#include <termios.h>
-#include <sys/ioctl.h>
-#include <sys/resource.h>
-#include <sys/socket.h>
-#include <netinet/in.h>
-#include <net/if.h>
-#include <arpa/inet.h>
-#include <netdb.h>
-#include <sys/select.h>
-#ifdef CONFIG_BSD
-#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
-#include <dev/ppbus/ppi.h>
-#include <dev/ppbus/ppbconf.h>
-#elif defined(__DragonFly__)
-#include <dev/misc/ppi/ppi.h>
-#include <bus/ppbus/ppbconf.h>
-#endif
-#else
-#ifdef __linux__
-#include <linux/ppdev.h>
-#include <linux/parport.h>
-#endif
-#ifdef __sun__
-#include <sys/ethernet.h>
-#include <sys/sockio.h>
-#include <netinet/arp.h>
-#include <netinet/in.h>
-#include <netinet/in_systm.h>
-#include <netinet/ip.h>
-#include <netinet/ip_icmp.h> // must come after ip.h
-#include <netinet/udp.h>
-#include <netinet/tcp.h>
-#endif
-#endif
-#endif
-
-#include "qemu/sockets.h"
-#include "ui/qemu-spice.h"
-
-#define READ_BUF_LEN 4096
-#define READ_RETRIES 10
-#define TCP_MAX_FDS 16
-
-/***********************************************************/
-/* Socket address helpers */
-
-static char *SocketAddress_to_str(const char *prefix, SocketAddress *addr,
-                                  bool is_listen, bool is_telnet)
-{
-    switch (addr->type) {
-    case SOCKET_ADDRESS_KIND_INET:
-        return g_strdup_printf("%s%s:%s:%s%s", prefix,
-                               is_telnet ? "telnet" : "tcp",
-                               addr->u.inet.data->host,
-                               addr->u.inet.data->port,
-                               is_listen ? ",server" : "");
-        break;
-    case SOCKET_ADDRESS_KIND_UNIX:
-        return g_strdup_printf("%sunix:%s%s", prefix,
-                               addr->u.q_unix.data->path,
-                               is_listen ? ",server" : "");
-        break;
-    case SOCKET_ADDRESS_KIND_FD:
-        return g_strdup_printf("%sfd:%s%s", prefix, addr->u.fd.data->str,
-                               is_listen ? ",server" : "");
-        break;
-    default:
-        abort();
-    }
-}
-
-static char *sockaddr_to_str(struct sockaddr_storage *ss, socklen_t ss_len,
-                             struct sockaddr_storage *ps, socklen_t ps_len,
-                             bool is_listen, bool is_telnet)
-{
-    char shost[NI_MAXHOST], sserv[NI_MAXSERV];
-    char phost[NI_MAXHOST], pserv[NI_MAXSERV];
-    const char *left = "", *right = "";
-
-    switch (ss->ss_family) {
-#ifndef _WIN32
-    case AF_UNIX:
-        return g_strdup_printf("unix:%s%s",
-                               ((struct sockaddr_un *)(ss))->sun_path,
-                               is_listen ? ",server" : "");
-#endif
-    case AF_INET6:
-        left  = "[";
-        right = "]";
-        /* fall through */
-    case AF_INET:
-        getnameinfo((struct sockaddr *) ss, ss_len, shost, sizeof(shost),
-                    sserv, sizeof(sserv), NI_NUMERICHOST | NI_NUMERICSERV);
-        getnameinfo((struct sockaddr *) ps, ps_len, phost, sizeof(phost),
-                    pserv, sizeof(pserv), NI_NUMERICHOST | NI_NUMERICSERV);
-        return g_strdup_printf("%s:%s%s%s:%s%s <-> %s%s%s:%s",
-                               is_telnet ? "telnet" : "tcp",
-                               left, shost, right, sserv,
-                               is_listen ? ",server" : "",
-                               left, phost, right, pserv);
-
-    default:
-        return g_strdup_printf("unknown");
-    }
-}
-
-/***********************************************************/
-/* character device */
-
-static QTAILQ_HEAD(CharDriverStateHead, CharDriverState) chardevs =
-    QTAILQ_HEAD_INITIALIZER(chardevs);
-
-static void qemu_chr_free_common(CharDriverState *chr);
-
-CharDriverState *qemu_chr_alloc(ChardevCommon *backend, Error **errp)
-{
-    CharDriverState *chr = g_malloc0(sizeof(CharDriverState));
-    qemu_mutex_init(&chr->chr_write_lock);
-
-    if (backend->has_logfile) {
-        int flags = O_WRONLY | O_CREAT;
-        if (backend->has_logappend &&
-            backend->logappend) {
-            flags |= O_APPEND;
-        } else {
-            flags |= O_TRUNC;
-        }
-        chr->logfd = qemu_open(backend->logfile, flags, 0666);
-        if (chr->logfd < 0) {
-            error_setg_errno(errp, errno,
-                             "Unable to open logfile %s",
-                             backend->logfile);
-            g_free(chr);
-            return NULL;
-        }
-    } else {
-        chr->logfd = -1;
-    }
-
-    return chr;
-}
-
-void qemu_chr_be_event(CharDriverState *s, int event)
-{
-    /* Keep track if the char device is open */
-    switch (event) {
-        case CHR_EVENT_OPENED:
-            s->be_open = 1;
-            break;
-        case CHR_EVENT_CLOSED:
-            s->be_open = 0;
-            break;
-    }
-
-    if (!s->chr_event)
-        return;
-    s->chr_event(s->handler_opaque, event);
-}
-
-void qemu_chr_be_generic_open(CharDriverState *s)
-{
-    qemu_chr_be_event(s, CHR_EVENT_OPENED);
-}
-
-
-/* Not reporting errors from writing to logfile, as logs are
- * defined to be "best effort" only */
-static void qemu_chr_fe_write_log(CharDriverState *s,
-                                  const uint8_t *buf, size_t len)
-{
-    size_t done = 0;
-    ssize_t ret;
-
-    if (s->logfd < 0) {
-        return;
-    }
-
-    while (done < len) {
-    retry:
-        ret = write(s->logfd, buf + done, len - done);
-        if (ret == -1 && errno == EAGAIN) {
-            g_usleep(100);
-            goto retry;
-        }
-
-        if (ret <= 0) {
-            return;
-        }
-        done += ret;
-    }
-}
-
-static int qemu_chr_fe_write_buffer(CharDriverState *s, const uint8_t *buf, int len, int *offset)
-{
-    int res = 0;
-    *offset = 0;
-
-    qemu_mutex_lock(&s->chr_write_lock);
-    while (*offset < len) {
-    retry:
-        res = s->chr_write(s, buf + *offset, len - *offset);
-        if (res < 0 && errno == EAGAIN) {
-            g_usleep(100);
-            goto retry;
-        }
-
-        if (res <= 0) {
-            break;
-        }
-
-        *offset += res;
-    }
-    if (*offset > 0) {
-        qemu_chr_fe_write_log(s, buf, *offset);
-    }
-    qemu_mutex_unlock(&s->chr_write_lock);
-
-    return res;
-}
-
-int qemu_chr_fe_write(CharDriverState *s, const uint8_t *buf, int len)
-{
-    int ret;
-
-    if (s->replay && replay_mode == REPLAY_MODE_PLAY) {
-        int offset;
-        replay_char_write_event_load(&ret, &offset);
-        assert(offset <= len);
-        qemu_chr_fe_write_buffer(s, buf, offset, &offset);
-        return ret;
-    }
-
-    qemu_mutex_lock(&s->chr_write_lock);
-    ret = s->chr_write(s, buf, len);
-
-    if (ret > 0) {
-        qemu_chr_fe_write_log(s, buf, ret);
-    }
-
-    qemu_mutex_unlock(&s->chr_write_lock);
-    
-    if (s->replay && replay_mode == REPLAY_MODE_RECORD) {
-        replay_char_write_event_save(ret, ret < 0 ? 0 : ret);
-    }
-    
-    return ret;
-}
-
-int qemu_chr_fe_write_all(CharDriverState *s, const uint8_t *buf, int len)
-{
-    int offset;
-    int res;
-
-    if (s->replay && replay_mode == REPLAY_MODE_PLAY) {
-        replay_char_write_event_load(&res, &offset);
-        assert(offset <= len);
-        qemu_chr_fe_write_buffer(s, buf, offset, &offset);
-        return res;
-    }
-
-    res = qemu_chr_fe_write_buffer(s, buf, len, &offset);
-
-    if (s->replay && replay_mode == REPLAY_MODE_RECORD) {
-        replay_char_write_event_save(res, offset);
-    }
-
-    if (res < 0) {
-        return res;
-    }
-    return offset;
-}
-
-int qemu_chr_fe_read_all(CharDriverState *s, uint8_t *buf, int len)
-{
-    int offset = 0, counter = 10;
-    int res;
-
-    if (!s->chr_sync_read) {
-        return 0;
-    }
-    
-    if (s->replay && replay_mode == REPLAY_MODE_PLAY) {
-        return replay_char_read_all_load(buf);
-    }
-
-    while (offset < len) {
-    retry:
-        res = s->chr_sync_read(s, buf + offset, len - offset);
-        if (res == -1 && errno == EAGAIN) {
-            g_usleep(100);
-            goto retry;
-        }
-
-        if (res == 0) {
-            break;
-        }
-
-        if (res < 0) {
-            if (s->replay && replay_mode == REPLAY_MODE_RECORD) {
-                replay_char_read_all_save_error(res);
-            }
-            return res;
-        }
-
-        offset += res;
-
-        if (!counter--) {
-            break;
-        }
-    }
-
-    if (s->replay && replay_mode == REPLAY_MODE_RECORD) {
-        replay_char_read_all_save_buf(buf, offset);
-    }
-    return offset;
-}
-
-int qemu_chr_fe_ioctl(CharDriverState *s, int cmd, void *arg)
-{
-    int res;
-    if (!s->chr_ioctl || s->replay) {
-        res = -ENOTSUP;
-    } else {
-        res = s->chr_ioctl(s, cmd, arg);
-    }
-
-    return res;
-}
-
-int qemu_chr_be_can_write(CharDriverState *s)
-{
-    if (!s->chr_can_read)
-        return 0;
-    return s->chr_can_read(s->handler_opaque);
-}
-
-void qemu_chr_be_write_impl(CharDriverState *s, uint8_t *buf, int len)
-{
-    if (s->chr_read) {
-        s->chr_read(s->handler_opaque, buf, len);
-    }
-}
-
-void qemu_chr_be_write(CharDriverState *s, uint8_t *buf, int len)
-{
-    if (s->replay) {
-        if (replay_mode == REPLAY_MODE_PLAY) {
-            return;
-        }
-        replay_chr_be_write(s, buf, len);
-    } else {
-        qemu_chr_be_write_impl(s, buf, len);
-    }
-}
-
-int qemu_chr_fe_get_msgfd(CharDriverState *s)
-{
-    int fd;
-    int res = (qemu_chr_fe_get_msgfds(s, &fd, 1) == 1) ? fd : -1;
-    if (s->replay) {
-        fprintf(stderr,
-                "Replay: get msgfd is not supported for serial devices yet\n");
-        exit(1);
-    }
-    return res;
-}
-
-int qemu_chr_fe_get_msgfds(CharDriverState *s, int *fds, int len)
-{
-    return s->get_msgfds ? s->get_msgfds(s, fds, len) : -1;
-}
-
-int qemu_chr_fe_set_msgfds(CharDriverState *s, int *fds, int num)
-{
-    return s->set_msgfds ? s->set_msgfds(s, fds, num) : -1;
-}
-
-int qemu_chr_add_client(CharDriverState *s, int fd)
-{
-    return s->chr_add_client ? s->chr_add_client(s, fd) : -1;
-}
-
-void qemu_chr_accept_input(CharDriverState *s)
-{
-    if (s->chr_accept_input)
-        s->chr_accept_input(s);
-    qemu_notify_event();
-}
-
-void qemu_chr_fe_printf(CharDriverState *s, const char *fmt, ...)
-{
-    char buf[READ_BUF_LEN];
-    va_list ap;
-    va_start(ap, fmt);
-    vsnprintf(buf, sizeof(buf), fmt, ap);
-    qemu_chr_fe_write(s, (uint8_t *)buf, strlen(buf));
-    va_end(ap);
-}
-
-static void remove_fd_in_watch(CharDriverState *chr);
-
-void qemu_chr_add_handlers(CharDriverState *s,
-                           IOCanReadHandler *fd_can_read,
-                           IOReadHandler *fd_read,
-                           IOEventHandler *fd_event,
-                           void *opaque)
-{
-    int fe_open;
-
-    if (!opaque && !fd_can_read && !fd_read && !fd_event) {
-        fe_open = 0;
-        remove_fd_in_watch(s);
-    } else {
-        fe_open = 1;
-    }
-    s->chr_can_read = fd_can_read;
-    s->chr_read = fd_read;
-    s->chr_event = fd_event;
-    s->handler_opaque = opaque;
-    if (fe_open && s->chr_update_read_handler)
-        s->chr_update_read_handler(s);
-
-    if (!s->explicit_fe_open) {
-        qemu_chr_fe_set_open(s, fe_open);
-    }
-
-    /* We're connecting to an already opened device, so let's make sure we
-       also get the open event */
-    if (fe_open && s->be_open) {
-        qemu_chr_be_generic_open(s);
-    }
-}
-
-static int null_chr_write(CharDriverState *chr, const uint8_t *buf, int len)
-{
-    return len;
-}
-
-static CharDriverState *qemu_chr_open_null(const char *id,
-                                           ChardevBackend *backend,
-                                           ChardevReturn *ret,
-                                           Error **errp)
-{
-    CharDriverState *chr;
-    ChardevCommon *common = backend->u.null.data;
-
-    chr = qemu_chr_alloc(common, errp);
-    if (!chr) {
-        return NULL;
-    }
-    chr->chr_write = null_chr_write;
-    chr->explicit_be_open = true;
-    return chr;
-}
-
-/* MUX driver for serial I/O splitting */
-#define MAX_MUX 4
-#define MUX_BUFFER_SIZE 32	/* Must be a power of 2.  */
-#define MUX_BUFFER_MASK (MUX_BUFFER_SIZE - 1)
-typedef struct {
-    IOCanReadHandler *chr_can_read[MAX_MUX];
-    IOReadHandler *chr_read[MAX_MUX];
-    IOEventHandler *chr_event[MAX_MUX];
-    void *ext_opaque[MAX_MUX];
-    CharDriverState *drv;
-    int focus;
-    int mux_cnt;
-    int term_got_escape;
-    int max_size;
-    /* Intermediate input buffer allows to catch escape sequences even if the
-       currently active device is not accepting any input - but only until it
-       is full as well. */
-    unsigned char buffer[MAX_MUX][MUX_BUFFER_SIZE];
-    int prod[MAX_MUX];
-    int cons[MAX_MUX];
-    int timestamps;
-
-    /* Protected by the CharDriverState chr_write_lock.  */
-    int linestart;
-    int64_t timestamps_start;
-} MuxDriver;
-
-
-/* Called with chr_write_lock held.  */
-static int mux_chr_write(CharDriverState *chr, const uint8_t *buf, int len)
-{
-    MuxDriver *d = chr->opaque;
-    int ret;
-    if (!d->timestamps) {
-        ret = qemu_chr_fe_write(d->drv, buf, len);
-    } else {
-        int i;
-
-        ret = 0;
-        for (i = 0; i < len; i++) {
-            if (d->linestart) {
-                char buf1[64];
-                int64_t ti;
-                int secs;
-
-                ti = qemu_clock_get_ms(QEMU_CLOCK_REALTIME);
-                if (d->timestamps_start == -1)
-                    d->timestamps_start = ti;
-                ti -= d->timestamps_start;
-                secs = ti / 1000;
-                snprintf(buf1, sizeof(buf1),
-                         "[%02d:%02d:%02d.%03d] ",
-                         secs / 3600,
-                         (secs / 60) % 60,
-                         secs % 60,
-                         (int)(ti % 1000));
-                qemu_chr_fe_write(d->drv, (uint8_t *)buf1, strlen(buf1));
-                d->linestart = 0;
-            }
-            ret += qemu_chr_fe_write(d->drv, buf+i, 1);
-            if (buf[i] == '\n') {
-                d->linestart = 1;
-            }
-        }
-    }
-    return ret;
-}
-
-static const char * const mux_help[] = {
-    "% h    print this help\n\r",
-    "% x    exit emulator\n\r",
-    "% s    save disk data back to file (if -snapshot)\n\r",
-    "% t    toggle console timestamps\n\r",
-    "% b    send break (magic sysrq)\n\r",
-    "% c    switch between console and monitor\n\r",
-    "% %  sends %\n\r",
-    NULL
-};
-
-int term_escape_char = 0x01; /* ctrl-a is used for escape */
-static void mux_print_help(CharDriverState *chr)
-{
-    int i, j;
-    char ebuf[15] = "Escape-Char";
-    char cbuf[50] = "\n\r";
-
-    if (term_escape_char > 0 && term_escape_char < 26) {
-        snprintf(cbuf, sizeof(cbuf), "\n\r");
-        snprintf(ebuf, sizeof(ebuf), "C-%c", term_escape_char - 1 + 'a');
-    } else {
-        snprintf(cbuf, sizeof(cbuf),
-                 "\n\rEscape-Char set to Ascii: 0x%02x\n\r\n\r",
-                 term_escape_char);
-    }
-    qemu_chr_fe_write(chr, (uint8_t *)cbuf, strlen(cbuf));
-    for (i = 0; mux_help[i] != NULL; i++) {
-        for (j=0; mux_help[i][j] != '\0'; j++) {
-            if (mux_help[i][j] == '%')
-                qemu_chr_fe_write(chr, (uint8_t *)ebuf, strlen(ebuf));
-            else
-                qemu_chr_fe_write(chr, (uint8_t *)&mux_help[i][j], 1);
-        }
-    }
-}
-
-static void mux_chr_send_event(MuxDriver *d, int mux_nr, int event)
-{
-    if (d->chr_event[mux_nr])
-        d->chr_event[mux_nr](d->ext_opaque[mux_nr], event);
-}
-
-static int mux_proc_byte(CharDriverState *chr, MuxDriver *d, int ch)
-{
-    if (d->term_got_escape) {
-        d->term_got_escape = 0;
-        if (ch == term_escape_char)
-            goto send_char;
-        switch(ch) {
-        case '?':
-        case 'h':
-            mux_print_help(chr);
-            break;
-        case 'x':
-            {
-                 const char *term =  "QEMU: Terminated\n\r";
-                 qemu_chr_fe_write(chr, (uint8_t *)term, strlen(term));
-                 exit(0);
-                 break;
-            }
-        case 's':
-            blk_commit_all();
-            break;
-        case 'b':
-            qemu_chr_be_event(chr, CHR_EVENT_BREAK);
-            break;
-        case 'c':
-            /* Switch to the next registered device */
-            mux_chr_send_event(d, d->focus, CHR_EVENT_MUX_OUT);
-            d->focus++;
-            if (d->focus >= d->mux_cnt)
-                d->focus = 0;
-            mux_chr_send_event(d, d->focus, CHR_EVENT_MUX_IN);
-            break;
-        case 't':
-            d->timestamps = !d->timestamps;
-            d->timestamps_start = -1;
-            d->linestart = 0;
-            break;
-        }
-    } else if (ch == term_escape_char) {
-        d->term_got_escape = 1;
-    } else {
-    send_char:
-        return 1;
-    }
-    return 0;
-}
-
-static void mux_chr_accept_input(CharDriverState *chr)
-{
-    MuxDriver *d = chr->opaque;
-    int m = d->focus;
-
-    while (d->prod[m] != d->cons[m] &&
-           d->chr_can_read[m] &&
-           d->chr_can_read[m](d->ext_opaque[m])) {
-        d->chr_read[m](d->ext_opaque[m],
-                       &d->buffer[m][d->cons[m]++ & MUX_BUFFER_MASK], 1);
-    }
-}
-
-static int mux_chr_can_read(void *opaque)
-{
-    CharDriverState *chr = opaque;
-    MuxDriver *d = chr->opaque;
-    int m = d->focus;
-
-    if ((d->prod[m] - d->cons[m]) < MUX_BUFFER_SIZE)
-        return 1;
-    if (d->chr_can_read[m])
-        return d->chr_can_read[m](d->ext_opaque[m]);
-    return 0;
-}
-
-static void mux_chr_read(void *opaque, const uint8_t *buf, int size)
-{
-    CharDriverState *chr = opaque;
-    MuxDriver *d = chr->opaque;
-    int m = d->focus;
-    int i;
-
-    mux_chr_accept_input (opaque);
-
-    for(i = 0; i < size; i++)
-        if (mux_proc_byte(chr, d, buf[i])) {
-            if (d->prod[m] == d->cons[m] &&
-                d->chr_can_read[m] &&
-                d->chr_can_read[m](d->ext_opaque[m]))
-                d->chr_read[m](d->ext_opaque[m], &buf[i], 1);
-            else
-                d->buffer[m][d->prod[m]++ & MUX_BUFFER_MASK] = buf[i];
-        }
-}
-
-static void mux_chr_event(void *opaque, int event)
-{
-    CharDriverState *chr = opaque;
-    MuxDriver *d = chr->opaque;
-    int i;
-
-    /* Send the event to all registered listeners */
-    for (i = 0; i < d->mux_cnt; i++)
-        mux_chr_send_event(d, i, event);
-}
-
-static void mux_chr_update_read_handler(CharDriverState *chr)
-{
-    MuxDriver *d = chr->opaque;
-
-    if (d->mux_cnt >= MAX_MUX) {
-        fprintf(stderr, "Cannot add I/O handlers, MUX array is full\n");
-        return;
-    }
-    d->ext_opaque[d->mux_cnt] = chr->handler_opaque;
-    d->chr_can_read[d->mux_cnt] = chr->chr_can_read;
-    d->chr_read[d->mux_cnt] = chr->chr_read;
-    d->chr_event[d->mux_cnt] = chr->chr_event;
-    /* Fix up the real driver with mux routines */
-    if (d->mux_cnt == 0) {
-        qemu_chr_add_handlers(d->drv, mux_chr_can_read, mux_chr_read,
-                              mux_chr_event, chr);
-    }
-    if (d->focus != -1) {
-        mux_chr_send_event(d, d->focus, CHR_EVENT_MUX_OUT);
-    }
-    d->focus = d->mux_cnt;
-    d->mux_cnt++;
-    mux_chr_send_event(d, d->focus, CHR_EVENT_MUX_IN);
-}
-
-static bool muxes_realized;
-
-/**
- * Called after processing of default and command-line-specified
- * chardevs to deliver CHR_EVENT_OPENED events to any FEs attached
- * to a mux chardev. This is done here to ensure that
- * output/prompts/banners are only displayed for the FE that has
- * focus when initial command-line processing/machine init is
- * completed.
- *
- * After this point, any new FE attached to any new or existing
- * mux will receive CHR_EVENT_OPENED notifications for the BE
- * immediately.
- */
-static void muxes_realize_done(Notifier *notifier, void *unused)
-{
-    CharDriverState *chr;
-
-    QTAILQ_FOREACH(chr, &chardevs, next) {
-        if (chr->is_mux) {
-            MuxDriver *d = chr->opaque;
-            int i;
-
-            /* send OPENED to all already-attached FEs */
-            for (i = 0; i < d->mux_cnt; i++) {
-                mux_chr_send_event(d, i, CHR_EVENT_OPENED);
-            }
-            /* mark mux as OPENED so any new FEs will immediately receive
-             * OPENED event
-             */
-            qemu_chr_be_generic_open(chr);
-        }
-    }
-    muxes_realized = true;
-}
-
-static Notifier muxes_realize_notify = {
-    .notify = muxes_realize_done,
-};
-
-static GSource *mux_chr_add_watch(CharDriverState *s, GIOCondition cond)
-{
-    MuxDriver *d = s->opaque;
-    return d->drv->chr_add_watch(d->drv, cond);
-}
-
-static void mux_chr_close(struct CharDriverState *chr)
-{
-    MuxDriver *d = chr->opaque;
-
-    g_free(d);
-}
-
-static CharDriverState *qemu_chr_open_mux(const char *id,
-                                          ChardevBackend *backend,
-                                          ChardevReturn *ret, Error **errp)
-{
-    ChardevMux *mux = backend->u.mux.data;
-    CharDriverState *chr, *drv;
-    MuxDriver *d;
-    ChardevCommon *common = qapi_ChardevMux_base(mux);
-
-    drv = qemu_chr_find(mux->chardev);
-    if (drv == NULL) {
-        error_setg(errp, "mux: base chardev %s not found", mux->chardev);
-        return NULL;
-    }
-
-    chr = qemu_chr_alloc(common, errp);
-    if (!chr) {
-        return NULL;
-    }
-    d = g_new0(MuxDriver, 1);
-
-    chr->opaque = d;
-    d->drv = drv;
-    d->focus = -1;
-    chr->chr_close = mux_chr_close;
-    chr->chr_write = mux_chr_write;
-    chr->chr_update_read_handler = mux_chr_update_read_handler;
-    chr->chr_accept_input = mux_chr_accept_input;
-    /* Frontend guest-open / -close notification is not support with muxes */
-    chr->chr_set_fe_open = NULL;
-    if (drv->chr_add_watch) {
-        chr->chr_add_watch = mux_chr_add_watch;
-    }
-    /* only default to opened state if we've realized the initial
-     * set of muxes
-     */
-    chr->explicit_be_open = muxes_realized ? 0 : 1;
-    chr->is_mux = 1;
-
-    return chr;
-}
-
-
-typedef struct IOWatchPoll
-{
-    GSource parent;
-
-    QIOChannel *ioc;
-    GSource *src;
-
-    IOCanReadHandler *fd_can_read;
-    GSourceFunc fd_read;
-    void *opaque;
-} IOWatchPoll;
-
-static IOWatchPoll *io_watch_poll_from_source(GSource *source)
-{
-    return container_of(source, IOWatchPoll, parent);
-}
-
-static gboolean io_watch_poll_prepare(GSource *source, gint *timeout_)
-{
-    IOWatchPoll *iwp = io_watch_poll_from_source(source);
-    bool now_active = iwp->fd_can_read(iwp->opaque) > 0;
-    bool was_active = iwp->src != NULL;
-    if (was_active == now_active) {
-        return FALSE;
-    }
-
-    if (now_active) {
-        iwp->src = qio_channel_create_watch(
-            iwp->ioc, G_IO_IN | G_IO_ERR | G_IO_HUP | G_IO_NVAL);
-        g_source_set_callback(iwp->src, iwp->fd_read, iwp->opaque, NULL);
-        g_source_attach(iwp->src, NULL);
-    } else {
-        g_source_destroy(iwp->src);
-        g_source_unref(iwp->src);
-        iwp->src = NULL;
-    }
-    return FALSE;
-}
-
-static gboolean io_watch_poll_check(GSource *source)
-{
-    return FALSE;
-}
-
-static gboolean io_watch_poll_dispatch(GSource *source, GSourceFunc callback,
-                                       gpointer user_data)
-{
-    abort();
-}
-
-static void io_watch_poll_finalize(GSource *source)
-{
-    /* Due to a glib bug, removing the last reference to a source
-     * inside a finalize callback causes recursive locking (and a
-     * deadlock).  This is not a problem inside other callbacks,
-     * including dispatch callbacks, so we call io_remove_watch_poll
-     * to remove this source.  At this point, iwp->src must
-     * be NULL, or we would leak it.
-     *
-     * This would be solved much more elegantly by child sources,
-     * but we support older glib versions that do not have them.
-     */
-    IOWatchPoll *iwp = io_watch_poll_from_source(source);
-    assert(iwp->src == NULL);
-}
-
-static GSourceFuncs io_watch_poll_funcs = {
-    .prepare = io_watch_poll_prepare,
-    .check = io_watch_poll_check,
-    .dispatch = io_watch_poll_dispatch,
-    .finalize = io_watch_poll_finalize,
-};
-
-/* Can only be used for read */
-static guint io_add_watch_poll(QIOChannel *ioc,
-                               IOCanReadHandler *fd_can_read,
-                               QIOChannelFunc fd_read,
-                               gpointer user_data)
-{
-    IOWatchPoll *iwp;
-    int tag;
-
-    iwp = (IOWatchPoll *) g_source_new(&io_watch_poll_funcs, sizeof(IOWatchPoll));
-    iwp->fd_can_read = fd_can_read;
-    iwp->opaque = user_data;
-    iwp->ioc = ioc;
-    iwp->fd_read = (GSourceFunc) fd_read;
-    iwp->src = NULL;
-
-    tag = g_source_attach(&iwp->parent, NULL);
-    g_source_unref(&iwp->parent);
-    return tag;
-}
-
-static void io_remove_watch_poll(guint tag)
-{
-    GSource *source;
-    IOWatchPoll *iwp;
-
-    g_return_if_fail (tag > 0);
-
-    source = g_main_context_find_source_by_id(NULL, tag);
-    g_return_if_fail (source != NULL);
-
-    iwp = io_watch_poll_from_source(source);
-    if (iwp->src) {
-        g_source_destroy(iwp->src);
-        g_source_unref(iwp->src);
-        iwp->src = NULL;
-    }
-    g_source_destroy(&iwp->parent);
-}
-
-static void remove_fd_in_watch(CharDriverState *chr)
-{
-    if (chr->fd_in_tag) {
-        io_remove_watch_poll(chr->fd_in_tag);
-        chr->fd_in_tag = 0;
-    }
-}
-
-
-static int io_channel_send_full(QIOChannel *ioc,
-                                const void *buf, size_t len,
-                                int *fds, size_t nfds)
-{
-    size_t offset = 0;
-
-    while (offset < len) {
-        ssize_t ret = 0;
-        struct iovec iov = { .iov_base = (char *)buf + offset,
-                             .iov_len = len - offset };
-
-        ret = qio_channel_writev_full(
-            ioc, &iov, 1,
-            fds, nfds, NULL);
-        if (ret == QIO_CHANNEL_ERR_BLOCK) {
-            if (offset) {
-                return offset;
-            }
-
-            errno = EAGAIN;
-            return -1;
-        } else if (ret < 0) {
-            errno = EINVAL;
-            return -1;
-        }
-
-        offset += ret;
-    }
-
-    return offset;
-}
-
-
-#ifndef _WIN32
-static int io_channel_send(QIOChannel *ioc, const void *buf, size_t len)
-{
-    return io_channel_send_full(ioc, buf, len, NULL, 0);
-}
-
-
-typedef struct FDCharDriver {
-    CharDriverState *chr;
-    QIOChannel *ioc_in, *ioc_out;
-    int max_size;
-} FDCharDriver;
-
-/* Called with chr_write_lock held.  */
-static int fd_chr_write(CharDriverState *chr, const uint8_t *buf, int len)
-{
-    FDCharDriver *s = chr->opaque;
-    
-    return io_channel_send(s->ioc_out, buf, len);
-}
-
-static gboolean fd_chr_read(QIOChannel *chan, GIOCondition cond, void *opaque)
-{
-    CharDriverState *chr = opaque;
-    FDCharDriver *s = chr->opaque;
-    int len;
-    uint8_t buf[READ_BUF_LEN];
-    ssize_t ret;
-
-    len = sizeof(buf);
-    if (len > s->max_size) {
-        len = s->max_size;
-    }
-    if (len == 0) {
-        return TRUE;
-    }
-
-    ret = qio_channel_read(
-        chan, (gchar *)buf, len, NULL);
-    if (ret == 0) {
-        remove_fd_in_watch(chr);
-        qemu_chr_be_event(chr, CHR_EVENT_CLOSED);
-        return FALSE;
-    }
-    if (ret > 0) {
-        qemu_chr_be_write(chr, buf, ret);
-    }
-
-    return TRUE;
-}
-
-static int fd_chr_read_poll(void *opaque)
-{
-    CharDriverState *chr = opaque;
-    FDCharDriver *s = chr->opaque;
-
-    s->max_size = qemu_chr_be_can_write(chr);
-    return s->max_size;
-}
-
-static GSource *fd_chr_add_watch(CharDriverState *chr, GIOCondition cond)
-{
-    FDCharDriver *s = chr->opaque;
-    return qio_channel_create_watch(s->ioc_out, cond);
-}
-
-static void fd_chr_update_read_handler(CharDriverState *chr)
-{
-    FDCharDriver *s = chr->opaque;
-
-    remove_fd_in_watch(chr);
-    if (s->ioc_in) {
-        chr->fd_in_tag = io_add_watch_poll(s->ioc_in,
-                                           fd_chr_read_poll,
-                                           fd_chr_read, chr);
-    }
-}
-
-static void fd_chr_close(struct CharDriverState *chr)
-{
-    FDCharDriver *s = chr->opaque;
-
-    remove_fd_in_watch(chr);
-    if (s->ioc_in) {
-        object_unref(OBJECT(s->ioc_in));
-    }
-    if (s->ioc_out) {
-        object_unref(OBJECT(s->ioc_out));
-    }
-
-    g_free(s);
-    qemu_chr_be_event(chr, CHR_EVENT_CLOSED);
-}
-
-/* open a character device to a unix fd */
-static CharDriverState *qemu_chr_open_fd(int fd_in, int fd_out,
-                                         ChardevCommon *backend, Error **errp)
-{
-    CharDriverState *chr;
-    FDCharDriver *s;
-
-    chr = qemu_chr_alloc(backend, errp);
-    if (!chr) {
-        return NULL;
-    }
-    s = g_new0(FDCharDriver, 1);
-    s->ioc_in = QIO_CHANNEL(qio_channel_file_new_fd(fd_in));
-    s->ioc_out = QIO_CHANNEL(qio_channel_file_new_fd(fd_out));
-    qemu_set_nonblock(fd_out);
-    s->chr = chr;
-    chr->opaque = s;
-    chr->chr_add_watch = fd_chr_add_watch;
-    chr->chr_write = fd_chr_write;
-    chr->chr_update_read_handler = fd_chr_update_read_handler;
-    chr->chr_close = fd_chr_close;
-
-    return chr;
-}
-
-static CharDriverState *qemu_chr_open_pipe(const char *id,
-                                           ChardevBackend *backend,
-                                           ChardevReturn *ret,
-                                           Error **errp)
-{
-    ChardevHostdev *opts = backend->u.pipe.data;
-    int fd_in, fd_out;
-    char *filename_in;
-    char *filename_out;
-    const char *filename = opts->device;
-    ChardevCommon *common = qapi_ChardevHostdev_base(opts);
-
-
-    filename_in = g_strdup_printf("%s.in", filename);
-    filename_out = g_strdup_printf("%s.out", filename);
-    TFR(fd_in = qemu_open(filename_in, O_RDWR | O_BINARY));
-    TFR(fd_out = qemu_open(filename_out, O_RDWR | O_BINARY));
-    g_free(filename_in);
-    g_free(filename_out);
-    if (fd_in < 0 || fd_out < 0) {
-	if (fd_in >= 0)
-	    close(fd_in);
-	if (fd_out >= 0)
-	    close(fd_out);
-        TFR(fd_in = fd_out = qemu_open(filename, O_RDWR | O_BINARY));
-        if (fd_in < 0) {
-            error_setg_file_open(errp, errno, filename);
-            return NULL;
-        }
-    }
-    return qemu_chr_open_fd(fd_in, fd_out, common, errp);
-}
-
-/* init terminal so that we can grab keys */
-static struct termios oldtty;
-static int old_fd0_flags;
-static bool stdio_in_use;
-static bool stdio_allow_signal;
-static bool stdio_echo_state;
-
-static void qemu_chr_set_echo_stdio(CharDriverState *chr, bool echo);
-
-static void term_exit(void)
-{
-    tcsetattr (0, TCSANOW, &oldtty);
-    fcntl(0, F_SETFL, old_fd0_flags);
-}
-
-static void term_stdio_handler(int sig)
-{
-    /* restore echo after resume from suspend. */
-    qemu_chr_set_echo_stdio(NULL, stdio_echo_state);
-}
-
-static void qemu_chr_set_echo_stdio(CharDriverState *chr, bool echo)
-{
-    struct termios tty;
-
-    stdio_echo_state = echo;
-    tty = oldtty;
-    if (!echo) {
-        tty.c_iflag &= ~(IGNBRK|BRKINT|PARMRK|ISTRIP
-                          |INLCR|IGNCR|ICRNL|IXON);
-        tty.c_oflag |= OPOST;
-        tty.c_lflag &= ~(ECHO|ECHONL|ICANON|IEXTEN);
-        tty.c_cflag &= ~(CSIZE|PARENB);
-        tty.c_cflag |= CS8;
-        tty.c_cc[VMIN] = 1;
-        tty.c_cc[VTIME] = 0;
-    }
-    if (!stdio_allow_signal)
-        tty.c_lflag &= ~ISIG;
-
-    tcsetattr (0, TCSANOW, &tty);
-}
-
-static void qemu_chr_close_stdio(struct CharDriverState *chr)
-{
-    term_exit();
-    fd_chr_close(chr);
-}
-
-static CharDriverState *qemu_chr_open_stdio(const char *id,
-                                            ChardevBackend *backend,
-                                            ChardevReturn *ret,
-                                            Error **errp)
-{
-    ChardevStdio *opts = backend->u.stdio.data;
-    CharDriverState *chr;
-    struct sigaction act;
-    ChardevCommon *common = qapi_ChardevStdio_base(opts);
-
-    if (is_daemonized()) {
-        error_setg(errp, "cannot use stdio with -daemonize");
-        return NULL;
-    }
-
-    if (stdio_in_use) {
-        error_setg(errp, "cannot use stdio by multiple character devices");
-        return NULL;
-    }
-
-    stdio_in_use = true;
-    old_fd0_flags = fcntl(0, F_GETFL);
-    tcgetattr(0, &oldtty);
-    qemu_set_nonblock(0);
-    atexit(term_exit);
-
-    memset(&act, 0, sizeof(act));
-    act.sa_handler = term_stdio_handler;
-    sigaction(SIGCONT, &act, NULL);
-
-    chr = qemu_chr_open_fd(0, 1, common, errp);
-    chr->chr_close = qemu_chr_close_stdio;
-    chr->chr_set_echo = qemu_chr_set_echo_stdio;
-    if (opts->has_signal) {
-        stdio_allow_signal = opts->signal;
-    }
-    qemu_chr_fe_set_echo(chr, false);
-
-    return chr;
-}
-
-#if defined(__linux__) || defined(__sun__) || defined(__FreeBSD__) \
-    || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__DragonFly__) \
-    || defined(__GLIBC__)
-
-#define HAVE_CHARDEV_SERIAL 1
-#define HAVE_CHARDEV_PTY 1
-
-typedef struct {
-    QIOChannel *ioc;
-    int read_bytes;
-
-    /* Protected by the CharDriverState chr_write_lock.  */
-    int connected;
-    guint timer_tag;
-    guint open_tag;
-} PtyCharDriver;
-
-static void pty_chr_update_read_handler_locked(CharDriverState *chr);
-static void pty_chr_state(CharDriverState *chr, int connected);
-
-static gboolean pty_chr_timer(gpointer opaque)
-{
-    struct CharDriverState *chr = opaque;
-    PtyCharDriver *s = chr->opaque;
-
-    qemu_mutex_lock(&chr->chr_write_lock);
-    s->timer_tag = 0;
-    s->open_tag = 0;
-    if (!s->connected) {
-        /* Next poll ... */
-        pty_chr_update_read_handler_locked(chr);
-    }
-    qemu_mutex_unlock(&chr->chr_write_lock);
-    return FALSE;
-}
-
-/* Called with chr_write_lock held.  */
-static void pty_chr_rearm_timer(CharDriverState *chr, int ms)
-{
-    PtyCharDriver *s = chr->opaque;
-
-    if (s->timer_tag) {
-        g_source_remove(s->timer_tag);
-        s->timer_tag = 0;
-    }
-
-    if (ms == 1000) {
-        s->timer_tag = g_timeout_add_seconds(1, pty_chr_timer, chr);
-    } else {
-        s->timer_tag = g_timeout_add(ms, pty_chr_timer, chr);
-    }
-}
-
-/* Called with chr_write_lock held.  */
-static void pty_chr_update_read_handler_locked(CharDriverState *chr)
-{
-    PtyCharDriver *s = chr->opaque;
-    GPollFD pfd;
-    int rc;
-    QIOChannelFile *fioc = QIO_CHANNEL_FILE(s->ioc);
-
-    pfd.fd = fioc->fd;
-    pfd.events = G_IO_OUT;
-    pfd.revents = 0;
-    do {
-        rc = g_poll(&pfd, 1, 0);
-    } while (rc == -1 && errno == EINTR);
-    assert(rc >= 0);
-
-    if (pfd.revents & G_IO_HUP) {
-        pty_chr_state(chr, 0);
-    } else {
-        pty_chr_state(chr, 1);
-    }
-}
-
-static void pty_chr_update_read_handler(CharDriverState *chr)
-{
-    qemu_mutex_lock(&chr->chr_write_lock);
-    pty_chr_update_read_handler_locked(chr);
-    qemu_mutex_unlock(&chr->chr_write_lock);
-}
-
-/* Called with chr_write_lock held.  */
-static int pty_chr_write(CharDriverState *chr, const uint8_t *buf, int len)
-{
-    PtyCharDriver *s = chr->opaque;
-
-    if (!s->connected) {
-        /* guest sends data, check for (re-)connect */
-        pty_chr_update_read_handler_locked(chr);
-        if (!s->connected) {
-            return 0;
-        }
-    }
-    return io_channel_send(s->ioc, buf, len);
-}
-
-static GSource *pty_chr_add_watch(CharDriverState *chr, GIOCondition cond)
-{
-    PtyCharDriver *s = chr->opaque;
-    if (!s->connected) {
-        return NULL;
-    }
-    return qio_channel_create_watch(s->ioc, cond);
-}
-
-static int pty_chr_read_poll(void *opaque)
-{
-    CharDriverState *chr = opaque;
-    PtyCharDriver *s = chr->opaque;
-
-    s->read_bytes = qemu_chr_be_can_write(chr);
-    return s->read_bytes;
-}
-
-static gboolean pty_chr_read(QIOChannel *chan, GIOCondition cond, void *opaque)
-{
-    CharDriverState *chr = opaque;
-    PtyCharDriver *s = chr->opaque;
-    gsize len;
-    uint8_t buf[READ_BUF_LEN];
-    ssize_t ret;
-
-    len = sizeof(buf);
-    if (len > s->read_bytes)
-        len = s->read_bytes;
-    if (len == 0) {
-        return TRUE;
-    }
-    ret = qio_channel_read(s->ioc, (char *)buf, len, NULL);
-    if (ret <= 0) {
-        pty_chr_state(chr, 0);
-        return FALSE;
-    } else {
-        pty_chr_state(chr, 1);
-        qemu_chr_be_write(chr, buf, ret);
-    }
-    return TRUE;
-}
-
-static gboolean qemu_chr_be_generic_open_func(gpointer opaque)
-{
-    CharDriverState *chr = opaque;
-    PtyCharDriver *s = chr->opaque;
-
-    s->open_tag = 0;
-    qemu_chr_be_generic_open(chr);
-    return FALSE;
-}
-
-/* Called with chr_write_lock held.  */
-static void pty_chr_state(CharDriverState *chr, int connected)
-{
-    PtyCharDriver *s = chr->opaque;
-
-    if (!connected) {
-        if (s->open_tag) {
-            g_source_remove(s->open_tag);
-            s->open_tag = 0;
-        }
-        remove_fd_in_watch(chr);
-        s->connected = 0;
-        /* (re-)connect poll interval for idle guests: once per second.
-         * We check more frequently in case the guests sends data to
-         * the virtual device linked to our pty. */
-        pty_chr_rearm_timer(chr, 1000);
-    } else {
-        if (s->timer_tag) {
-            g_source_remove(s->timer_tag);
-            s->timer_tag = 0;
-        }
-        if (!s->connected) {
-            g_assert(s->open_tag == 0);
-            s->connected = 1;
-            s->open_tag = g_idle_add(qemu_chr_be_generic_open_func, chr);
-        }
-        if (!chr->fd_in_tag) {
-            chr->fd_in_tag = io_add_watch_poll(s->ioc,
-                                               pty_chr_read_poll,
-                                               pty_chr_read, chr);
-        }
-    }
-}
-
-static void pty_chr_close(struct CharDriverState *chr)
-{
-    PtyCharDriver *s = chr->opaque;
-
-    qemu_mutex_lock(&chr->chr_write_lock);
-    pty_chr_state(chr, 0);
-    object_unref(OBJECT(s->ioc));
-    if (s->timer_tag) {
-        g_source_remove(s->timer_tag);
-        s->timer_tag = 0;
-    }
-    qemu_mutex_unlock(&chr->chr_write_lock);
-    g_free(s);
-    qemu_chr_be_event(chr, CHR_EVENT_CLOSED);
-}
-
-static CharDriverState *qemu_chr_open_pty(const char *id,
-                                          ChardevBackend *backend,
-                                          ChardevReturn *ret,
-                                          Error **errp)
-{
-    CharDriverState *chr;
-    PtyCharDriver *s;
-    int master_fd, slave_fd;
-    char pty_name[PATH_MAX];
-    ChardevCommon *common = backend->u.pty.data;
-
-    master_fd = qemu_openpty_raw(&slave_fd, pty_name);
-    if (master_fd < 0) {
-        error_setg_errno(errp, errno, "Failed to create PTY");
-        return NULL;
-    }
-
-    close(slave_fd);
-    qemu_set_nonblock(master_fd);
-
-    chr = qemu_chr_alloc(common, errp);
-    if (!chr) {
-        close(master_fd);
-        return NULL;
-    }
-
-    chr->filename = g_strdup_printf("pty:%s", pty_name);
-    ret->pty = g_strdup(pty_name);
-    ret->has_pty = true;
-
-    fprintf(stderr, "char device redirected to %s (label %s)\n",
-            pty_name, id);
-
-    s = g_new0(PtyCharDriver, 1);
-    chr->opaque = s;
-    chr->chr_write = pty_chr_write;
-    chr->chr_update_read_handler = pty_chr_update_read_handler;
-    chr->chr_close = pty_chr_close;
-    chr->chr_add_watch = pty_chr_add_watch;
-    chr->explicit_be_open = true;
-
-    s->ioc = QIO_CHANNEL(qio_channel_file_new_fd(master_fd));
-    s->timer_tag = 0;
-
-    return chr;
-}
-
-static void tty_serial_init(int fd, int speed,
-                            int parity, int data_bits, int stop_bits)
-{
-    struct termios tty;
-    speed_t spd;
-
-#if 0
-    printf("tty_serial_init: speed=%d parity=%c data=%d stop=%d\n",
-           speed, parity, data_bits, stop_bits);
-#endif
-    tcgetattr (fd, &tty);
-
-#define check_speed(val) if (speed <= val) { spd = B##val; break; }
-    speed = speed * 10 / 11;
-    do {
-        check_speed(50);
-        check_speed(75);
-        check_speed(110);
-        check_speed(134);
-        check_speed(150);
-        check_speed(200);
-        check_speed(300);
-        check_speed(600);
-        check_speed(1200);
-        check_speed(1800);
-        check_speed(2400);
-        check_speed(4800);
-        check_speed(9600);
-        check_speed(19200);
-        check_speed(38400);
-        /* Non-Posix values follow. They may be unsupported on some systems. */
-        check_speed(57600);
-        check_speed(115200);
-#ifdef B230400
-        check_speed(230400);
-#endif
-#ifdef B460800
-        check_speed(460800);
-#endif
-#ifdef B500000
-        check_speed(500000);
-#endif
-#ifdef B576000
-        check_speed(576000);
-#endif
-#ifdef B921600
-        check_speed(921600);
-#endif
-#ifdef B1000000
-        check_speed(1000000);
-#endif
-#ifdef B1152000
-        check_speed(1152000);
-#endif
-#ifdef B1500000
-        check_speed(1500000);
-#endif
-#ifdef B2000000
-        check_speed(2000000);
-#endif
-#ifdef B2500000
-        check_speed(2500000);
-#endif
-#ifdef B3000000
-        check_speed(3000000);
-#endif
-#ifdef B3500000
-        check_speed(3500000);
-#endif
-#ifdef B4000000
-        check_speed(4000000);
-#endif
-        spd = B115200;
-    } while (0);
-
-    cfsetispeed(&tty, spd);
-    cfsetospeed(&tty, spd);
-
-    tty.c_iflag &= ~(IGNBRK|BRKINT|PARMRK|ISTRIP
-                          |INLCR|IGNCR|ICRNL|IXON);
-    tty.c_oflag |= OPOST;
-    tty.c_lflag &= ~(ECHO|ECHONL|ICANON|IEXTEN|ISIG);
-    tty.c_cflag &= ~(CSIZE|PARENB|PARODD|CRTSCTS|CSTOPB);
-    switch(data_bits) {
-    default:
-    case 8:
-        tty.c_cflag |= CS8;
-        break;
-    case 7:
-        tty.c_cflag |= CS7;
-        break;
-    case 6:
-        tty.c_cflag |= CS6;
-        break;
-    case 5:
-        tty.c_cflag |= CS5;
-        break;
-    }
-    switch(parity) {
-    default:
-    case 'N':
-        break;
-    case 'E':
-        tty.c_cflag |= PARENB;
-        break;
-    case 'O':
-        tty.c_cflag |= PARENB | PARODD;
-        break;
-    }
-    if (stop_bits == 2)
-        tty.c_cflag |= CSTOPB;
-
-    tcsetattr (fd, TCSANOW, &tty);
-}
-
-static int tty_serial_ioctl(CharDriverState *chr, int cmd, void *arg)
-{
-    FDCharDriver *s = chr->opaque;
-    QIOChannelFile *fioc = QIO_CHANNEL_FILE(s->ioc_in);
-
-    switch(cmd) {
-    case CHR_IOCTL_SERIAL_SET_PARAMS:
-        {
-            QEMUSerialSetParams *ssp = arg;
-            tty_serial_init(fioc->fd,
-                            ssp->speed, ssp->parity,
-                            ssp->data_bits, ssp->stop_bits);
-        }
-        break;
-    case CHR_IOCTL_SERIAL_SET_BREAK:
-        {
-            int enable = *(int *)arg;
-            if (enable) {
-                tcsendbreak(fioc->fd, 1);
-            }
-        }
-        break;
-    case CHR_IOCTL_SERIAL_GET_TIOCM:
-        {
-            int sarg = 0;
-            int *targ = (int *)arg;
-            ioctl(fioc->fd, TIOCMGET, &sarg);
-            *targ = 0;
-            if (sarg & TIOCM_CTS)
-                *targ |= CHR_TIOCM_CTS;
-            if (sarg & TIOCM_CAR)
-                *targ |= CHR_TIOCM_CAR;
-            if (sarg & TIOCM_DSR)
-                *targ |= CHR_TIOCM_DSR;
-            if (sarg & TIOCM_RI)
-                *targ |= CHR_TIOCM_RI;
-            if (sarg & TIOCM_DTR)
-                *targ |= CHR_TIOCM_DTR;
-            if (sarg & TIOCM_RTS)
-                *targ |= CHR_TIOCM_RTS;
-        }
-        break;
-    case CHR_IOCTL_SERIAL_SET_TIOCM:
-        {
-            int sarg = *(int *)arg;
-            int targ = 0;
-            ioctl(fioc->fd, TIOCMGET, &targ);
-            targ &= ~(CHR_TIOCM_CTS | CHR_TIOCM_CAR | CHR_TIOCM_DSR
-                     | CHR_TIOCM_RI | CHR_TIOCM_DTR | CHR_TIOCM_RTS);
-            if (sarg & CHR_TIOCM_CTS)
-                targ |= TIOCM_CTS;
-            if (sarg & CHR_TIOCM_CAR)
-                targ |= TIOCM_CAR;
-            if (sarg & CHR_TIOCM_DSR)
-                targ |= TIOCM_DSR;
-            if (sarg & CHR_TIOCM_RI)
-                targ |= TIOCM_RI;
-            if (sarg & CHR_TIOCM_DTR)
-                targ |= TIOCM_DTR;
-            if (sarg & CHR_TIOCM_RTS)
-                targ |= TIOCM_RTS;
-            ioctl(fioc->fd, TIOCMSET, &targ);
-        }
-        break;
-    default:
-        return -ENOTSUP;
-    }
-    return 0;
-}
-
-static void qemu_chr_close_tty(CharDriverState *chr)
-{
-    fd_chr_close(chr);
-}
-
-static CharDriverState *qemu_chr_open_tty_fd(int fd,
-                                             ChardevCommon *backend,
-                                             Error **errp)
-{
-    CharDriverState *chr;
-
-    tty_serial_init(fd, 115200, 'N', 8, 1);
-    chr = qemu_chr_open_fd(fd, fd, backend, errp);
-    chr->chr_ioctl = tty_serial_ioctl;
-    chr->chr_close = qemu_chr_close_tty;
-    return chr;
-}
-#endif /* __linux__ || __sun__ */
-
-#if defined(__linux__)
-
-#define HAVE_CHARDEV_PARPORT 1
-
-typedef struct {
-    int fd;
-    int mode;
-} ParallelCharDriver;
-
-static int pp_hw_mode(ParallelCharDriver *s, uint16_t mode)
-{
-    if (s->mode != mode) {
-	int m = mode;
-        if (ioctl(s->fd, PPSETMODE, &m) < 0)
-            return 0;
-	s->mode = mode;
-    }
-    return 1;
-}
-
-static int pp_ioctl(CharDriverState *chr, int cmd, void *arg)
-{
-    ParallelCharDriver *drv = chr->opaque;
-    int fd = drv->fd;
-    uint8_t b;
-
-    switch(cmd) {
-    case CHR_IOCTL_PP_READ_DATA:
-        if (ioctl(fd, PPRDATA, &b) < 0)
-            return -ENOTSUP;
-        *(uint8_t *)arg = b;
-        break;
-    case CHR_IOCTL_PP_WRITE_DATA:
-        b = *(uint8_t *)arg;
-        if (ioctl(fd, PPWDATA, &b) < 0)
-            return -ENOTSUP;
-        break;
-    case CHR_IOCTL_PP_READ_CONTROL:
-        if (ioctl(fd, PPRCONTROL, &b) < 0)
-            return -ENOTSUP;
-	/* Linux gives only the lowest bits, and no way to know data
-	   direction! For better compatibility set the fixed upper
-	   bits. */
-        *(uint8_t *)arg = b | 0xc0;
-        break;
-    case CHR_IOCTL_PP_WRITE_CONTROL:
-        b = *(uint8_t *)arg;
-        if (ioctl(fd, PPWCONTROL, &b) < 0)
-            return -ENOTSUP;
-        break;
-    case CHR_IOCTL_PP_READ_STATUS:
-        if (ioctl(fd, PPRSTATUS, &b) < 0)
-            return -ENOTSUP;
-        *(uint8_t *)arg = b;
-        break;
-    case CHR_IOCTL_PP_DATA_DIR:
-        if (ioctl(fd, PPDATADIR, (int *)arg) < 0)
-            return -ENOTSUP;
-        break;
-    case CHR_IOCTL_PP_EPP_READ_ADDR:
-	if (pp_hw_mode(drv, IEEE1284_MODE_EPP|IEEE1284_ADDR)) {
-	    struct ParallelIOArg *parg = arg;
-	    int n = read(fd, parg->buffer, parg->count);
-	    if (n != parg->count) {
-		return -EIO;
-	    }
-	}
-        break;
-    case CHR_IOCTL_PP_EPP_READ:
-	if (pp_hw_mode(drv, IEEE1284_MODE_EPP)) {
-	    struct ParallelIOArg *parg = arg;
-	    int n = read(fd, parg->buffer, parg->count);
-	    if (n != parg->count) {
-		return -EIO;
-	    }
-	}
-        break;
-    case CHR_IOCTL_PP_EPP_WRITE_ADDR:
-	if (pp_hw_mode(drv, IEEE1284_MODE_EPP|IEEE1284_ADDR)) {
-	    struct ParallelIOArg *parg = arg;
-	    int n = write(fd, parg->buffer, parg->count);
-	    if (n != parg->count) {
-		return -EIO;
-	    }
-	}
-        break;
-    case CHR_IOCTL_PP_EPP_WRITE:
-	if (pp_hw_mode(drv, IEEE1284_MODE_EPP)) {
-	    struct ParallelIOArg *parg = arg;
-	    int n = write(fd, parg->buffer, parg->count);
-	    if (n != parg->count) {
-		return -EIO;
-	    }
-	}
-        break;
-    default:
-        return -ENOTSUP;
-    }
-    return 0;
-}
-
-static void pp_close(CharDriverState *chr)
-{
-    ParallelCharDriver *drv = chr->opaque;
-    int fd = drv->fd;
-
-    pp_hw_mode(drv, IEEE1284_MODE_COMPAT);
-    ioctl(fd, PPRELEASE);
-    close(fd);
-    g_free(drv);
-    qemu_chr_be_event(chr, CHR_EVENT_CLOSED);
-}
-
-static CharDriverState *qemu_chr_open_pp_fd(int fd,
-                                            ChardevCommon *backend,
-                                            Error **errp)
-{
-    CharDriverState *chr;
-    ParallelCharDriver *drv;
-
-    if (ioctl(fd, PPCLAIM) < 0) {
-        error_setg_errno(errp, errno, "not a parallel port");
-        close(fd);
-        return NULL;
-    }
-
-    chr = qemu_chr_alloc(backend, errp);
-    if (!chr) {
-        return NULL;
-    }
-
-    drv = g_new0(ParallelCharDriver, 1);
-    chr->opaque = drv;
-    chr->chr_write = null_chr_write;
-    chr->chr_ioctl = pp_ioctl;
-    chr->chr_close = pp_close;
-
-    drv->fd = fd;
-    drv->mode = IEEE1284_MODE_COMPAT;
-
-    return chr;
-}
-#endif /* __linux__ */
-
-#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__)
-
-#define HAVE_CHARDEV_PARPORT 1
-
-static int pp_ioctl(CharDriverState *chr, int cmd, void *arg)
-{
-    int fd = (int)(intptr_t)chr->opaque;
-    uint8_t b;
-
-    switch(cmd) {
-    case CHR_IOCTL_PP_READ_DATA:
-        if (ioctl(fd, PPIGDATA, &b) < 0)
-            return -ENOTSUP;
-        *(uint8_t *)arg = b;
-        break;
-    case CHR_IOCTL_PP_WRITE_DATA:
-        b = *(uint8_t *)arg;
-        if (ioctl(fd, PPISDATA, &b) < 0)
-            return -ENOTSUP;
-        break;
-    case CHR_IOCTL_PP_READ_CONTROL:
-        if (ioctl(fd, PPIGCTRL, &b) < 0)
-            return -ENOTSUP;
-        *(uint8_t *)arg = b;
-        break;
-    case CHR_IOCTL_PP_WRITE_CONTROL:
-        b = *(uint8_t *)arg;
-        if (ioctl(fd, PPISCTRL, &b) < 0)
-            return -ENOTSUP;
-        break;
-    case CHR_IOCTL_PP_READ_STATUS:
-        if (ioctl(fd, PPIGSTATUS, &b) < 0)
-            return -ENOTSUP;
-        *(uint8_t *)arg = b;
-        break;
-    default:
-        return -ENOTSUP;
-    }
-    return 0;
-}
-
-static CharDriverState *qemu_chr_open_pp_fd(int fd,
-                                            ChardevCommon *backend,
-                                            Error **errp)
-{
-    CharDriverState *chr;
-
-    chr = qemu_chr_alloc(backend, errp);
-    if (!chr) {
-        return NULL;
-    }
-    chr->opaque = (void *)(intptr_t)fd;
-    chr->chr_write = null_chr_write;
-    chr->chr_ioctl = pp_ioctl;
-    chr->explicit_be_open = true;
-    return chr;
-}
-#endif
-
-#else /* _WIN32 */
-
-#define HAVE_CHARDEV_SERIAL 1
-
-typedef struct {
-    int max_size;
-    HANDLE hcom, hrecv, hsend;
-    OVERLAPPED orecv;
-    BOOL fpipe;
-    DWORD len;
-
-    /* Protected by the CharDriverState chr_write_lock.  */
-    OVERLAPPED osend;
-} WinCharState;
-
-typedef struct {
-    HANDLE  hStdIn;
-    HANDLE  hInputReadyEvent;
-    HANDLE  hInputDoneEvent;
-    HANDLE  hInputThread;
-    uint8_t win_stdio_buf;
-} WinStdioCharState;
-
-#define NSENDBUF 2048
-#define NRECVBUF 2048
-#define MAXCONNECT 1
-#define NTIMEOUT 5000
-
-static int win_chr_poll(void *opaque);
-static int win_chr_pipe_poll(void *opaque);
-
-static void win_chr_close(CharDriverState *chr)
-{
-    WinCharState *s = chr->opaque;
-
-    if (s->hsend) {
-        CloseHandle(s->hsend);
-        s->hsend = NULL;
-    }
-    if (s->hrecv) {
-        CloseHandle(s->hrecv);
-        s->hrecv = NULL;
-    }
-    if (s->hcom) {
-        CloseHandle(s->hcom);
-        s->hcom = NULL;
-    }
-    if (s->fpipe)
-        qemu_del_polling_cb(win_chr_pipe_poll, chr);
-    else
-        qemu_del_polling_cb(win_chr_poll, chr);
-
-    qemu_chr_be_event(chr, CHR_EVENT_CLOSED);
-}
-
-static int win_chr_init(CharDriverState *chr, const char *filename, Error **errp)
-{
-    WinCharState *s = chr->opaque;
-    COMMCONFIG comcfg;
-    COMMTIMEOUTS cto = { 0, 0, 0, 0, 0};
-    COMSTAT comstat;
-    DWORD size;
-    DWORD err;
-
-    s->hsend = CreateEvent(NULL, TRUE, FALSE, NULL);
-    if (!s->hsend) {
-        error_setg(errp, "Failed CreateEvent");
-        goto fail;
-    }
-    s->hrecv = CreateEvent(NULL, TRUE, FALSE, NULL);
-    if (!s->hrecv) {
-        error_setg(errp, "Failed CreateEvent");
-        goto fail;
-    }
-
-    s->hcom = CreateFile(filename, GENERIC_READ|GENERIC_WRITE, 0, NULL,
-                      OPEN_EXISTING, FILE_FLAG_OVERLAPPED, 0);
-    if (s->hcom == INVALID_HANDLE_VALUE) {
-        error_setg(errp, "Failed CreateFile (%lu)", GetLastError());
-        s->hcom = NULL;
-        goto fail;
-    }
-
-    if (!SetupComm(s->hcom, NRECVBUF, NSENDBUF)) {
-        error_setg(errp, "Failed SetupComm");
-        goto fail;
-    }
-
-    ZeroMemory(&comcfg, sizeof(COMMCONFIG));
-    size = sizeof(COMMCONFIG);
-    GetDefaultCommConfig(filename, &comcfg, &size);
-    comcfg.dcb.DCBlength = sizeof(DCB);
-    CommConfigDialog(filename, NULL, &comcfg);
-
-    if (!SetCommState(s->hcom, &comcfg.dcb)) {
-        error_setg(errp, "Failed SetCommState");
-        goto fail;
-    }
-
-    if (!SetCommMask(s->hcom, EV_ERR)) {
-        error_setg(errp, "Failed SetCommMask");
-        goto fail;
-    }
-
-    cto.ReadIntervalTimeout = MAXDWORD;
-    if (!SetCommTimeouts(s->hcom, &cto)) {
-        error_setg(errp, "Failed SetCommTimeouts");
-        goto fail;
-    }
-
-    if (!ClearCommError(s->hcom, &err, &comstat)) {
-        error_setg(errp, "Failed ClearCommError");
-        goto fail;
-    }
-    qemu_add_polling_cb(win_chr_poll, chr);
-    return 0;
-
- fail:
-    win_chr_close(chr);
-    return -1;
-}
-
-/* Called with chr_write_lock held.  */
-static int win_chr_write(CharDriverState *chr, const uint8_t *buf, int len1)
-{
-    WinCharState *s = chr->opaque;
-    DWORD len, ret, size, err;
-
-    len = len1;
-    ZeroMemory(&s->osend, sizeof(s->osend));
-    s->osend.hEvent = s->hsend;
-    while (len > 0) {
-        if (s->hsend)
-            ret = WriteFile(s->hcom, buf, len, &size, &s->osend);
-        else
-            ret = WriteFile(s->hcom, buf, len, &size, NULL);
-        if (!ret) {
-            err = GetLastError();
-            if (err == ERROR_IO_PENDING) {
-                ret = GetOverlappedResult(s->hcom, &s->osend, &size, TRUE);
-                if (ret) {
-                    buf += size;
-                    len -= size;
-                } else {
-                    break;
-                }
-            } else {
-                break;
-            }
-        } else {
-            buf += size;
-            len -= size;
-        }
-    }
-    return len1 - len;
-}
-
-static int win_chr_read_poll(CharDriverState *chr)
-{
-    WinCharState *s = chr->opaque;
-
-    s->max_size = qemu_chr_be_can_write(chr);
-    return s->max_size;
-}
-
-static void win_chr_readfile(CharDriverState *chr)
-{
-    WinCharState *s = chr->opaque;
-    int ret, err;
-    uint8_t buf[READ_BUF_LEN];
-    DWORD size;
-
-    ZeroMemory(&s->orecv, sizeof(s->orecv));
-    s->orecv.hEvent = s->hrecv;
-    ret = ReadFile(s->hcom, buf, s->len, &size, &s->orecv);
-    if (!ret) {
-        err = GetLastError();
-        if (err == ERROR_IO_PENDING) {
-            ret = GetOverlappedResult(s->hcom, &s->orecv, &size, TRUE);
-        }
-    }
-
-    if (size > 0) {
-        qemu_chr_be_write(chr, buf, size);
-    }
-}
-
-static void win_chr_read(CharDriverState *chr)
-{
-    WinCharState *s = chr->opaque;
-
-    if (s->len > s->max_size)
-        s->len = s->max_size;
-    if (s->len == 0)
-        return;
-
-    win_chr_readfile(chr);
-}
-
-static int win_chr_poll(void *opaque)
-{
-    CharDriverState *chr = opaque;
-    WinCharState *s = chr->opaque;
-    COMSTAT status;
-    DWORD comerr;
-
-    ClearCommError(s->hcom, &comerr, &status);
-    if (status.cbInQue > 0) {
-        s->len = status.cbInQue;
-        win_chr_read_poll(chr);
-        win_chr_read(chr);
-        return 1;
-    }
-    return 0;
-}
-
-static CharDriverState *qemu_chr_open_win_path(const char *filename,
-                                               ChardevCommon *backend,
-                                               Error **errp)
-{
-    CharDriverState *chr;
-    WinCharState *s;
-
-    chr = qemu_chr_alloc(backend, errp);
-    if (!chr) {
-        return NULL;
-    }
-    s = g_new0(WinCharState, 1);
-    chr->opaque = s;
-    chr->chr_write = win_chr_write;
-    chr->chr_close = win_chr_close;
-
-    if (win_chr_init(chr, filename, errp) < 0) {
-        g_free(s);
-        qemu_chr_free_common(chr);
-        return NULL;
-    }
-    return chr;
-}
-
-static int win_chr_pipe_poll(void *opaque)
-{
-    CharDriverState *chr = opaque;
-    WinCharState *s = chr->opaque;
-    DWORD size;
-
-    PeekNamedPipe(s->hcom, NULL, 0, NULL, &size, NULL);
-    if (size > 0) {
-        s->len = size;
-        win_chr_read_poll(chr);
-        win_chr_read(chr);
-        return 1;
-    }
-    return 0;
-}
-
-static int win_chr_pipe_init(CharDriverState *chr, const char *filename,
-                             Error **errp)
-{
-    WinCharState *s = chr->opaque;
-    OVERLAPPED ov;
-    int ret;
-    DWORD size;
-    char *openname;
-
-    s->fpipe = TRUE;
-
-    s->hsend = CreateEvent(NULL, TRUE, FALSE, NULL);
-    if (!s->hsend) {
-        error_setg(errp, "Failed CreateEvent");
-        goto fail;
-    }
-    s->hrecv = CreateEvent(NULL, TRUE, FALSE, NULL);
-    if (!s->hrecv) {
-        error_setg(errp, "Failed CreateEvent");
-        goto fail;
-    }
-
-    openname = g_strdup_printf("\\\\.\\pipe\\%s", filename);
-    s->hcom = CreateNamedPipe(openname, PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED,
-                              PIPE_TYPE_BYTE | PIPE_READMODE_BYTE |
-                              PIPE_WAIT,
-                              MAXCONNECT, NSENDBUF, NRECVBUF, NTIMEOUT, NULL);
-    g_free(openname);
-    if (s->hcom == INVALID_HANDLE_VALUE) {
-        error_setg(errp, "Failed CreateNamedPipe (%lu)", GetLastError());
-        s->hcom = NULL;
-        goto fail;
-    }
-
-    ZeroMemory(&ov, sizeof(ov));
-    ov.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
-    ret = ConnectNamedPipe(s->hcom, &ov);
-    if (ret) {
-        error_setg(errp, "Failed ConnectNamedPipe");
-        goto fail;
-    }
-
-    ret = GetOverlappedResult(s->hcom, &ov, &size, TRUE);
-    if (!ret) {
-        error_setg(errp, "Failed GetOverlappedResult");
-        if (ov.hEvent) {
-            CloseHandle(ov.hEvent);
-            ov.hEvent = NULL;
-        }
-        goto fail;
-    }
-
-    if (ov.hEvent) {
-        CloseHandle(ov.hEvent);
-        ov.hEvent = NULL;
-    }
-    qemu_add_polling_cb(win_chr_pipe_poll, chr);
-    return 0;
-
- fail:
-    win_chr_close(chr);
-    return -1;
-}
-
-
-static CharDriverState *qemu_chr_open_pipe(const char *id,
-                                           ChardevBackend *backend,
-                                           ChardevReturn *ret,
-                                           Error **errp)
-{
-    ChardevHostdev *opts = backend->u.pipe.data;
-    const char *filename = opts->device;
-    CharDriverState *chr;
-    WinCharState *s;
-    ChardevCommon *common = qapi_ChardevHostdev_base(opts);
-
-    chr = qemu_chr_alloc(common, errp);
-    if (!chr) {
-        return NULL;
-    }
-    s = g_new0(WinCharState, 1);
-    chr->opaque = s;
-    chr->chr_write = win_chr_write;
-    chr->chr_close = win_chr_close;
-
-    if (win_chr_pipe_init(chr, filename, errp) < 0) {
-        g_free(s);
-        qemu_chr_free_common(chr);
-        return NULL;
-    }
-    return chr;
-}
-
-static CharDriverState *qemu_chr_open_win_file(HANDLE fd_out,
-                                               ChardevCommon *backend,
-                                               Error **errp)
-{
-    CharDriverState *chr;
-    WinCharState *s;
-
-    chr = qemu_chr_alloc(backend, errp);
-    if (!chr) {
-        return NULL;
-    }
-    s = g_new0(WinCharState, 1);
-    s->hcom = fd_out;
-    chr->opaque = s;
-    chr->chr_write = win_chr_write;
-    return chr;
-}
-
-static CharDriverState *qemu_chr_open_win_con(const char *id,
-                                              ChardevBackend *backend,
-                                              ChardevReturn *ret,
-                                              Error **errp)
-{
-    ChardevCommon *common = backend->u.console.data;
-    return qemu_chr_open_win_file(GetStdHandle(STD_OUTPUT_HANDLE),
-                                  common, errp);
-}
-
-static int win_stdio_write(CharDriverState *chr, const uint8_t *buf, int len)
-{
-    HANDLE  hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);
-    DWORD   dwSize;
-    int     len1;
-
-    len1 = len;
-
-    while (len1 > 0) {
-        if (!WriteFile(hStdOut, buf, len1, &dwSize, NULL)) {
-            break;
-        }
-        buf  += dwSize;
-        len1 -= dwSize;
-    }
-
-    return len - len1;
-}
-
-static void win_stdio_wait_func(void *opaque)
-{
-    CharDriverState   *chr   = opaque;
-    WinStdioCharState *stdio = chr->opaque;
-    INPUT_RECORD       buf[4];
-    int                ret;
-    DWORD              dwSize;
-    int                i;
-
-    ret = ReadConsoleInput(stdio->hStdIn, buf, ARRAY_SIZE(buf), &dwSize);
-
-    if (!ret) {
-        /* Avoid error storm */
-        qemu_del_wait_object(stdio->hStdIn, NULL, NULL);
-        return;
-    }
-
-    for (i = 0; i < dwSize; i++) {
-        KEY_EVENT_RECORD *kev = &buf[i].Event.KeyEvent;
-
-        if (buf[i].EventType == KEY_EVENT && kev->bKeyDown) {
-            int j;
-            if (kev->uChar.AsciiChar != 0) {
-                for (j = 0; j < kev->wRepeatCount; j++) {
-                    if (qemu_chr_be_can_write(chr)) {
-                        uint8_t c = kev->uChar.AsciiChar;
-                        qemu_chr_be_write(chr, &c, 1);
-                    }
-                }
-            }
-        }
-    }
-}
-
-static DWORD WINAPI win_stdio_thread(LPVOID param)
-{
-    CharDriverState   *chr   = param;
-    WinStdioCharState *stdio = chr->opaque;
-    int                ret;
-    DWORD              dwSize;
-
-    while (1) {
-
-        /* Wait for one byte */
-        ret = ReadFile(stdio->hStdIn, &stdio->win_stdio_buf, 1, &dwSize, NULL);
-
-        /* Exit in case of error, continue if nothing read */
-        if (!ret) {
-            break;
-        }
-        if (!dwSize) {
-            continue;
-        }
-
-        /* Some terminal emulator returns \r\n for Enter, just pass \n */
-        if (stdio->win_stdio_buf == '\r') {
-            continue;
-        }
-
-        /* Signal the main thread and wait until the byte was eaten */
-        if (!SetEvent(stdio->hInputReadyEvent)) {
-            break;
-        }
-        if (WaitForSingleObject(stdio->hInputDoneEvent, INFINITE)
-            != WAIT_OBJECT_0) {
-            break;
-        }
-    }
-
-    qemu_del_wait_object(stdio->hInputReadyEvent, NULL, NULL);
-    return 0;
-}
-
-static void win_stdio_thread_wait_func(void *opaque)
-{
-    CharDriverState   *chr   = opaque;
-    WinStdioCharState *stdio = chr->opaque;
-
-    if (qemu_chr_be_can_write(chr)) {
-        qemu_chr_be_write(chr, &stdio->win_stdio_buf, 1);
-    }
-
-    SetEvent(stdio->hInputDoneEvent);
-}
-
-static void qemu_chr_set_echo_win_stdio(CharDriverState *chr, bool echo)
-{
-    WinStdioCharState *stdio  = chr->opaque;
-    DWORD              dwMode = 0;
-
-    GetConsoleMode(stdio->hStdIn, &dwMode);
-
-    if (echo) {
-        SetConsoleMode(stdio->hStdIn, dwMode | ENABLE_ECHO_INPUT);
-    } else {
-        SetConsoleMode(stdio->hStdIn, dwMode & ~ENABLE_ECHO_INPUT);
-    }
-}
-
-static void win_stdio_close(CharDriverState *chr)
-{
-    WinStdioCharState *stdio = chr->opaque;
-
-    if (stdio->hInputReadyEvent != INVALID_HANDLE_VALUE) {
-        CloseHandle(stdio->hInputReadyEvent);
-    }
-    if (stdio->hInputDoneEvent != INVALID_HANDLE_VALUE) {
-        CloseHandle(stdio->hInputDoneEvent);
-    }
-    if (stdio->hInputThread != INVALID_HANDLE_VALUE) {
-        TerminateThread(stdio->hInputThread, 0);
-    }
-
-    g_free(chr->opaque);
-    g_free(chr);
-}
-
-static CharDriverState *qemu_chr_open_stdio(const char *id,
-                                            ChardevBackend *backend,
-                                            ChardevReturn *ret,
-                                            Error **errp)
-{
-    CharDriverState   *chr;
-    WinStdioCharState *stdio;
-    DWORD              dwMode;
-    int                is_console = 0;
-    ChardevCommon *common = qapi_ChardevStdio_base(backend->u.stdio.data);
-
-    chr   = qemu_chr_alloc(common, errp);
-    if (!chr) {
-        return NULL;
-    }
-    stdio = g_new0(WinStdioCharState, 1);
-
-    stdio->hStdIn = GetStdHandle(STD_INPUT_HANDLE);
-    if (stdio->hStdIn == INVALID_HANDLE_VALUE) {
-        error_setg(errp, "cannot open stdio: invalid handle");
-        return NULL;
-    }
-
-    is_console = GetConsoleMode(stdio->hStdIn, &dwMode) != 0;
-
-    chr->opaque    = stdio;
-    chr->chr_write = win_stdio_write;
-    chr->chr_close = win_stdio_close;
-
-    if (is_console) {
-        if (qemu_add_wait_object(stdio->hStdIn,
-                                 win_stdio_wait_func, chr)) {
-            error_setg(errp, "qemu_add_wait_object: failed");
-            goto err1;
-        }
-    } else {
-        DWORD   dwId;
-            
-        stdio->hInputReadyEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
-        stdio->hInputDoneEvent  = CreateEvent(NULL, FALSE, FALSE, NULL);
-        if (stdio->hInputReadyEvent == INVALID_HANDLE_VALUE
-            || stdio->hInputDoneEvent == INVALID_HANDLE_VALUE) {
-            error_setg(errp, "cannot create event");
-            goto err2;
-        }
-        if (qemu_add_wait_object(stdio->hInputReadyEvent,
-                                 win_stdio_thread_wait_func, chr)) {
-            error_setg(errp, "qemu_add_wait_object: failed");
-            goto err2;
-        }
-        stdio->hInputThread     = CreateThread(NULL, 0, win_stdio_thread,
-                                               chr, 0, &dwId);
-
-        if (stdio->hInputThread == INVALID_HANDLE_VALUE) {
-            error_setg(errp, "cannot create stdio thread");
-            goto err3;
-        }
-    }
-
-    dwMode |= ENABLE_LINE_INPUT;
-
-    if (is_console) {
-        /* set the terminal in raw mode */
-        /* ENABLE_QUICK_EDIT_MODE | ENABLE_EXTENDED_FLAGS */
-        dwMode |= ENABLE_PROCESSED_INPUT;
-    }
-
-    SetConsoleMode(stdio->hStdIn, dwMode);
-
-    chr->chr_set_echo = qemu_chr_set_echo_win_stdio;
-    qemu_chr_fe_set_echo(chr, false);
-
-    return chr;
-
-err3:
-    qemu_del_wait_object(stdio->hInputReadyEvent, NULL, NULL);
-err2:
-    CloseHandle(stdio->hInputReadyEvent);
-    CloseHandle(stdio->hInputDoneEvent);
-err1:
-    qemu_del_wait_object(stdio->hStdIn, NULL, NULL);
-    return NULL;
-}
-#endif /* !_WIN32 */
-
-
-/***********************************************************/
-/* UDP Net console */
-
-typedef struct {
-    QIOChannel *ioc;
-    uint8_t buf[READ_BUF_LEN];
-    int bufcnt;
-    int bufptr;
-    int max_size;
-} NetCharDriver;
-
-/* Called with chr_write_lock held.  */
-static int udp_chr_write(CharDriverState *chr, const uint8_t *buf, int len)
-{
-    NetCharDriver *s = chr->opaque;
-
-    return qio_channel_write(
-        s->ioc, (const char *)buf, len, NULL);
-}
-
-static int udp_chr_read_poll(void *opaque)
-{
-    CharDriverState *chr = opaque;
-    NetCharDriver *s = chr->opaque;
-
-    s->max_size = qemu_chr_be_can_write(chr);
-
-    /* If there were any stray characters in the queue process them
-     * first
-     */
-    while (s->max_size > 0 && s->bufptr < s->bufcnt) {
-        qemu_chr_be_write(chr, &s->buf[s->bufptr], 1);
-        s->bufptr++;
-        s->max_size = qemu_chr_be_can_write(chr);
-    }
-    return s->max_size;
-}
-
-static gboolean udp_chr_read(QIOChannel *chan, GIOCondition cond, void *opaque)
-{
-    CharDriverState *chr = opaque;
-    NetCharDriver *s = chr->opaque;
-    ssize_t ret;
-
-    if (s->max_size == 0) {
-        return TRUE;
-    }
-    ret = qio_channel_read(
-        s->ioc, (char *)s->buf, sizeof(s->buf), NULL);
-    if (ret <= 0) {
-        remove_fd_in_watch(chr);
-        return FALSE;
-    }
-    s->bufcnt = ret;
-
-    s->bufptr = 0;
-    while (s->max_size > 0 && s->bufptr < s->bufcnt) {
-        qemu_chr_be_write(chr, &s->buf[s->bufptr], 1);
-        s->bufptr++;
-        s->max_size = qemu_chr_be_can_write(chr);
-    }
-
-    return TRUE;
-}
-
-static void udp_chr_update_read_handler(CharDriverState *chr)
-{
-    NetCharDriver *s = chr->opaque;
-
-    remove_fd_in_watch(chr);
-    if (s->ioc) {
-        chr->fd_in_tag = io_add_watch_poll(s->ioc,
-                                           udp_chr_read_poll,
-                                           udp_chr_read, chr);
-    }
-}
-
-static void udp_chr_close(CharDriverState *chr)
-{
-    NetCharDriver *s = chr->opaque;
-
-    remove_fd_in_watch(chr);
-    if (s->ioc) {
-        object_unref(OBJECT(s->ioc));
-    }
-    g_free(s);
-    qemu_chr_be_event(chr, CHR_EVENT_CLOSED);
-}
-
-static CharDriverState *qemu_chr_open_udp(QIOChannelSocket *sioc,
-                                          ChardevCommon *backend,
-                                          Error **errp)
-{
-    CharDriverState *chr = NULL;
-    NetCharDriver *s = NULL;
-
-    chr = qemu_chr_alloc(backend, errp);
-    if (!chr) {
-        return NULL;
-    }
-    s = g_new0(NetCharDriver, 1);
-
-    s->ioc = QIO_CHANNEL(sioc);
-    s->bufcnt = 0;
-    s->bufptr = 0;
-    chr->opaque = s;
-    chr->chr_write = udp_chr_write;
-    chr->chr_update_read_handler = udp_chr_update_read_handler;
-    chr->chr_close = udp_chr_close;
-    /* be isn't opened until we get a connection */
-    chr->explicit_be_open = true;
-    return chr;
-}
-
-/***********************************************************/
-/* TCP Net console */
-
-typedef struct {
-    QIOChannel *ioc; /* Client I/O channel */
-    QIOChannelSocket *sioc; /* Client master channel */
-    QIOChannelSocket *listen_ioc;
-    guint listen_tag;
-    QCryptoTLSCreds *tls_creds;
-    int connected;
-    int max_size;
-    int do_telnetopt;
-    int do_nodelay;
-    int is_unix;
-    int *read_msgfds;
-    size_t read_msgfds_num;
-    int *write_msgfds;
-    size_t write_msgfds_num;
-
-    SocketAddress *addr;
-    bool is_listen;
-    bool is_telnet;
-
-    guint reconnect_timer;
-    int64_t reconnect_time;
-    bool connect_err_reported;
-} TCPCharDriver;
-
-static gboolean socket_reconnect_timeout(gpointer opaque);
-
-static void qemu_chr_socket_restart_timer(CharDriverState *chr)
-{
-    TCPCharDriver *s = chr->opaque;
-    assert(s->connected == 0);
-    s->reconnect_timer = g_timeout_add_seconds(s->reconnect_time,
-                                               socket_reconnect_timeout, chr);
-}
-
-static void check_report_connect_error(CharDriverState *chr,
-                                       Error *err)
-{
-    TCPCharDriver *s = chr->opaque;
-
-    if (!s->connect_err_reported) {
-        error_report("Unable to connect character device %s: %s",
-                     chr->label, error_get_pretty(err));
-        s->connect_err_reported = true;
-    }
-    qemu_chr_socket_restart_timer(chr);
-}
-
-static gboolean tcp_chr_accept(QIOChannel *chan,
-                               GIOCondition cond,
-                               void *opaque);
-
-/* Called with chr_write_lock held.  */
-static int tcp_chr_write(CharDriverState *chr, const uint8_t *buf, int len)
-{
-    TCPCharDriver *s = chr->opaque;
-    if (s->connected) {
-        int ret =  io_channel_send_full(s->ioc, buf, len,
-                                        s->write_msgfds,
-                                        s->write_msgfds_num);
-
-        /* free the written msgfds, no matter what */
-        if (s->write_msgfds_num) {
-            g_free(s->write_msgfds);
-            s->write_msgfds = 0;
-            s->write_msgfds_num = 0;
-        }
-
-        return ret;
-    } else {
-        /* XXX: indicate an error ? */
-        return len;
-    }
-}
-
-static int tcp_chr_read_poll(void *opaque)
-{
-    CharDriverState *chr = opaque;
-    TCPCharDriver *s = chr->opaque;
-    if (!s->connected)
-        return 0;
-    s->max_size = qemu_chr_be_can_write(chr);
-    return s->max_size;
-}
-
-#define IAC 255
-#define IAC_BREAK 243
-static void tcp_chr_process_IAC_bytes(CharDriverState *chr,
-                                      TCPCharDriver *s,
-                                      uint8_t *buf, int *size)
-{
-    /* Handle any telnet client's basic IAC options to satisfy char by
-     * char mode with no echo.  All IAC options will be removed from
-     * the buf and the do_telnetopt variable will be used to track the
-     * state of the width of the IAC information.
-     *
-     * IAC commands come in sets of 3 bytes with the exception of the
-     * "IAC BREAK" command and the double IAC.
-     */
-
-    int i;
-    int j = 0;
-
-    for (i = 0; i < *size; i++) {
-        if (s->do_telnetopt > 1) {
-            if ((unsigned char)buf[i] == IAC && s->do_telnetopt == 2) {
-                /* Double IAC means send an IAC */
-                if (j != i)
-                    buf[j] = buf[i];
-                j++;
-                s->do_telnetopt = 1;
-            } else {
-                if ((unsigned char)buf[i] == IAC_BREAK && s->do_telnetopt == 2) {
-                    /* Handle IAC break commands by sending a serial break */
-                    qemu_chr_be_event(chr, CHR_EVENT_BREAK);
-                    s->do_telnetopt++;
-                }
-                s->do_telnetopt++;
-            }
-            if (s->do_telnetopt >= 4) {
-                s->do_telnetopt = 1;
-            }
-        } else {
-            if ((unsigned char)buf[i] == IAC) {
-                s->do_telnetopt = 2;
-            } else {
-                if (j != i)
-                    buf[j] = buf[i];
-                j++;
-            }
-        }
-    }
-    *size = j;
-}
-
-static int tcp_get_msgfds(CharDriverState *chr, int *fds, int num)
-{
-    TCPCharDriver *s = chr->opaque;
-    int to_copy = (s->read_msgfds_num < num) ? s->read_msgfds_num : num;
-
-    assert(num <= TCP_MAX_FDS);
-
-    if (to_copy) {
-        int i;
-
-        memcpy(fds, s->read_msgfds, to_copy * sizeof(int));
-
-        /* Close unused fds */
-        for (i = to_copy; i < s->read_msgfds_num; i++) {
-            close(s->read_msgfds[i]);
-        }
-
-        g_free(s->read_msgfds);
-        s->read_msgfds = 0;
-        s->read_msgfds_num = 0;
-    }
-
-    return to_copy;
-}
-
-static int tcp_set_msgfds(CharDriverState *chr, int *fds, int num)
-{
-    TCPCharDriver *s = chr->opaque;
-
-    /* clear old pending fd array */
-    g_free(s->write_msgfds);
-    s->write_msgfds = NULL;
-    s->write_msgfds_num = 0;
-
-    if (!s->connected ||
-        !qio_channel_has_feature(s->ioc,
-                                 QIO_CHANNEL_FEATURE_FD_PASS)) {
-        return -1;
-    }
-
-    if (num) {
-        s->write_msgfds = g_new(int, num);
-        memcpy(s->write_msgfds, fds, num * sizeof(int));
-    }
-
-    s->write_msgfds_num = num;
-
-    return 0;
-}
-
-static ssize_t tcp_chr_recv(CharDriverState *chr, char *buf, size_t len)
-{
-    TCPCharDriver *s = chr->opaque;
-    struct iovec iov = { .iov_base = buf, .iov_len = len };
-    int ret;
-    size_t i;
-    int *msgfds = NULL;
-    size_t msgfds_num = 0;
-
-    if (qio_channel_has_feature(s->ioc, QIO_CHANNEL_FEATURE_FD_PASS)) {
-        ret = qio_channel_readv_full(s->ioc, &iov, 1,
-                                     &msgfds, &msgfds_num,
-                                     NULL);
-    } else {
-        ret = qio_channel_readv_full(s->ioc, &iov, 1,
-                                     NULL, NULL,
-                                     NULL);
-    }
-
-    if (ret == QIO_CHANNEL_ERR_BLOCK) {
-        errno = EAGAIN;
-        ret = -1;
-    } else if (ret == -1) {
-        errno = EIO;
-    }
-
-    if (msgfds_num) {
-        /* close and clean read_msgfds */
-        for (i = 0; i < s->read_msgfds_num; i++) {
-            close(s->read_msgfds[i]);
-        }
-
-        if (s->read_msgfds_num) {
-            g_free(s->read_msgfds);
-        }
-
-        s->read_msgfds = msgfds;
-        s->read_msgfds_num = msgfds_num;
-    }
-
-    for (i = 0; i < s->read_msgfds_num; i++) {
-        int fd = s->read_msgfds[i];
-        if (fd < 0) {
-            continue;
-        }
-
-        /* O_NONBLOCK is preserved across SCM_RIGHTS so reset it */
-        qemu_set_block(fd);
-
-#ifndef MSG_CMSG_CLOEXEC
-        qemu_set_cloexec(fd);
-#endif
-    }
-
-    return ret;
-}
-
-static GSource *tcp_chr_add_watch(CharDriverState *chr, GIOCondition cond)
-{
-    TCPCharDriver *s = chr->opaque;
-    return qio_channel_create_watch(s->ioc, cond);
-}
-
-static void tcp_chr_free_connection(CharDriverState *chr)
-{
-    TCPCharDriver *s = chr->opaque;
-    int i;
-
-    if (!s->connected) {
-        return;
-    }
-
-    if (s->read_msgfds_num) {
-        for (i = 0; i < s->read_msgfds_num; i++) {
-            close(s->read_msgfds[i]);
-        }
-        g_free(s->read_msgfds);
-        s->read_msgfds = NULL;
-        s->read_msgfds_num = 0;
-    }
-
-    tcp_set_msgfds(chr, NULL, 0);
-    remove_fd_in_watch(chr);
-    object_unref(OBJECT(s->sioc));
-    s->sioc = NULL;
-    object_unref(OBJECT(s->ioc));
-    s->ioc = NULL;
-    g_free(chr->filename);
-    chr->filename = NULL;
-    s->connected = 0;
-}
-
-static void tcp_chr_disconnect(CharDriverState *chr)
-{
-    TCPCharDriver *s = chr->opaque;
-
-    if (!s->connected) {
-        return;
-    }
-
-    tcp_chr_free_connection(chr);
-
-    if (s->listen_ioc) {
-        s->listen_tag = qio_channel_add_watch(
-            QIO_CHANNEL(s->listen_ioc), G_IO_IN, tcp_chr_accept, chr, NULL);
-    }
-    chr->filename = SocketAddress_to_str("disconnected:", s->addr,
-                                         s->is_listen, s->is_telnet);
-    qemu_chr_be_event(chr, CHR_EVENT_CLOSED);
-    if (s->reconnect_time) {
-        qemu_chr_socket_restart_timer(chr);
-    }
-}
-
-static gboolean tcp_chr_read(QIOChannel *chan, GIOCondition cond, void *opaque)
-{
-    CharDriverState *chr = opaque;
-    TCPCharDriver *s = chr->opaque;
-    uint8_t buf[READ_BUF_LEN];
-    int len, size;
-
-    if (!s->connected || s->max_size <= 0) {
-        return TRUE;
-    }
-    len = sizeof(buf);
-    if (len > s->max_size)
-        len = s->max_size;
-    size = tcp_chr_recv(chr, (void *)buf, len);
-    if (size == 0 || size == -1) {
-        /* connection closed */
-        tcp_chr_disconnect(chr);
-    } else if (size > 0) {
-        if (s->do_telnetopt)
-            tcp_chr_process_IAC_bytes(chr, s, buf, &size);
-        if (size > 0)
-            qemu_chr_be_write(chr, buf, size);
-    }
-
-    return TRUE;
-}
-
-static int tcp_chr_sync_read(CharDriverState *chr, const uint8_t *buf, int len)
-{
-    TCPCharDriver *s = chr->opaque;
-    int size;
-
-    if (!s->connected) {
-        return 0;
-    }
-
-    size = tcp_chr_recv(chr, (void *) buf, len);
-    if (size == 0) {
-        /* connection closed */
-        tcp_chr_disconnect(chr);
-    }
-
-    return size;
-}
-
-static void tcp_chr_connect(void *opaque)
-{
-    CharDriverState *chr = opaque;
-    TCPCharDriver *s = chr->opaque;
-
-    g_free(chr->filename);
-    chr->filename = sockaddr_to_str(
-        &s->sioc->localAddr, s->sioc->localAddrLen,
-        &s->sioc->remoteAddr, s->sioc->remoteAddrLen,
-        s->is_listen, s->is_telnet);
-
-    s->connected = 1;
-    if (s->ioc) {
-        chr->fd_in_tag = io_add_watch_poll(s->ioc,
-                                           tcp_chr_read_poll,
-                                           tcp_chr_read, chr);
-    }
-    qemu_chr_be_generic_open(chr);
-}
-
-static void tcp_chr_update_read_handler(CharDriverState *chr)
-{
-    TCPCharDriver *s = chr->opaque;
-
-    if (!s->connected) {
-        return;
-    }
-
-    remove_fd_in_watch(chr);
-    if (s->ioc) {
-        chr->fd_in_tag = io_add_watch_poll(s->ioc,
-                                           tcp_chr_read_poll,
-                                           tcp_chr_read, chr);
-    }
-}
-
-typedef struct {
-    CharDriverState *chr;
-    char buf[12];
-    size_t buflen;
-} TCPCharDriverTelnetInit;
-
-static gboolean tcp_chr_telnet_init_io(QIOChannel *ioc,
-                                       GIOCondition cond G_GNUC_UNUSED,
-                                       gpointer user_data)
-{
-    TCPCharDriverTelnetInit *init = user_data;
-    ssize_t ret;
-
-    ret = qio_channel_write(ioc, init->buf, init->buflen, NULL);
-    if (ret < 0) {
-        if (ret == QIO_CHANNEL_ERR_BLOCK) {
-            ret = 0;
-        } else {
-            tcp_chr_disconnect(init->chr);
-            return FALSE;
-        }
-    }
-    init->buflen -= ret;
-
-    if (init->buflen == 0) {
-        tcp_chr_connect(init->chr);
-        return FALSE;
-    }
-
-    memmove(init->buf, init->buf + ret, init->buflen);
-
-    return TRUE;
-}
-
-static void tcp_chr_telnet_init(CharDriverState *chr)
-{
-    TCPCharDriver *s = chr->opaque;
-    TCPCharDriverTelnetInit *init =
-        g_new0(TCPCharDriverTelnetInit, 1);
-    size_t n = 0;
-
-    init->chr = chr;
-    init->buflen = 12;
-
-#define IACSET(x, a, b, c)                      \
-    do {                                        \
-        x[n++] = a;                             \
-        x[n++] = b;                             \
-        x[n++] = c;                             \
-    } while (0)
-
-    /* Prep the telnet negotion to put telnet in binary,
-     * no echo, single char mode */
-    IACSET(init->buf, 0xff, 0xfb, 0x01);  /* IAC WILL ECHO */
-    IACSET(init->buf, 0xff, 0xfb, 0x03);  /* IAC WILL Suppress go ahead */
-    IACSET(init->buf, 0xff, 0xfb, 0x00);  /* IAC WILL Binary */
-    IACSET(init->buf, 0xff, 0xfd, 0x00);  /* IAC DO Binary */
-
-#undef IACSET
-
-    qio_channel_add_watch(
-        s->ioc, G_IO_OUT,
-        tcp_chr_telnet_init_io,
-        init, NULL);
-}
-
-
-static void tcp_chr_tls_handshake(Object *source,
-                                  Error *err,
-                                  gpointer user_data)
-{
-    CharDriverState *chr = user_data;
-    TCPCharDriver *s = chr->opaque;
-
-    if (err) {
-        tcp_chr_disconnect(chr);
-    } else {
-        if (s->do_telnetopt) {
-            tcp_chr_telnet_init(chr);
-        } else {
-            tcp_chr_connect(chr);
-        }
-    }
-}
-
-
-static void tcp_chr_tls_init(CharDriverState *chr)
-{
-    TCPCharDriver *s = chr->opaque;
-    QIOChannelTLS *tioc;
-    Error *err = NULL;
-
-    if (s->is_listen) {
-        tioc = qio_channel_tls_new_server(
-            s->ioc, s->tls_creds,
-            NULL, /* XXX Use an ACL */
-            &err);
-    } else {
-        tioc = qio_channel_tls_new_client(
-            s->ioc, s->tls_creds,
-            s->addr->u.inet.data->host,
-            &err);
-    }
-    if (tioc == NULL) {
-        error_free(err);
-        tcp_chr_disconnect(chr);
-    }
-    object_unref(OBJECT(s->ioc));
-    s->ioc = QIO_CHANNEL(tioc);
-
-    qio_channel_tls_handshake(tioc,
-                              tcp_chr_tls_handshake,
-                              chr,
-                              NULL);
-}
-
-
-static int tcp_chr_new_client(CharDriverState *chr, QIOChannelSocket *sioc)
-{
-    TCPCharDriver *s = chr->opaque;
-    if (s->ioc != NULL) {
-	return -1;
-    }
-
-    s->ioc = QIO_CHANNEL(sioc);
-    object_ref(OBJECT(sioc));
-    s->sioc = sioc;
-    object_ref(OBJECT(sioc));
-
-    qio_channel_set_blocking(s->ioc, false, NULL);
-
-    if (s->do_nodelay) {
-        qio_channel_set_delay(s->ioc, false);
-    }
-    if (s->listen_tag) {
-        g_source_remove(s->listen_tag);
-        s->listen_tag = 0;
-    }
-
-    if (s->tls_creds) {
-        tcp_chr_tls_init(chr);
-    } else {
-        if (s->do_telnetopt) {
-            tcp_chr_telnet_init(chr);
-        } else {
-            tcp_chr_connect(chr);
-        }
-    }
-
-    return 0;
-}
-
-
-static int tcp_chr_add_client(CharDriverState *chr, int fd)
-{
-    int ret;
-    QIOChannelSocket *sioc;
-
-    sioc = qio_channel_socket_new_fd(fd, NULL);
-    if (!sioc) {
-        return -1;
-    }
-    ret = tcp_chr_new_client(chr, sioc);
-    object_unref(OBJECT(sioc));
-    return ret;
-}
-
-static gboolean tcp_chr_accept(QIOChannel *channel,
-                               GIOCondition cond,
-                               void *opaque)
-{
-    CharDriverState *chr = opaque;
-    QIOChannelSocket *sioc;
-
-    sioc = qio_channel_socket_accept(QIO_CHANNEL_SOCKET(channel),
-                                     NULL);
-    if (!sioc) {
-        return TRUE;
-    }
-
-    tcp_chr_new_client(chr, sioc);
-
-    object_unref(OBJECT(sioc));
-
-    return TRUE;
-}
-
-static int tcp_chr_wait_connected(CharDriverState *chr, Error **errp)
-{
-    TCPCharDriver *s = chr->opaque;
-    QIOChannelSocket *sioc;
-
-    /* It can't wait on s->connected, since it is set asynchronously
-     * in TLS and telnet cases, only wait for an accepted socket */
-    while (!s->ioc) {
-        if (s->is_listen) {
-            fprintf(stderr, "QEMU waiting for connection on: %s\n",
-                    chr->filename);
-            qio_channel_set_blocking(QIO_CHANNEL(s->listen_ioc), true, NULL);
-            tcp_chr_accept(QIO_CHANNEL(s->listen_ioc), G_IO_IN, chr);
-            qio_channel_set_blocking(QIO_CHANNEL(s->listen_ioc), false, NULL);
-        } else {
-            sioc = qio_channel_socket_new();
-            if (qio_channel_socket_connect_sync(sioc, s->addr, errp) < 0) {
-                object_unref(OBJECT(sioc));
-                return -1;
-            }
-            tcp_chr_new_client(chr, sioc);
-            object_unref(OBJECT(sioc));
-        }
-    }
-
-    return 0;
-}
-
-int qemu_chr_wait_connected(CharDriverState *chr, Error **errp)
-{
-    if (chr->chr_wait_connected) {
-        return chr->chr_wait_connected(chr, errp);
-    }
-
-    return 0;
-}
-
-static void tcp_chr_close(CharDriverState *chr)
-{
-    TCPCharDriver *s = chr->opaque;
-
-    tcp_chr_free_connection(chr);
-
-    if (s->reconnect_timer) {
-        g_source_remove(s->reconnect_timer);
-        s->reconnect_timer = 0;
-    }
-    qapi_free_SocketAddress(s->addr);
-    if (s->listen_tag) {
-        g_source_remove(s->listen_tag);
-        s->listen_tag = 0;
-    }
-    if (s->listen_ioc) {
-        object_unref(OBJECT(s->listen_ioc));
-    }
-    if (s->tls_creds) {
-        object_unref(OBJECT(s->tls_creds));
-    }
-    g_free(s);
-    qemu_chr_be_event(chr, CHR_EVENT_CLOSED);
-}
-
-
-static void qemu_chr_socket_connected(Object *src, Error *err, void *opaque)
-{
-    QIOChannelSocket *sioc = QIO_CHANNEL_SOCKET(src);
-    CharDriverState *chr = opaque;
-    TCPCharDriver *s = chr->opaque;
-
-    if (err) {
-        check_report_connect_error(chr, err);
-        object_unref(src);
-        return;
-    }
-
-    s->connect_err_reported = false;
-    tcp_chr_new_client(chr, sioc);
-    object_unref(OBJECT(sioc));
-}
-
-
-/*********************************************************/
-/* Ring buffer chardev */
-
-typedef struct {
-    size_t size;
-    size_t prod;
-    size_t cons;
-    uint8_t *cbuf;
-} RingBufCharDriver;
-
-static size_t ringbuf_count(const CharDriverState *chr)
-{
-    const RingBufCharDriver *d = chr->opaque;
-
-    return d->prod - d->cons;
-}
-
-/* Called with chr_write_lock held.  */
-static int ringbuf_chr_write(CharDriverState *chr, const uint8_t *buf, int len)
-{
-    RingBufCharDriver *d = chr->opaque;
-    int i;
-
-    if (!buf || (len < 0)) {
-        return -1;
-    }
-
-    for (i = 0; i < len; i++ ) {
-        d->cbuf[d->prod++ & (d->size - 1)] = buf[i];
-        if (d->prod - d->cons > d->size) {
-            d->cons = d->prod - d->size;
-        }
-    }
-
-    return 0;
-}
-
-static int ringbuf_chr_read(CharDriverState *chr, uint8_t *buf, int len)
-{
-    RingBufCharDriver *d = chr->opaque;
-    int i;
-
-    qemu_mutex_lock(&chr->chr_write_lock);
-    for (i = 0; i < len && d->cons != d->prod; i++) {
-        buf[i] = d->cbuf[d->cons++ & (d->size - 1)];
-    }
-    qemu_mutex_unlock(&chr->chr_write_lock);
-
-    return i;
-}
-
-static void ringbuf_chr_close(struct CharDriverState *chr)
-{
-    RingBufCharDriver *d = chr->opaque;
-
-    g_free(d->cbuf);
-    g_free(d);
-    chr->opaque = NULL;
-}
-
-static CharDriverState *qemu_chr_open_ringbuf(const char *id,
-                                              ChardevBackend *backend,
-                                              ChardevReturn *ret,
-                                              Error **errp)
-{
-    ChardevRingbuf *opts = backend->u.ringbuf.data;
-    ChardevCommon *common = qapi_ChardevRingbuf_base(opts);
-    CharDriverState *chr;
-    RingBufCharDriver *d;
-
-    chr = qemu_chr_alloc(common, errp);
-    if (!chr) {
-        return NULL;
-    }
-    d = g_malloc(sizeof(*d));
-
-    d->size = opts->has_size ? opts->size : 65536;
-
-    /* The size must be power of 2 */
-    if (d->size & (d->size - 1)) {
-        error_setg(errp, "size of ringbuf chardev must be power of two");
-        goto fail;
-    }
-
-    d->prod = 0;
-    d->cons = 0;
-    d->cbuf = g_malloc0(d->size);
-
-    chr->opaque = d;
-    chr->chr_write = ringbuf_chr_write;
-    chr->chr_close = ringbuf_chr_close;
-
-    return chr;
-
-fail:
-    g_free(d);
-    qemu_chr_free_common(chr);
-    return NULL;
-}
-
-bool chr_is_ringbuf(const CharDriverState *chr)
-{
-    return chr->chr_write == ringbuf_chr_write;
-}
-
-void qmp_ringbuf_write(const char *device, const char *data,
-                       bool has_format, enum DataFormat format,
-                       Error **errp)
-{
-    CharDriverState *chr;
-    const uint8_t *write_data;
-    int ret;
-    gsize write_count;
-
-    chr = qemu_chr_find(device);
-    if (!chr) {
-        error_setg(errp, "Device '%s' not found", device);
-        return;
-    }
-
-    if (!chr_is_ringbuf(chr)) {
-        error_setg(errp,"%s is not a ringbuf device", device);
-        return;
-    }
-
-    if (has_format && (format == DATA_FORMAT_BASE64)) {
-        write_data = qbase64_decode(data, -1,
-                                    &write_count,
-                                    errp);
-        if (!write_data) {
-            return;
-        }
-    } else {
-        write_data = (uint8_t *)data;
-        write_count = strlen(data);
-    }
-
-    ret = ringbuf_chr_write(chr, write_data, write_count);
-
-    if (write_data != (uint8_t *)data) {
-        g_free((void *)write_data);
-    }
-
-    if (ret < 0) {
-        error_setg(errp, "Failed to write to device %s", device);
-        return;
-    }
-}
-
-char *qmp_ringbuf_read(const char *device, int64_t size,
-                       bool has_format, enum DataFormat format,
-                       Error **errp)
-{
-    CharDriverState *chr;
-    uint8_t *read_data;
-    size_t count;
-    char *data;
-
-    chr = qemu_chr_find(device);
-    if (!chr) {
-        error_setg(errp, "Device '%s' not found", device);
-        return NULL;
-    }
-
-    if (!chr_is_ringbuf(chr)) {
-        error_setg(errp,"%s is not a ringbuf device", device);
-        return NULL;
-    }
-
-    if (size <= 0) {
-        error_setg(errp, "size must be greater than zero");
-        return NULL;
-    }
-
-    count = ringbuf_count(chr);
-    size = size > count ? count : size;
-    read_data = g_malloc(size + 1);
-
-    ringbuf_chr_read(chr, read_data, size);
-
-    if (has_format && (format == DATA_FORMAT_BASE64)) {
-        data = g_base64_encode(read_data, size);
-        g_free(read_data);
-    } else {
-        /*
-         * FIXME should read only complete, valid UTF-8 characters up
-         * to @size bytes.  Invalid sequences should be replaced by a
-         * suitable replacement character.  Except when (and only
-         * when) ring buffer lost characters since last read, initial
-         * continuation characters should be dropped.
-         */
-        read_data[size] = 0;
-        data = (char *)read_data;
-    }
-
-    return data;
-}
-
-QemuOpts *qemu_chr_parse_compat(const char *label, const char *filename)
-{
-    char host[65], port[33], width[8], height[8];
-    int pos;
-    const char *p;
-    QemuOpts *opts;
-    Error *local_err = NULL;
-
-    opts = qemu_opts_create(qemu_find_opts("chardev"), label, 1, &local_err);
-    if (local_err) {
-        error_report_err(local_err);
-        return NULL;
-    }
-
-    if (strstart(filename, "mon:", &p)) {
-        filename = p;
-        qemu_opt_set(opts, "mux", "on", &error_abort);
-        if (strcmp(filename, "stdio") == 0) {
-            /* Monitor is muxed to stdio: do not exit on Ctrl+C by default
-             * but pass it to the guest.  Handle this only for compat syntax,
-             * for -chardev syntax we have special option for this.
-             * This is what -nographic did, redirecting+muxing serial+monitor
-             * to stdio causing Ctrl+C to be passed to guest. */
-            qemu_opt_set(opts, "signal", "off", &error_abort);
-        }
-    }
-
-    if (strcmp(filename, "null")    == 0 ||
-        strcmp(filename, "pty")     == 0 ||
-        strcmp(filename, "msmouse") == 0 ||
-        strcmp(filename, "braille") == 0 ||
-        strcmp(filename, "testdev") == 0 ||
-        strcmp(filename, "stdio")   == 0) {
-        qemu_opt_set(opts, "backend", filename, &error_abort);
-        return opts;
-    }
-    if (strstart(filename, "vc", &p)) {
-        qemu_opt_set(opts, "backend", "vc", &error_abort);
-        if (*p == ':') {
-            if (sscanf(p+1, "%7[0-9]x%7[0-9]", width, height) == 2) {
-                /* pixels */
-                qemu_opt_set(opts, "width", width, &error_abort);
-                qemu_opt_set(opts, "height", height, &error_abort);
-            } else if (sscanf(p+1, "%7[0-9]Cx%7[0-9]C", width, height) == 2) {
-                /* chars */
-                qemu_opt_set(opts, "cols", width, &error_abort);
-                qemu_opt_set(opts, "rows", height, &error_abort);
-            } else {
-                goto fail;
-            }
-        }
-        return opts;
-    }
-    if (strcmp(filename, "con:") == 0) {
-        qemu_opt_set(opts, "backend", "console", &error_abort);
-        return opts;
-    }
-    if (strstart(filename, "COM", NULL)) {
-        qemu_opt_set(opts, "backend", "serial", &error_abort);
-        qemu_opt_set(opts, "path", filename, &error_abort);
-        return opts;
-    }
-    if (strstart(filename, "file:", &p)) {
-        qemu_opt_set(opts, "backend", "file", &error_abort);
-        qemu_opt_set(opts, "path", p, &error_abort);
-        return opts;
-    }
-    if (strstart(filename, "pipe:", &p)) {
-        qemu_opt_set(opts, "backend", "pipe", &error_abort);
-        qemu_opt_set(opts, "path", p, &error_abort);
-        return opts;
-    }
-    if (strstart(filename, "tcp:", &p) ||
-        strstart(filename, "telnet:", &p)) {
-        if (sscanf(p, "%64[^:]:%32[^,]%n", host, port, &pos) < 2) {
-            host[0] = 0;
-            if (sscanf(p, ":%32[^,]%n", port, &pos) < 1)
-                goto fail;
-        }
-        qemu_opt_set(opts, "backend", "socket", &error_abort);
-        qemu_opt_set(opts, "host", host, &error_abort);
-        qemu_opt_set(opts, "port", port, &error_abort);
-        if (p[pos] == ',') {
-            qemu_opts_do_parse(opts, p+pos+1, NULL, &local_err);
-            if (local_err) {
-                error_report_err(local_err);
-                goto fail;
-            }
-        }
-        if (strstart(filename, "telnet:", &p))
-            qemu_opt_set(opts, "telnet", "on", &error_abort);
-        return opts;
-    }
-    if (strstart(filename, "udp:", &p)) {
-        qemu_opt_set(opts, "backend", "udp", &error_abort);
-        if (sscanf(p, "%64[^:]:%32[^@,]%n", host, port, &pos) < 2) {
-            host[0] = 0;
-            if (sscanf(p, ":%32[^@,]%n", port, &pos) < 1) {
-                goto fail;
-            }
-        }
-        qemu_opt_set(opts, "host", host, &error_abort);
-        qemu_opt_set(opts, "port", port, &error_abort);
-        if (p[pos] == '@') {
-            p += pos + 1;
-            if (sscanf(p, "%64[^:]:%32[^,]%n", host, port, &pos) < 2) {
-                host[0] = 0;
-                if (sscanf(p, ":%32[^,]%n", port, &pos) < 1) {
-                    goto fail;
-                }
-            }
-            qemu_opt_set(opts, "localaddr", host, &error_abort);
-            qemu_opt_set(opts, "localport", port, &error_abort);
-        }
-        return opts;
-    }
-    if (strstart(filename, "unix:", &p)) {
-        qemu_opt_set(opts, "backend", "socket", &error_abort);
-        qemu_opts_do_parse(opts, p, "path", &local_err);
-        if (local_err) {
-            error_report_err(local_err);
-            goto fail;
-        }
-        return opts;
-    }
-    if (strstart(filename, "/dev/parport", NULL) ||
-        strstart(filename, "/dev/ppi", NULL)) {
-        qemu_opt_set(opts, "backend", "parport", &error_abort);
-        qemu_opt_set(opts, "path", filename, &error_abort);
-        return opts;
-    }
-    if (strstart(filename, "/dev/", NULL)) {
-        qemu_opt_set(opts, "backend", "tty", &error_abort);
-        qemu_opt_set(opts, "path", filename, &error_abort);
-        return opts;
-    }
-
-fail:
-    qemu_opts_del(opts);
-    return NULL;
-}
-
-void qemu_chr_parse_common(QemuOpts *opts, ChardevCommon *backend)
-{
-    const char *logfile = qemu_opt_get(opts, "logfile");
-
-    backend->has_logfile = logfile != NULL;
-    backend->logfile = logfile ? g_strdup(logfile) : NULL;
-
-    backend->has_logappend = true;
-    backend->logappend = qemu_opt_get_bool(opts, "logappend", false);
-}
-
-
-static void qemu_chr_parse_file_out(QemuOpts *opts, ChardevBackend *backend,
-                                    Error **errp)
-{
-    const char *path = qemu_opt_get(opts, "path");
-    ChardevFile *file;
-
-    if (path == NULL) {
-        error_setg(errp, "chardev: file: no filename given");
-        return;
-    }
-    file = backend->u.file.data = g_new0(ChardevFile, 1);
-    qemu_chr_parse_common(opts, qapi_ChardevFile_base(file));
-    file->out = g_strdup(path);
-
-    file->has_append = true;
-    file->append = qemu_opt_get_bool(opts, "append", false);
-}
-
-static void qemu_chr_parse_stdio(QemuOpts *opts, ChardevBackend *backend,
-                                 Error **errp)
-{
-    ChardevStdio *stdio;
-
-    stdio = backend->u.stdio.data = g_new0(ChardevStdio, 1);
-    qemu_chr_parse_common(opts, qapi_ChardevStdio_base(stdio));
-    stdio->has_signal = true;
-    stdio->signal = qemu_opt_get_bool(opts, "signal", true);
-}
-
-#ifdef HAVE_CHARDEV_SERIAL
-static void qemu_chr_parse_serial(QemuOpts *opts, ChardevBackend *backend,
-                                  Error **errp)
-{
-    const char *device = qemu_opt_get(opts, "path");
-    ChardevHostdev *serial;
-
-    if (device == NULL) {
-        error_setg(errp, "chardev: serial/tty: no device path given");
-        return;
-    }
-    serial = backend->u.serial.data = g_new0(ChardevHostdev, 1);
-    qemu_chr_parse_common(opts, qapi_ChardevHostdev_base(serial));
-    serial->device = g_strdup(device);
-}
-#endif
-
-#ifdef HAVE_CHARDEV_PARPORT
-static void qemu_chr_parse_parallel(QemuOpts *opts, ChardevBackend *backend,
-                                    Error **errp)
-{
-    const char *device = qemu_opt_get(opts, "path");
-    ChardevHostdev *parallel;
-
-    if (device == NULL) {
-        error_setg(errp, "chardev: parallel: no device path given");
-        return;
-    }
-    parallel = backend->u.parallel.data = g_new0(ChardevHostdev, 1);
-    qemu_chr_parse_common(opts, qapi_ChardevHostdev_base(parallel));
-    parallel->device = g_strdup(device);
-}
-#endif
-
-static void qemu_chr_parse_pipe(QemuOpts *opts, ChardevBackend *backend,
-                                Error **errp)
-{
-    const char *device = qemu_opt_get(opts, "path");
-    ChardevHostdev *dev;
-
-    if (device == NULL) {
-        error_setg(errp, "chardev: pipe: no device path given");
-        return;
-    }
-    dev = backend->u.pipe.data = g_new0(ChardevHostdev, 1);
-    qemu_chr_parse_common(opts, qapi_ChardevHostdev_base(dev));
-    dev->device = g_strdup(device);
-}
-
-static void qemu_chr_parse_ringbuf(QemuOpts *opts, ChardevBackend *backend,
-                                   Error **errp)
-{
-    int val;
-    ChardevRingbuf *ringbuf;
-
-    ringbuf = backend->u.ringbuf.data = g_new0(ChardevRingbuf, 1);
-    qemu_chr_parse_common(opts, qapi_ChardevRingbuf_base(ringbuf));
-
-    val = qemu_opt_get_size(opts, "size", 0);
-    if (val != 0) {
-        ringbuf->has_size = true;
-        ringbuf->size = val;
-    }
-}
-
-static void qemu_chr_parse_mux(QemuOpts *opts, ChardevBackend *backend,
-                               Error **errp)
-{
-    const char *chardev = qemu_opt_get(opts, "chardev");
-    ChardevMux *mux;
-
-    if (chardev == NULL) {
-        error_setg(errp, "chardev: mux: no chardev given");
-        return;
-    }
-    mux = backend->u.mux.data = g_new0(ChardevMux, 1);
-    qemu_chr_parse_common(opts, qapi_ChardevMux_base(mux));
-    mux->chardev = g_strdup(chardev);
-}
-
-static void qemu_chr_parse_socket(QemuOpts *opts, ChardevBackend *backend,
-                                  Error **errp)
-{
-    bool is_listen      = qemu_opt_get_bool(opts, "server", false);
-    bool is_waitconnect = is_listen && qemu_opt_get_bool(opts, "wait", true);
-    bool is_telnet      = qemu_opt_get_bool(opts, "telnet", false);
-    bool do_nodelay     = !qemu_opt_get_bool(opts, "delay", true);
-    int64_t reconnect   = qemu_opt_get_number(opts, "reconnect", 0);
-    const char *path = qemu_opt_get(opts, "path");
-    const char *host = qemu_opt_get(opts, "host");
-    const char *port = qemu_opt_get(opts, "port");
-    const char *tls_creds = qemu_opt_get(opts, "tls-creds");
-    SocketAddress *addr;
-    ChardevSocket *sock;
-
-    if (!path) {
-        if (!host) {
-            error_setg(errp, "chardev: socket: no host given");
-            return;
-        }
-        if (!port) {
-            error_setg(errp, "chardev: socket: no port given");
-            return;
-        }
-    } else {
-        if (tls_creds) {
-            error_setg(errp, "TLS can only be used over TCP socket");
-            return;
-        }
-    }
-
-    sock = backend->u.socket.data = g_new0(ChardevSocket, 1);
-    qemu_chr_parse_common(opts, qapi_ChardevSocket_base(sock));
-
-    sock->has_nodelay = true;
-    sock->nodelay = do_nodelay;
-    sock->has_server = true;
-    sock->server = is_listen;
-    sock->has_telnet = true;
-    sock->telnet = is_telnet;
-    sock->has_wait = true;
-    sock->wait = is_waitconnect;
-    sock->has_reconnect = true;
-    sock->reconnect = reconnect;
-    sock->tls_creds = g_strdup(tls_creds);
-
-    addr = g_new0(SocketAddress, 1);
-    if (path) {
-        UnixSocketAddress *q_unix;
-        addr->type = SOCKET_ADDRESS_KIND_UNIX;
-        q_unix = addr->u.q_unix.data = g_new0(UnixSocketAddress, 1);
-        q_unix->path = g_strdup(path);
-    } else {
-        addr->type = SOCKET_ADDRESS_KIND_INET;
-        addr->u.inet.data = g_new(InetSocketAddress, 1);
-        *addr->u.inet.data = (InetSocketAddress) {
-            .host = g_strdup(host),
-            .port = g_strdup(port),
-            .has_to = qemu_opt_get(opts, "to"),
-            .to = qemu_opt_get_number(opts, "to", 0),
-            .has_ipv4 = qemu_opt_get(opts, "ipv4"),
-            .ipv4 = qemu_opt_get_bool(opts, "ipv4", 0),
-            .has_ipv6 = qemu_opt_get(opts, "ipv6"),
-            .ipv6 = qemu_opt_get_bool(opts, "ipv6", 0),
-        };
-    }
-    sock->addr = addr;
-}
-
-static void qemu_chr_parse_udp(QemuOpts *opts, ChardevBackend *backend,
-                               Error **errp)
-{
-    const char *host = qemu_opt_get(opts, "host");
-    const char *port = qemu_opt_get(opts, "port");
-    const char *localaddr = qemu_opt_get(opts, "localaddr");
-    const char *localport = qemu_opt_get(opts, "localport");
-    bool has_local = false;
-    SocketAddress *addr;
-    ChardevUdp *udp;
-
-    if (host == NULL || strlen(host) == 0) {
-        host = "localhost";
-    }
-    if (port == NULL || strlen(port) == 0) {
-        error_setg(errp, "chardev: udp: remote port not specified");
-        return;
-    }
-    if (localport == NULL || strlen(localport) == 0) {
-        localport = "0";
-    } else {
-        has_local = true;
-    }
-    if (localaddr == NULL || strlen(localaddr) == 0) {
-        localaddr = "";
-    } else {
-        has_local = true;
-    }
-
-    udp = backend->u.udp.data = g_new0(ChardevUdp, 1);
-    qemu_chr_parse_common(opts, qapi_ChardevUdp_base(udp));
-
-    addr = g_new0(SocketAddress, 1);
-    addr->type = SOCKET_ADDRESS_KIND_INET;
-    addr->u.inet.data = g_new(InetSocketAddress, 1);
-    *addr->u.inet.data = (InetSocketAddress) {
-        .host = g_strdup(host),
-        .port = g_strdup(port),
-        .has_ipv4 = qemu_opt_get(opts, "ipv4"),
-        .ipv4 = qemu_opt_get_bool(opts, "ipv4", 0),
-        .has_ipv6 = qemu_opt_get(opts, "ipv6"),
-        .ipv6 = qemu_opt_get_bool(opts, "ipv6", 0),
-    };
-    udp->remote = addr;
-
-    if (has_local) {
-        udp->has_local = true;
-        addr = g_new0(SocketAddress, 1);
-        addr->type = SOCKET_ADDRESS_KIND_INET;
-        addr->u.inet.data = g_new(InetSocketAddress, 1);
-        *addr->u.inet.data = (InetSocketAddress) {
-            .host = g_strdup(localaddr),
-            .port = g_strdup(localport),
-        };
-        udp->local = addr;
-    }
-}
-
-typedef struct CharDriver {
-    const char *name;
-    ChardevBackendKind kind;
-    void (*parse)(QemuOpts *opts, ChardevBackend *backend, Error **errp);
-    CharDriverState *(*create)(const char *id, ChardevBackend *backend,
-                               ChardevReturn *ret, Error **errp);
-} CharDriver;
-
-static GSList *backends;
-
-void register_char_driver(const char *name, ChardevBackendKind kind,
-        void (*parse)(QemuOpts *opts, ChardevBackend *backend, Error **errp),
-        CharDriverState *(*create)(const char *id, ChardevBackend *backend,
-                                   ChardevReturn *ret, Error **errp))
-{
-    CharDriver *s;
-
-    s = g_malloc0(sizeof(*s));
-    s->name = g_strdup(name);
-    s->kind = kind;
-    s->parse = parse;
-    s->create = create;
-
-    backends = g_slist_append(backends, s);
-}
-
-CharDriverState *qemu_chr_new_from_opts(QemuOpts *opts,
-                                    void (*init)(struct CharDriverState *s),
-                                    Error **errp)
-{
-    Error *local_err = NULL;
-    CharDriver *cd;
-    CharDriverState *chr;
-    GSList *i;
-    ChardevReturn *ret = NULL;
-    ChardevBackend *backend;
-    const char *id = qemu_opts_id(opts);
-    char *bid = NULL;
-
-    if (id == NULL) {
-        error_setg(errp, "chardev: no id specified");
-        goto err;
-    }
-
-    if (qemu_opt_get(opts, "backend") == NULL) {
-        error_setg(errp, "chardev: \"%s\" missing backend",
-                   qemu_opts_id(opts));
-        goto err;
-    }
-    for (i = backends; i; i = i->next) {
-        cd = i->data;
-
-        if (strcmp(cd->name, qemu_opt_get(opts, "backend")) == 0) {
-            break;
-        }
-    }
-    if (i == NULL) {
-        error_setg(errp, "chardev: backend \"%s\" not found",
-                   qemu_opt_get(opts, "backend"));
-        goto err;
-    }
-
-    backend = g_new0(ChardevBackend, 1);
-
-    if (qemu_opt_get_bool(opts, "mux", 0)) {
-        bid = g_strdup_printf("%s-base", id);
-    }
-
-    chr = NULL;
-    backend->type = cd->kind;
-    if (cd->parse) {
-        cd->parse(opts, backend, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
-            goto qapi_out;
-        }
-    } else {
-        ChardevCommon *cc = g_new0(ChardevCommon, 1);
-        qemu_chr_parse_common(opts, cc);
-        backend->u.null.data = cc; /* Any ChardevCommon member would work */
-    }
-
-    ret = qmp_chardev_add(bid ? bid : id, backend, errp);
-    if (!ret) {
-        goto qapi_out;
-    }
-
-    if (bid) {
-        qapi_free_ChardevBackend(backend);
-        qapi_free_ChardevReturn(ret);
-        backend = g_new0(ChardevBackend, 1);
-        backend->u.mux.data = g_new0(ChardevMux, 1);
-        backend->type = CHARDEV_BACKEND_KIND_MUX;
-        backend->u.mux.data->chardev = g_strdup(bid);
-        ret = qmp_chardev_add(id, backend, errp);
-        if (!ret) {
-            chr = qemu_chr_find(bid);
-            qemu_chr_delete(chr);
-            chr = NULL;
-            goto qapi_out;
-        }
-    }
-
-    chr = qemu_chr_find(id);
-    chr->opts = opts;
-
-qapi_out:
-    qapi_free_ChardevBackend(backend);
-    qapi_free_ChardevReturn(ret);
-    g_free(bid);
-    return chr;
-
-err:
-    qemu_opts_del(opts);
-    return NULL;
-}
-
-CharDriverState *qemu_chr_new_noreplay(const char *label, const char *filename,
-                                       void (*init)(struct CharDriverState *s))
-{
-    const char *p;
-    CharDriverState *chr;
-    QemuOpts *opts;
-    Error *err = NULL;
-
-    if (strstart(filename, "chardev:", &p)) {
-        return qemu_chr_find(p);
-    }
-
-    opts = qemu_chr_parse_compat(label, filename);
-    if (!opts)
-        return NULL;
-
-    chr = qemu_chr_new_from_opts(opts, init, &err);
-    if (err) {
-        error_report_err(err);
-    }
-    if (chr && qemu_opt_get_bool(opts, "mux", 0)) {
-        qemu_chr_fe_claim_no_fail(chr);
-        monitor_init(chr, MONITOR_USE_READLINE);
-    }
-    return chr;
-}
-
-CharDriverState *qemu_chr_new(const char *label, const char *filename, void (*init)(struct CharDriverState *s))
-{
-    CharDriverState *chr;
-    chr = qemu_chr_new_noreplay(label, filename, init);
-    if (chr) {
-        chr->replay = replay_mode != REPLAY_MODE_NONE;
-        if (chr->replay && chr->chr_ioctl) {
-            fprintf(stderr,
-                    "Replay: ioctl is not supported for serial devices yet\n");
-        }
-        replay_register_char_driver(chr);
-    }
-    return chr;
-}
-
-void qemu_chr_fe_set_echo(struct CharDriverState *chr, bool echo)
-{
-    if (chr->chr_set_echo) {
-        chr->chr_set_echo(chr, echo);
-    }
-}
-
-void qemu_chr_fe_set_open(struct CharDriverState *chr, int fe_open)
-{
-    if (chr->fe_open == fe_open) {
-        return;
-    }
-    chr->fe_open = fe_open;
-    if (chr->chr_set_fe_open) {
-        chr->chr_set_fe_open(chr, fe_open);
-    }
-}
-
-void qemu_chr_fe_event(struct CharDriverState *chr, int event)
-{
-    if (chr->chr_fe_event) {
-        chr->chr_fe_event(chr, event);
-    }
-}
-
-guint qemu_chr_fe_add_watch(CharDriverState *s, GIOCondition cond,
-                            GIOFunc func, void *user_data)
-{
-    GSource *src;
-    guint tag;
-
-    if (s->chr_add_watch == NULL) {
-        return 0;
-    }
-
-    src = s->chr_add_watch(s, cond);
-    if (!src) {
-        return 0;
-    }
-
-    g_source_set_callback(src, (GSourceFunc)func, user_data, NULL);
-    tag = g_source_attach(src, NULL);
-    g_source_unref(src);
-
-    return tag;
-}
-
-int qemu_chr_fe_claim(CharDriverState *s)
-{
-    if (s->avail_connections < 1) {
-        return -1;
-    }
-    s->avail_connections--;
-    return 0;
-}
-
-void qemu_chr_fe_claim_no_fail(CharDriverState *s)
-{
-    if (qemu_chr_fe_claim(s) != 0) {
-        fprintf(stderr, "%s: error chardev \"%s\" already used\n",
-                __func__, s->label);
-        exit(1);
-    }
-}
-
-void qemu_chr_fe_release(CharDriverState *s)
-{
-    s->avail_connections++;
-}
-
-void qemu_chr_disconnect(CharDriverState *chr)
-{
-    if (chr->chr_disconnect) {
-        chr->chr_disconnect(chr);
-    }
-}
-
-static void qemu_chr_free_common(CharDriverState *chr)
-{
-    g_free(chr->filename);
-    g_free(chr->label);
-    qemu_opts_del(chr->opts);
-    if (chr->logfd != -1) {
-        close(chr->logfd);
-    }
-    qemu_mutex_destroy(&chr->chr_write_lock);
-    g_free(chr);
-}
-
-void qemu_chr_free(CharDriverState *chr)
-{
-    if (chr->chr_close) {
-        chr->chr_close(chr);
-    }
-    qemu_chr_free_common(chr);
-}
-
-void qemu_chr_delete(CharDriverState *chr)
-{
-    QTAILQ_REMOVE(&chardevs, chr, next);
-    qemu_chr_free(chr);
-}
-
-ChardevInfoList *qmp_query_chardev(Error **errp)
-{
-    ChardevInfoList *chr_list = NULL;
-    CharDriverState *chr;
-
-    QTAILQ_FOREACH(chr, &chardevs, next) {
-        ChardevInfoList *info = g_malloc0(sizeof(*info));
-        info->value = g_malloc0(sizeof(*info->value));
-        info->value->label = g_strdup(chr->label);
-        info->value->filename = g_strdup(chr->filename);
-        info->value->frontend_open = chr->fe_open;
-
-        info->next = chr_list;
-        chr_list = info;
-    }
-
-    return chr_list;
-}
-
-ChardevBackendInfoList *qmp_query_chardev_backends(Error **errp)
-{
-    ChardevBackendInfoList *backend_list = NULL;
-    CharDriver *c = NULL;
-    GSList *i = NULL;
-
-    for (i = backends; i; i = i->next) {
-        ChardevBackendInfoList *info = g_malloc0(sizeof(*info));
-        c = i->data;
-        info->value = g_malloc0(sizeof(*info->value));
-        info->value->name = g_strdup(c->name);
-
-        info->next = backend_list;
-        backend_list = info;
-    }
-
-    return backend_list;
-}
-
-CharDriverState *qemu_chr_find(const char *name)
-{
-    CharDriverState *chr;
-
-    QTAILQ_FOREACH(chr, &chardevs, next) {
-        if (strcmp(chr->label, name) != 0)
-            continue;
-        return chr;
-    }
-    return NULL;
-}
-
-QemuOptsList qemu_chardev_opts = {
-    .name = "chardev",
-    .implied_opt_name = "backend",
-    .head = QTAILQ_HEAD_INITIALIZER(qemu_chardev_opts.head),
-    .desc = {
-        {
-            .name = "backend",
-            .type = QEMU_OPT_STRING,
-        },{
-            .name = "path",
-            .type = QEMU_OPT_STRING,
-        },{
-            .name = "host",
-            .type = QEMU_OPT_STRING,
-        },{
-            .name = "port",
-            .type = QEMU_OPT_STRING,
-        },{
-            .name = "localaddr",
-            .type = QEMU_OPT_STRING,
-        },{
-            .name = "localport",
-            .type = QEMU_OPT_STRING,
-        },{
-            .name = "to",
-            .type = QEMU_OPT_NUMBER,
-        },{
-            .name = "ipv4",
-            .type = QEMU_OPT_BOOL,
-        },{
-            .name = "ipv6",
-            .type = QEMU_OPT_BOOL,
-        },{
-            .name = "wait",
-            .type = QEMU_OPT_BOOL,
-        },{
-            .name = "server",
-            .type = QEMU_OPT_BOOL,
-        },{
-            .name = "delay",
-            .type = QEMU_OPT_BOOL,
-        },{
-            .name = "reconnect",
-            .type = QEMU_OPT_NUMBER,
-        },{
-            .name = "telnet",
-            .type = QEMU_OPT_BOOL,
-        },{
-            .name = "tls-creds",
-            .type = QEMU_OPT_STRING,
-        },{
-            .name = "width",
-            .type = QEMU_OPT_NUMBER,
-        },{
-            .name = "height",
-            .type = QEMU_OPT_NUMBER,
-        },{
-            .name = "cols",
-            .type = QEMU_OPT_NUMBER,
-        },{
-            .name = "rows",
-            .type = QEMU_OPT_NUMBER,
-        },{
-            .name = "mux",
-            .type = QEMU_OPT_BOOL,
-        },{
-            .name = "signal",
-            .type = QEMU_OPT_BOOL,
-        },{
-            .name = "name",
-            .type = QEMU_OPT_STRING,
-        },{
-            .name = "debug",
-            .type = QEMU_OPT_NUMBER,
-        },{
-            .name = "size",
-            .type = QEMU_OPT_SIZE,
-        },{
-            .name = "chardev",
-            .type = QEMU_OPT_STRING,
-        },{
-            .name = "append",
-            .type = QEMU_OPT_BOOL,
-        },{
-            .name = "logfile",
-            .type = QEMU_OPT_STRING,
-        },{
-            .name = "logappend",
-            .type = QEMU_OPT_BOOL,
-        },
-        { /* end of list */ }
-    },
-};
-
-#ifdef _WIN32
-
-static CharDriverState *qmp_chardev_open_file(const char *id,
-                                              ChardevBackend *backend,
-                                              ChardevReturn *ret,
-                                              Error **errp)
-{
-    ChardevFile *file = backend->u.file.data;
-    ChardevCommon *common = qapi_ChardevFile_base(file);
-    HANDLE out;
-    DWORD accessmode;
-    DWORD flags;
-
-    if (file->has_in) {
-        error_setg(errp, "input file not supported");
-        return NULL;
-    }
-
-    if (file->has_append && file->append) {
-        /* Append to file if it already exists. */
-        accessmode = FILE_GENERIC_WRITE & ~FILE_WRITE_DATA;
-        flags = OPEN_ALWAYS;
-    } else {
-        /* Truncate file if it already exists. */
-        accessmode = GENERIC_WRITE;
-        flags = CREATE_ALWAYS;
-    }
-
-    out = CreateFile(file->out, accessmode, FILE_SHARE_READ, NULL, flags,
-                     FILE_ATTRIBUTE_NORMAL, NULL);
-    if (out == INVALID_HANDLE_VALUE) {
-        error_setg(errp, "open %s failed", file->out);
-        return NULL;
-    }
-    return qemu_chr_open_win_file(out, common, errp);
-}
-
-static CharDriverState *qmp_chardev_open_serial(const char *id,
-                                                ChardevBackend *backend,
-                                                ChardevReturn *ret,
-                                                Error **errp)
-{
-    ChardevHostdev *serial = backend->u.serial.data;
-    ChardevCommon *common = qapi_ChardevHostdev_base(serial);
-    return qemu_chr_open_win_path(serial->device, common, errp);
-}
-
-#else /* WIN32 */
-
-static int qmp_chardev_open_file_source(char *src, int flags,
-                                        Error **errp)
-{
-    int fd = -1;
-
-    TFR(fd = qemu_open(src, flags, 0666));
-    if (fd == -1) {
-        error_setg_file_open(errp, errno, src);
-    }
-    return fd;
-}
-
-static CharDriverState *qmp_chardev_open_file(const char *id,
-                                              ChardevBackend *backend,
-                                              ChardevReturn *ret,
-                                              Error **errp)
-{
-    ChardevFile *file = backend->u.file.data;
-    ChardevCommon *common = qapi_ChardevFile_base(file);
-    int flags, in = -1, out;
-
-    flags = O_WRONLY | O_CREAT | O_BINARY;
-    if (file->has_append && file->append) {
-        flags |= O_APPEND;
-    } else {
-        flags |= O_TRUNC;
-    }
-
-    out = qmp_chardev_open_file_source(file->out, flags, errp);
-    if (out < 0) {
-        return NULL;
-    }
-
-    if (file->has_in) {
-        flags = O_RDONLY;
-        in = qmp_chardev_open_file_source(file->in, flags, errp);
-        if (in < 0) {
-            qemu_close(out);
-            return NULL;
-        }
-    }
-
-    return qemu_chr_open_fd(in, out, common, errp);
-}
-
-#ifdef HAVE_CHARDEV_SERIAL
-static CharDriverState *qmp_chardev_open_serial(const char *id,
-                                                ChardevBackend *backend,
-                                                ChardevReturn *ret,
-                                                Error **errp)
-{
-    ChardevHostdev *serial = backend->u.serial.data;
-    ChardevCommon *common = qapi_ChardevHostdev_base(serial);
-    int fd;
-
-    fd = qmp_chardev_open_file_source(serial->device, O_RDWR, errp);
-    if (fd < 0) {
-        return NULL;
-    }
-    qemu_set_nonblock(fd);
-    return qemu_chr_open_tty_fd(fd, common, errp);
-}
-#endif
-
-#ifdef HAVE_CHARDEV_PARPORT
-static CharDriverState *qmp_chardev_open_parallel(const char *id,
-                                                  ChardevBackend *backend,
-                                                  ChardevReturn *ret,
-                                                  Error **errp)
-{
-    ChardevHostdev *parallel = backend->u.parallel.data;
-    ChardevCommon *common = qapi_ChardevHostdev_base(parallel);
-    int fd;
-
-    fd = qmp_chardev_open_file_source(parallel->device, O_RDWR, errp);
-    if (fd < 0) {
-        return NULL;
-    }
-    return qemu_chr_open_pp_fd(fd, common, errp);
-}
-#endif
-
-#endif /* WIN32 */
-
-static gboolean socket_reconnect_timeout(gpointer opaque)
-{
-    CharDriverState *chr = opaque;
-    TCPCharDriver *s = chr->opaque;
-    QIOChannelSocket *sioc;
-
-    s->reconnect_timer = 0;
-
-    if (chr->be_open) {
-        return false;
-    }
-
-    sioc = qio_channel_socket_new();
-    qio_channel_socket_connect_async(sioc, s->addr,
-                                     qemu_chr_socket_connected,
-                                     chr, NULL);
-
-    return false;
-}
-
-static CharDriverState *qmp_chardev_open_socket(const char *id,
-                                                ChardevBackend *backend,
-                                                ChardevReturn *ret,
-                                                Error **errp)
-{
-    CharDriverState *chr;
-    TCPCharDriver *s;
-    ChardevSocket *sock = backend->u.socket.data;
-    SocketAddress *addr = sock->addr;
-    bool do_nodelay     = sock->has_nodelay ? sock->nodelay : false;
-    bool is_listen      = sock->has_server  ? sock->server  : true;
-    bool is_telnet      = sock->has_telnet  ? sock->telnet  : false;
-    bool is_waitconnect = sock->has_wait    ? sock->wait    : false;
-    int64_t reconnect   = sock->has_reconnect ? sock->reconnect : 0;
-    ChardevCommon *common = qapi_ChardevSocket_base(sock);
-    QIOChannelSocket *sioc = NULL;
-
-    chr = qemu_chr_alloc(common, errp);
-    if (!chr) {
-        return NULL;
-    }
-    s = g_new0(TCPCharDriver, 1);
-
-    s->is_unix = addr->type == SOCKET_ADDRESS_KIND_UNIX;
-    s->is_listen = is_listen;
-    s->is_telnet = is_telnet;
-    s->do_nodelay = do_nodelay;
-    if (sock->tls_creds) {
-        Object *creds;
-        creds = object_resolve_path_component(
-            object_get_objects_root(), sock->tls_creds);
-        if (!creds) {
-            error_setg(errp, "No TLS credentials with id '%s'",
-                       sock->tls_creds);
-            goto error;
-        }
-        s->tls_creds = (QCryptoTLSCreds *)
-            object_dynamic_cast(creds,
-                                TYPE_QCRYPTO_TLS_CREDS);
-        if (!s->tls_creds) {
-            error_setg(errp, "Object with id '%s' is not TLS credentials",
-                       sock->tls_creds);
-            goto error;
-        }
-        object_ref(OBJECT(s->tls_creds));
-        if (is_listen) {
-            if (s->tls_creds->endpoint != QCRYPTO_TLS_CREDS_ENDPOINT_SERVER) {
-                error_setg(errp, "%s",
-                           "Expected TLS credentials for server endpoint");
-                goto error;
-            }
-        } else {
-            if (s->tls_creds->endpoint != QCRYPTO_TLS_CREDS_ENDPOINT_CLIENT) {
-                error_setg(errp, "%s",
-                           "Expected TLS credentials for client endpoint");
-                goto error;
-            }
-        }
-    }
-
-    s->addr = QAPI_CLONE(SocketAddress, sock->addr);
-
-    chr->opaque = s;
-    chr->chr_wait_connected = tcp_chr_wait_connected;
-    chr->chr_write = tcp_chr_write;
-    chr->chr_sync_read = tcp_chr_sync_read;
-    chr->chr_close = tcp_chr_close;
-    chr->chr_disconnect = tcp_chr_disconnect;
-    chr->get_msgfds = tcp_get_msgfds;
-    chr->set_msgfds = tcp_set_msgfds;
-    chr->chr_add_client = tcp_chr_add_client;
-    chr->chr_add_watch = tcp_chr_add_watch;
-    chr->chr_update_read_handler = tcp_chr_update_read_handler;
-    /* be isn't opened until we get a connection */
-    chr->explicit_be_open = true;
-
-    chr->filename = SocketAddress_to_str("disconnected:",
-                                         addr, is_listen, is_telnet);
-
-    if (is_listen) {
-        if (is_telnet) {
-            s->do_telnetopt = 1;
-        }
-    } else if (reconnect > 0) {
-        s->reconnect_time = reconnect;
-    }
-
-    if (s->reconnect_time) {
-        sioc = qio_channel_socket_new();
-        qio_channel_socket_connect_async(sioc, s->addr,
-                                         qemu_chr_socket_connected,
-                                         chr, NULL);
-    } else {
-        if (s->is_listen) {
-            sioc = qio_channel_socket_new();
-            if (qio_channel_socket_listen_sync(sioc, s->addr, errp) < 0) {
-                goto error;
-            }
-            s->listen_ioc = sioc;
-            if (is_waitconnect &&
-                qemu_chr_wait_connected(chr, errp) < 0) {
-                goto error;
-            }
-            if (!s->ioc) {
-                s->listen_tag = qio_channel_add_watch(
-                    QIO_CHANNEL(s->listen_ioc), G_IO_IN,
-                    tcp_chr_accept, chr, NULL);
-            }
-        } else if (qemu_chr_wait_connected(chr, errp) < 0) {
-            goto error;
-        }
-    }
-
-    return chr;
-
- error:
-    if (sioc) {
-        object_unref(OBJECT(sioc));
-    }
-    if (s->tls_creds) {
-        object_unref(OBJECT(s->tls_creds));
-    }
-    g_free(s);
-    qemu_chr_free_common(chr);
-    return NULL;
-}
-
-static CharDriverState *qmp_chardev_open_udp(const char *id,
-                                             ChardevBackend *backend,
-                                             ChardevReturn *ret,
-                                             Error **errp)
-{
-    ChardevUdp *udp = backend->u.udp.data;
-    ChardevCommon *common = qapi_ChardevUdp_base(udp);
-    QIOChannelSocket *sioc = qio_channel_socket_new();
-
-    if (qio_channel_socket_dgram_sync(sioc,
-                                      udp->local, udp->remote,
-                                      errp) < 0) {
-        object_unref(OBJECT(sioc));
-        return NULL;
-    }
-    return qemu_chr_open_udp(sioc, common, errp);
-}
-
-ChardevReturn *qmp_chardev_add(const char *id, ChardevBackend *backend,
-                               Error **errp)
-{
-    ChardevReturn *ret = g_new0(ChardevReturn, 1);
-    CharDriverState *chr = NULL;
-    Error *local_err = NULL;
-    GSList *i;
-    CharDriver *cd;
-
-    chr = qemu_chr_find(id);
-    if (chr) {
-        error_setg(errp, "Chardev '%s' already exists", id);
-        g_free(ret);
-        return NULL;
-    }
-
-    for (i = backends; i; i = i->next) {
-        cd = i->data;
-
-        if (cd->kind == backend->type) {
-            chr = cd->create(id, backend, ret, &local_err);
-            if (local_err) {
-                error_propagate(errp, local_err);
-                goto out_error;
-            }
-            break;
-        }
-    }
-
-    if (chr == NULL) {
-        assert(!i);
-        error_setg(errp, "chardev backend not available");
-        goto out_error;
-    }
-
-    chr->label = g_strdup(id);
-    chr->avail_connections =
-        (backend->type == CHARDEV_BACKEND_KIND_MUX) ? MAX_MUX : 1;
-    if (!chr->filename) {
-        chr->filename = g_strdup(ChardevBackendKind_lookup[backend->type]);
-    }
-    if (!chr->explicit_be_open) {
-        qemu_chr_be_event(chr, CHR_EVENT_OPENED);
-    }
-    QTAILQ_INSERT_TAIL(&chardevs, chr, next);
-    return ret;
-
-out_error:
-    g_free(ret);
-    return NULL;
-}
-
-void qmp_chardev_remove(const char *id, Error **errp)
-{
-    CharDriverState *chr;
-
-    chr = qemu_chr_find(id);
-    if (chr == NULL) {
-        error_setg(errp, "Chardev '%s' not found", id);
-        return;
-    }
-    if (chr->chr_can_read || chr->chr_read ||
-        chr->chr_event || chr->handler_opaque) {
-        error_setg(errp, "Chardev '%s' is busy", id);
-        return;
-    }
-    if (chr->replay) {
-        error_setg(errp,
-            "Chardev '%s' cannot be unplugged in record/replay mode", id);
-        return;
-    }
-    qemu_chr_delete(chr);
-}
-
-void qemu_chr_cleanup(void)
-{
-    CharDriverState *chr, *tmp;
-
-    QTAILQ_FOREACH_SAFE(chr, &chardevs, next, tmp) {
-        qemu_chr_delete(chr);
-    }
-}
-
-static void register_types(void)
-{
-    register_char_driver("null", CHARDEV_BACKEND_KIND_NULL, NULL,
-                         qemu_chr_open_null);
-    register_char_driver("socket", CHARDEV_BACKEND_KIND_SOCKET,
-                         qemu_chr_parse_socket, qmp_chardev_open_socket);
-    register_char_driver("udp", CHARDEV_BACKEND_KIND_UDP, qemu_chr_parse_udp,
-                         qmp_chardev_open_udp);
-    register_char_driver("ringbuf", CHARDEV_BACKEND_KIND_RINGBUF,
-                         qemu_chr_parse_ringbuf, qemu_chr_open_ringbuf);
-    register_char_driver("file", CHARDEV_BACKEND_KIND_FILE,
-                         qemu_chr_parse_file_out, qmp_chardev_open_file);
-    register_char_driver("stdio", CHARDEV_BACKEND_KIND_STDIO,
-                         qemu_chr_parse_stdio, qemu_chr_open_stdio);
-#if defined HAVE_CHARDEV_SERIAL
-    register_char_driver("serial", CHARDEV_BACKEND_KIND_SERIAL,
-                         qemu_chr_parse_serial, qmp_chardev_open_serial);
-    register_char_driver("tty", CHARDEV_BACKEND_KIND_SERIAL,
-                         qemu_chr_parse_serial, qmp_chardev_open_serial);
-#endif
-#ifdef HAVE_CHARDEV_PARPORT
-    register_char_driver("parallel", CHARDEV_BACKEND_KIND_PARALLEL,
-                         qemu_chr_parse_parallel, qmp_chardev_open_parallel);
-    register_char_driver("parport", CHARDEV_BACKEND_KIND_PARALLEL,
-                         qemu_chr_parse_parallel, qmp_chardev_open_parallel);
-#endif
-#ifdef HAVE_CHARDEV_PTY
-    register_char_driver("pty", CHARDEV_BACKEND_KIND_PTY, NULL,
-                         qemu_chr_open_pty);
-#endif
-#ifdef _WIN32
-    register_char_driver("console", CHARDEV_BACKEND_KIND_CONSOLE, NULL,
-                         qemu_chr_open_win_con);
-#endif
-    register_char_driver("pipe", CHARDEV_BACKEND_KIND_PIPE,
-                         qemu_chr_parse_pipe, qemu_chr_open_pipe);
-    register_char_driver("mux", CHARDEV_BACKEND_KIND_MUX, qemu_chr_parse_mux,
-                         qemu_chr_open_mux);
-    /* Bug-compatibility: */
-    register_char_driver("memory", CHARDEV_BACKEND_KIND_MEMORY,
-                         qemu_chr_parse_ringbuf, qemu_chr_open_ringbuf);
-    /* this must be done after machine init, since we register FEs with muxes
-     * as part of realize functions like serial_isa_realizefn when -nographic
-     * is specified
-     */
-    qemu_add_machine_init_done_notifier(&muxes_realize_notify);
-}
-
-type_init(register_types);
diff --git a/target-unicore64/Makefile.objs b/target-unicore64/Makefile.objs
new file mode 100644
index 0000000..6b9e7bb
--- /dev/null
+++ b/target-unicore64/Makefile.objs
@@ -0,0 +1,3 @@
+obj-y += translate.o helper.o cpu.o
+obj-y += ucf64_helper.o
+obj-$(CONFIG_SOFTMMU) +=machine.o softmmu.o
diff --git a/target-unicore64/cpu-qom.h b/target-unicore64/cpu-qom.h
new file mode 100644
index 0000000..59d7860
--- /dev/null
+++ b/target-unicore64/cpu-qom.h
@@ -0,0 +1,52 @@
+/*
+ * QEMU UniCore64 CPU
+ *
+ * Copyright (c) 2012 SUSE LINUX Products GmbH
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation, or (at your option) any
+ * later version. See the COPYING file in the top-level directory.
+ */
+#ifndef QEMU_UC64_CPU_QOM_H
+#define QEMU_UC64_CPU_QOM_H
+
+#include "qom/cpu.h"
+//#include "cpu.h"
+
+#define TYPE_UNICORE64_CPU "unicore64-cpu"
+
+#define UNICORE64_CPU_CLASS(klass) \
+    OBJECT_CLASS_CHECK(UniCore64CPUClass, (klass), TYPE_UNICORE64_CPU)
+#define UNICORE64_CPU(obj) \
+    OBJECT_CHECK(UniCore64CPU, (obj), TYPE_UNICORE64_CPU)
+#define UNICORE64_CPU_GET_CLASS(obj) \
+    OBJECT_GET_CLASS(UniCore64CPUClass, (obj), TYPE_UNICORE64_CPU)
+
+/**
+ * UniCore64CPUClass:
+ *
+ * A UniCore64 CPU model.
+ */
+typedef struct UniCore64CPUClass {
+    /*< private >*/
+    CPUClass parent_class;
+    /*< public >*/
+} UniCore64CPUClass;
+
+/**
+ * UniCore64CPU:
+ * @env: #CPUUniCore64State
+ *
+ * A UniCore64 CPU.
+ */
+/*
+typedef struct UniCore64CPU {
+    CPUState parent_obj;
+
+    CPUUniCore64State env;
+} UniCore64CPU;
+*/
+
+typedef struct UniCore64CPU UniCore64CPU;
+#endif
diff --git a/target-unicore64/cpu.c b/target-unicore64/cpu.c
new file mode 100644
index 0000000..65d8c6b
--- /dev/null
+++ b/target-unicore64/cpu.c
@@ -0,0 +1,92 @@
+/*
+ * QEMU UniCore64 CPU
+ *
+ * Copyright (c) 2012 Guan Xue-tao
+ */
+
+#include "cpu-qom.h"
+#include "qemu-common.h"
+
+/* CPU models */
+
+typedef struct UniCore64CPUInfo {
+    const char *name;
+    void (*instance_init)(Object *obj);
+} UniCore64CPUInfo;
+
+static void uc64_unicore3_cpu_initfn(Object *obj)
+{
+    UniCore64CPU *cpu = UNICORE64_CPU(obj);
+    CPUUniCore64State *env = &cpu->env;
+
+    env->cp0.c0_cpuid = 0x4d110863;
+    env->cp0.c0_cachetype = 0x0519a19a;
+    env->uncached_asr = ASR_MODE_PRIV;
+    env->regs[31] = 0x03000000;
+
+#ifndef CONFIG_USER_ONLY
+    uc64_cp0_intc_init(env);
+    uc64_cp0_itm_init(env);
+#endif
+}
+
+static void uc64_any_cpu_initfn(Object *obj)
+{
+    UniCore64CPU *cpu = UNICORE64_CPU(obj);
+    CPUUniCore64State *env = &cpu->env;
+
+    env->cp0.c0_cpuid = 0xffffffff;
+    env->uncached_asr = ASR_MODE_USER;
+    env->regs[31] = 0;
+}
+
+static const UniCore64CPUInfo uc64_cpus[] = {
+    { .name = "UniCore-III", .instance_init = uc64_unicore3_cpu_initfn },
+    { .name = "any",         .instance_init = uc64_any_cpu_initfn },
+};
+
+static void uc64_cpu_initfn(Object *obj)
+{
+    UniCore64CPU *cpu = UNICORE64_CPU(obj);
+    CPUUniCore64State *env = &cpu->env;
+
+    cpu_exec_init(env);
+    if (env->cpu_index) {
+        env->halted = 1;
+    }
+    env->cpu_model_str = object_get_typename(obj);
+
+    tlb_flush(env, 1);
+}
+
+static void uc64_register_cpu_type(const UniCore64CPUInfo *info)
+{
+    TypeInfo type_info = {
+        .name = info->name,
+        .parent = TYPE_UNICORE64_CPU,
+        .instance_init = info->instance_init,
+    };
+
+    type_register_static(&type_info);
+}
+
+static const TypeInfo uc64_cpu_type_info = {
+    .name = TYPE_UNICORE64_CPU,
+    .parent = TYPE_CPU,
+    .instance_size = sizeof(UniCore64CPU),
+    .instance_init = uc64_cpu_initfn,
+    .abstract = true,
+    .class_size = sizeof(UniCore64CPUClass),
+};
+
+static void uc64_cpu_register_types(void)
+{
+    int i;
+
+    type_register_static(&uc64_cpu_type_info);
+    for (i = 0; i < ARRAY_SIZE(uc64_cpus); i++) {
+        uc64_register_cpu_type(&uc64_cpus[i]);
+    }
+}
+
+type_init(uc64_cpu_register_types)
diff --git a/target-unicore64/cpu.h b/target-unicore64/cpu.h
new file mode 100644
index 0000000..3bec3aa
--- /dev/null
+++ b/target-unicore64/cpu.h
@@ -0,0 +1,238 @@
+/*
+ * UniCore64 virtual CPU header
+ *
+ * Copyright (C) 2012 Guan Xuetao
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation, or (at your option) any
+ * later version. See the COPYING file in the top-level directory.
+ */
+#ifndef QEMU_UNICORE64_CPU_H
+#define QEMU_UNICORE64_CPU_H
+
+#define TARGET_LONG_BITS                64
+#define TARGET_PAGE_BITS                12
+
+#define TARGET_PHYS_ADDR_SPACE_BITS     64
+#define TARGET_VIRT_ADDR_SPACE_BITS     64
+
+#define ELF_MACHINE                     EM_UNICORE64
+
+#define CPUArchState                    struct CPUUniCore64State
+
+#define NB_MMU_MODES                     2
+#define TARGET_HAS_ICE                   1
+
+#include "config.h"
+#include "qemu-common.h"
+#include "cpu-qom.h"
+#include "exec/cpu-defs.h"
+#include "fpu/softfloat.h"
+
+typedef struct CPUUniCore64State {
+    /* Regs for current mode.  */
+    uint64_t regs[32];
+    /* Frequently accessed ASR bits are stored separately for efficiently.
+       This contains all the other bits.  Use asr_{read,write} to access
+       the whole ASR.  */
+    uint64_t uncached_asr;
+    uint64_t uncached_afr;
+    uint64_t bsr;
+    uint64_t bfr;
+
+    /* Banked registers. */
+    uint64_t banked_r29[3];
+    uint64_t banked_r30[3];
+
+    /* AFR cache for faster execution */
+    uint64_t VF; /* V is the bit 31. All other bits are undefined */
+    uint64_t CF; /* 0 or 1 */
+    uint64_t ZF; /* Z set if zero.  */
+    uint64_t NF; /* N is bit 31. All other bits are undefined.  */
+
+    /* Addr for LL-SC */
+    uint64_t llsc_exclusive_addr;
+    /* lock for LL-SC */
+    uint64_t llsc_exclusive_lock;
+    /* value for LL-SC */
+    uint64_t llsc_exclusive_val;
+
+    /* System control coprocessor (cp0) */
+    struct {
+        uint64_t c0_cpuid;
+        uint64_t c0_cachetype;
+        uint64_t c1_sys; /* System control register.  */
+        uint64_t c2_base; /* MMU translation table base.  */
+        uint64_t c3_ifaultstatus; /* Instruction fault status register.  */
+        uint64_t c3_dfaultstatus; /* Data fault status register.  */
+        uint64_t c4_dtrapaddr; /* Fault address registers.  */
+        uint64_t c4_epc; /* Exception address register.*/
+        uint64_t c8_mrar[16]; /* Memory region configuration registers */
+        uint64_t c9_excpbase; /* Exception base register. */
+        uint64_t c10_intrtype; /* Interrupt type register. */
+        uint64_t c10_itimercr; /* Itimer count register. */
+        uint64_t c10_itimermr; /* Itimer match register. */
+        uint64_t c11_rwmargin; /* Read/Write margin control register */
+        uint64_t c12_sysu[8]; /* SysU registers. */
+    } cp0;
+
+    /* UniCore-F64 coprocessor state.  */
+    struct {
+        float64 regs[16];
+        uint64_t fpsr; /* float point status reg */
+        uint64_t fpfr; /* float point flag reg */
+        float_status qemu_fp_status; /* QEMU emulator float status */
+    } ucf64;
+
+    CPU_COMMON
+
+} CPUUniCore64State;
+
+struct UniCore64CPU {
+        CPUState parent_obj;
+        CPUUniCore64State env;
+};
+
+static inline UniCore64CPU *uc64_env_get_cpu(CPUUniCore64State *env)
+{
+        return container_of(env, UniCore64CPU, env);
+}
+#define ENV_GET_CPU(e) CPU(uc64_env_get_cpu(e))
+#define ENV_OFFSET offsetof(UniCore64CPU, env)
+
+
+void uc32_cpu_do_interrupt(CPUState *cpu);
+bool uc32_cpu_exec_interrupt(CPUState *cpu, int int_req);
+void uc32_cpu_dump_state(CPUState *cpu, FILE *f,
+                fprintf_function cpu_fprintf, int flags);
+hwaddr uc32_cpu_get_phys_page_debug(CPUState *cpu, vaddr addr);
+
+#define ASR_IDX_USER            (0)
+#define ASR_IDX_PRIV            (1)
+#define ASR_IDX_DEBUG           (2)
+#define ASR_MODE_SELECT         (ASR_MODE_USER | ASR_MODE_PRIV | ASR_MODE_DEBUG)
+#define ASR_MODE_USER           (1 << ASR_IDX_USER)
+#define ASR_MODE_PRIV           (1 << ASR_IDX_PRIV)
+#define ASR_MODE_DEBUG          (1 << ASR_IDX_DEBUG)
+#define ASR_INTR_SELECT         (0x3f << 5)
+#define AFR_V                   (1 << 0)
+#define AFR_C                   (1 << 1)
+#define AFR_Z                   (1 << 2)
+#define AFR_N                   (1 << 3)
+
+#define AFR_READ(env)   (((env->NF >> 63) << 3) | ((env->ZF == 0) << 2) | \
+                        (env->CF << 1) | (env->VF >> 63))
+
+#define UC64_EXCP_PRIV          0x08
+#define UC64_EXCP_ITRAP         0x0c
+#define UC64_EXCP_DTRAP         0x10
+#define UC64_INTR_IPI           0x18
+#define UC64_INTR_ITIMER        0x20
+#define UC64_INTR_PUV4          0x24
+#define UC64_INTR_OTIMER        0x28
+
+/* Return the current ASR value.  */
+target_ulong cpu_asr_read(CPUUniCore64State *env1);
+/* Set the ASR.  Note that some bits of mask must be all-set or all-clear.  */
+void cpu_asr_write(CPUUniCore64State *env, target_ulong val, target_ulong msk);
+
+
+/* Return the current AFR value.  */
+target_ulong cpu_afr_read(CPUUniCore64State *env1);
+/* Set the AFR.  Note that some bits of mask must be all-set or all-clear.  */
+void cpu_afr_write(CPUUniCore64State *env, target_ulong val, target_ulong msk);
+
+#define cpu_init                        uc64_cpu_init
+//#define cpu_exec                        uc64_cpu_exec
+#define cpu_signal_handler              uc64_cpu_signal_handler
+#define cpu_handle_mmu_fault            uc64_cpu_handle_mmu_fault
+
+/* UniCore64-specific interrupt pending bits. */
+#define CPU_INTERRUPT_ITM    CPU_INTERRUPT_TGT_INT_0
+#define CPU_INTERRUPT_SMP    CPU_INTERRUPT_TGT_INT_1
+#define CPU_INTERRUPT_OTM    CPU_INTERRUPT_TGT_INT_2
+
+CPUUniCore64State *uc64_cpu_init(const char *cpu_model);
+//int uc64_cpu_exec(CPUUniCore64State *s);
+int uc64_cpu_signal_handler(int host_signum, void *pinfo, void *puc);
+int uc64_cpu_handle_mmu_fault(CPUUniCore64State *env, target_ulong address,
+        int rw, int mmu_idx);
+
+void uc64_translate_init(void);
+void switch_mode(CPUUniCore64State *, int);
+
+//#define CPU_SAVE_VERSION       2
+
+/* MMU modes definitions */
+#define MMU_MODE0_SUFFIX       _kernel
+#define MMU_MODE1_SUFFIX       _user
+#define MMU_USER_IDX           1
+
+static inline int cpu_mmu_index(CPUUniCore64State *env, bool ifetch)
+{
+    return (env->uncached_asr & ASR_MODE_SELECT) == ASR_MODE_USER ? 1 : 0;
+}
+/*
+static inline void cpu_clone_regs(CPUUniCore64State *env, target_ulong newsp)
+{
+    if (newsp) {
+        env->regs[29] = newsp;
+    }
+    env->regs[0] = 0;
+}
+
+static inline void cpu_set_tls(CPUUniCore64State *env, target_ulong newtls)
+{
+    abort();
+}
+*/
+#include "exec/cpu-all.h"
+#include "cpu-qom.h"
+//#include "exec/exec-all.h"
+/*
+static inline void cpu_pc_from_tb(CPUUniCore64State *env, TranslationBlock *tb)
+{
+    env->regs[31] = tb->pc;
+}
+*/
+static inline void cpu_get_tb_cpu_state(CPUUniCore64State *env,
+        target_ulong *pc, target_ulong *cs_base, int *flags)
+{
+    *pc = env->regs[31];
+    *cs_base = 0;
+    *flags = 0;
+    if ((env->uncached_asr & ASR_MODE_SELECT) != ASR_MODE_USER) {
+        *flags |= (1 << 6);
+    }
+}
+/*
+static inline bool cpu_has_work(CPUState *cpu)
+{
+    return cpu->interrupt_request & (CPU_INTERRUPT_HARD
+                                   | CPU_INTERRUPT_SMP
+                                   | CPU_INTERRUPT_EXITTB);
+}
+*/
+/* Hardware interrupts */
+#define UC64_INTR_NUM           (7)
+#define UC64_INTR_SMP           (0)
+#define UC64_INTR_LSU           (1)
+#define UC64_INTR_ITM           (2)
+#define UC64_INTR_OTM           (3)
+#define UC64_INTR_DEV           (4)
+#define UC64_INTR_PFM           (5)
+
+extern uint32_t share_io_reg;   /* Fake share IO reg */
+
+/* cp0_itm.c */
+void uc64_cp0_itm_init(CPUUniCore64State *env);
+uint64_t uc64_cp0_itimer_get_delta(int);
+void uc64_cp0_itimer_set_count(int, uint64_t value);
+
+/* cp0_intc.c */
+void uc64_cp0_intc_init(CPUUniCore64State *env);
+void uc64_cp0_intc_irq_lower(CPUUniCore64State *env, int);
+void uc64_cp0_intc_irq_raise(CPUUniCore64State *env, int);
+
+#endif /* QEMU_UNICORE64_CPU_H */
diff --git a/target-unicore64/helper.c b/target-unicore64/helper.c
new file mode 100644
index 0000000..4f365a2
--- /dev/null
+++ b/target-unicore64/helper.c
@@ -0,0 +1,515 @@
+/*
+ * Copyright (C) 2012 Guan Xuetao
+ */
+
+#include "cpu.h"
+#include "dyngen-exec.h"
+#include "gdbstub.h"
+#include "helper.h"
+#include "host-utils.h"
+#include "console.h"
+#include "trace.h"
+
+#define DEBUG_UC64
+
+#ifdef DEBUG_UC64
+#define DPRINTF(fmt, ...) printf("\t\t(qemu)%s: " fmt , __func__, ## __VA_ARGS__)
+#else
+#define DPRINTF(fmt, ...) do {} while (0)
+#endif
+
+CPUUniCore64State *uc64_cpu_init(const char *cpu_model)
+{
+    UniCore64CPU *cpu;
+    CPUUniCore64State *env;
+    static int inited = 1;
+
+    if (object_class_by_name(cpu_model) == NULL) {
+        return NULL;
+    }
+    cpu = UNICORE64_CPU(object_new(cpu_model));
+    env = &cpu->env;
+
+    if (inited) {
+        inited = 0;
+        uc64_translate_init();
+    }
+
+    qemu_init_vcpu(env);
+    return env;
+}
+
+#if !defined(CONFIG_USER_ONLY) && defined(CONFIG_CURSES)
+/*
+ * FIXME:
+ *     1. curses windows will be blank when switching back
+ *     2. backspace is not handled yet
+ */
+static void putc_on_screen(unsigned char ch)
+{
+    static WINDOW *localwin;
+    static int init;
+    static char buf[256];
+    static char *p;
+
+    if (!init) {
+        /* Assume 80 * 30 screen to minimize the implementation */
+        localwin = newwin(30, 80, 0, 0);
+        scrollok(localwin, TRUE);
+        init = TRUE;
+        p = buf;
+    }
+
+    if (isprint(ch)) {
+        wprintw(localwin, "%c", ch);
+        *p++ = ch;
+    } else {
+        switch (ch) {
+        case '\n':
+            wprintw(localwin, "\n", ch);
+            *p++ = '\0';
+            trace_uc64_guestos_output(buf);
+            p = buf;
+            break;
+        case '\r':
+            /* If '\r' is put before '\n', the curses window will destroy the
+             * last print line. And meanwhile, '\n' implifies '\r' inside. */
+            break;
+        case '\t':
+            wprintw(localwin, "%c", ch);
+            *p++ = ch;
+            break;
+        default: /* Not handled, so just print it hex code */
+            wprintw(localwin, "-- 0x%x --", ch);
+        }
+    }
+
+    wrefresh(localwin);
+}
+#else
+#define putc_on_screen(c)               do { } while (0)
+#endif
+
+void helper_ocd_output(void)
+{
+    if (env->cp0.c12_sysu[6]) { /* 1 */
+        /* Output to screen */
+        putc_on_screen((unsigned char)env->cp0.c12_sysu[7]);
+    } else { /* 0 */
+        printf("\n--%16" PRIx64 "--", env->cp0.c12_sysu[7]);
+        trace_uc64_guestos_output2(env->cp0.c12_sysu[7]);
+    }
+    fflush(NULL);
+}
+
+void helper_cp1_putc(target_ulong x)
+{
+    printf("%c", (unsigned char)x); /* Output to stdout */
+    fflush(NULL);
+}
+
+void helper_cp1_putx(target_ulong x)
+{
+    printf("\n--%16" PRIx64 "--", x); /* Output to stdout */
+    fflush(NULL);
+}
+
+void HELPER(exception)(uint32_t excp)
+{
+    env->exception_index = excp;
+    cpu_loop_exit(env);
+}
+
+void helper_halt(uint32_t tmp)
+{
+    env->interrupt_request |= tmp;
+    cpu_loop_exit(env);
+}
+
+void HELPER(asr_write)(uint64_t x)
+{
+    uint64_t mod = x & ASR_MODE_SELECT;
+    if (env->uncached_asr ^ mod) {
+        switch_mode(env, mod);
+    }
+    env->uncached_asr = x & 0x7ff;
+}
+
+void HELPER(afr_write)(uint64_t x)
+{
+    env->NF = x << 60;
+    env->ZF = (~x) & AFR_Z;
+    env->CF = (x & AFR_C) >> 1;
+    env->VF = x << 63;
+}
+
+uint64_t HELPER(afr_read)(void)
+{
+    return AFR_READ(env);
+}
+
+target_ulong cpu_afr_read(CPUUniCore64State *env1)
+{
+    CPUUniCore64State *saved_env;
+    target_ulong ret;
+
+    saved_env = env;
+    env = env1;
+    ret = AFR_READ(env1);
+    env = saved_env;
+    return ret;
+}
+
+uint64_t HELPER(asr_read)(void)
+{
+    return env->uncached_asr;
+}
+
+uint32_t HELPER(clo_i32)(uint32_t x)
+{
+        return clo32(x);
+}
+
+uint64_t HELPER(clo_i64)(uint64_t x)
+{
+        return clo64(x);
+}
+
+uint32_t HELPER(clz_i32)(uint32_t x)
+{
+        return clz32(x);
+}
+
+uint64_t HELPER(clz_i64)(uint64_t x)
+{
+        return clz64(x);
+}
+
+/*
+ * Flag setting arithmetic is awkward because we need to do comparisons.
+ * The only way to do that in TCG is a conditional branch, which clobbers
+ * all our temporaries.  For now implement these as helper functions.
+ */
+uint32_t HELPER(sub_cc_i32)(uint32_t a, uint32_t b)
+{
+    uint32_t result;
+    result = a - b;
+    env->NF = env->ZF = (int32_t)result;
+    env->CF = a >= b;
+    env->VF = (int32_t)((a ^ b) & (a ^ result));
+    return result;
+}
+
+uint64_t HELPER(sub_cc_i64)(uint64_t a, uint64_t b)
+{
+    uint64_t result;
+    result = a - b;
+    env->NF = env->ZF = result;
+    env->CF = a >= b;
+    env->VF = ((a ^ b) & (a ^ result));
+    return result;
+}
+
+uint32_t HELPER(add_cc_i32)(uint32_t a, uint32_t b)
+{
+    uint32_t result;
+    result = a + b;
+    env->NF = env->ZF = (int32_t)result;
+    env->CF = result < a;
+    env->VF = (int32_t)((a ^ b ^ -1) & (a ^ result));
+    return result;
+}
+
+uint64_t HELPER(add_cc_i64)(uint64_t a, uint64_t b)
+{
+    uint64_t result;
+    result = a + b;
+    env->NF = env->ZF = result;
+    env->CF = result < a;
+    env->VF = (a ^ b ^ -1) & (a ^ result);
+    return result;
+}
+
+uint32_t HELPER(sbc_cc_i32)(uint32_t a, uint32_t b)
+{
+    uint32_t result;
+    if (!env->CF) {
+        result = a - b - 1;
+        env->CF = a > b;
+    } else {
+        result = a - b;
+        env->CF = a >= b;
+    }
+    env->VF = (int32_t)((a ^ b) & (a ^ result));
+    env->NF = env->ZF = (int32_t)result;
+    return result;
+}
+
+uint64_t HELPER(sbc_cc_i64)(uint64_t a, uint64_t b)
+{
+    uint64_t result;
+    if (!env->CF) {
+        result = a - b - 1;
+        env->CF = a > b;
+    } else {
+        result = a - b;
+        env->CF = a >= b;
+    }
+    env->VF = ((a ^ b) & (a ^ result));
+    env->NF = env->ZF = result;
+    return result;
+}
+
+uint32_t HELPER(adc_cc_i32)(uint32_t a, uint32_t b)
+{
+    uint32_t result;
+    if (!env->CF) {
+        result = a + b;
+        env->CF = result < a;
+    } else {
+        result = a + b + 1;
+        env->CF = result <= a;
+    }
+    env->VF = (int32_t)((a ^ b ^ -1) & (a ^ result));
+    env->NF = env->ZF = (int32_t)result;
+    return result;
+}
+
+uint64_t HELPER(adc_cc_i64)(uint64_t a, uint64_t b)
+{
+    uint64_t result;
+    if (!env->CF) {
+        result = a + b;
+        env->CF = result < a;
+    } else {
+        result = a + b + 1;
+        env->CF = result <= a;
+    }
+    env->VF = ((a ^ b ^ -1) & (a ^ result));
+    env->NF = env->ZF = result;
+    return result;
+}
+
+uint64_t helper_cp0_get(CPUUniCore64State *env, uint64_t creg,
+        uint64_t cop)
+{
+#ifdef CONFIG_USER_ONLY
+    cpu_abort(env, "NO priviledged instructions in user mode\n");
+#endif
+    switch (creg) {
+    case 0:
+        switch (cop) {
+        case 0:
+            return env->cp0.c0_cpuid;
+        case 1:
+            return env->cp0.c0_cachetype;
+        }
+        break;
+    case 1:
+        switch (cop) {
+        case 0:
+            return env->cp0.c1_sys;
+        }
+        break;
+    case 2:
+        switch (cop) {
+        case 0:
+            return env->cp0.c2_base;
+        }
+        break;
+    case 3:
+        switch (cop) {
+        case 0:
+            return env->cp0.c3_ifaultstatus;
+        case 1:
+            return env->cp0.c3_dfaultstatus;
+        }
+        break;
+    case 4:
+        switch (cop) {
+        case 0:
+            return env->cp0.c4_dtrapaddr;
+        case 1:
+            return env->cp0.c4_epc;
+        }
+        break;
+    case 8:
+        if (cop < 16) {
+            return env->cp0.c8_mrar[cop];
+        }
+        break;
+    case 9:
+        switch (cop) {
+        case 0:
+            return env->cp0.c9_excpbase;
+        }
+        break;
+    case 10:
+        switch (cop) {
+        case 0: /* Interrupt type */
+            return env->cp0.c10_intrtype;
+        case 9: /* Counter Register */
+            return env->cp0.c10_itimermr -
+                uc64_cp0_itimer_get_delta(env->cpu_index);
+        }
+        break;
+    case 11:
+        switch (cop) {
+        case 0:
+            return env->cp0.c11_rwmargin;
+        }
+        break;
+    case 12:
+        if (cop < 8) {
+            return env->cp0.c12_sysu[cop];
+        }
+        break;
+    }
+    DPRINTF("Wrong register (%" PRIx64 ") or wrong operation (%" PRIx64
+            ") in %s!\n", creg, cop, __func__);
+    return 0;
+}
+
+void helper_cp0_set(CPUUniCore64State *env, uint64_t val, uint64_t creg,
+        uint64_t cop)
+{
+#ifdef CONFIG_USER_ONLY
+    cpu_abort(env, "NO priviledged instructions in user mode\n");
+#endif
+    CPUUniCore64State *ipi_env = NULL;
+    switch (creg) {
+    case 1:
+        if (cop != 0) {
+            goto unrecognized;
+        }
+        env->cp0.c1_sys = val;
+        break;
+    case 2:
+        if (cop != 0) {
+            goto unrecognized;
+        }
+        env->cp0.c2_base = val;
+        break;
+    case 4:
+        switch (cop) {
+        case 0:
+            env->cp0.c4_dtrapaddr = val;
+            break;
+        case 1:
+            env->cp0.c4_epc = val;
+            break;
+        default:
+            goto unrecognized;
+        }
+        break;
+    case 5:
+        tlb_flush(env, 1);
+        switch (cop) {
+        case 0xc:
+            trace_uc64_mmu_tlb_ops("Invalidate DTLB single entry by VA\n");
+            return;
+        case 0x14:
+            trace_uc64_mmu_tlb_ops("Invalidate ITLB single entry by VA\n");
+            return;
+        case 0x18:
+            trace_uc64_mmu_tlb_ops("Invalidate I&D TLB\n");
+            return;
+        default:
+            goto unrecognized;
+        }
+        break;
+    case 6:
+        switch (cop) {
+        case 0x8:
+            trace_uc64_mmu_cache_ops("Invalidate Entire L1 DCache\n");
+            return;
+        case 0xc:
+            trace_uc64_mmu_cache_ops("Flush Entire L1 DCache\n");
+            return;
+        default:
+            goto unrecognized;
+        }
+        break;
+    case 7:
+        switch (cop) {
+        case 0:
+            trace_uc64_mmu_cache_ops("Invalidate Entire ICache\n");
+            break;
+        default:
+            goto unrecognized;
+        }
+        break;
+    case 9:
+        switch (cop) {
+        case 0:
+            env->cp0.c9_excpbase = val;
+            break;
+        default:
+            goto unrecognized;
+        }
+        break;
+    case 10:
+        switch (cop) {
+        case 0: /* Interrupt type */
+            uc64_cp0_intc_irq_lower(env, val);
+            break;
+        case 3:
+            ipi_env = qemu_get_cpu(0);
+            //ipi_env->cp0.c10_intrtype |= 1<<(env->cpu_index + 9);
+            uc64_cp0_intc_irq_raise(ipi_env, UC64_INTR_SMP);
+            break;
+        case 4:
+            ipi_env = qemu_get_cpu(1);
+            //ipi_env->cp0.c10_intrtype |= 1<<(env->cpu_index + 9);
+            uc64_cp0_intc_irq_raise(ipi_env, UC64_INTR_SMP);
+            break;
+        case 10: /* Match Register */
+            env->cp0.c10_itimermr = val;
+            if (env->cp0.c10_itimermr > env->cp0.c10_itimercr) {
+                uc64_cp0_itimer_set_count(env->cpu_index,
+                        env->cp0.c10_itimermr - env->cp0.c10_itimercr);
+            } else {
+                uc64_cp0_itimer_set_count(env->cpu_index, env->cp0.c10_itimermr
+                        + (0xffffffffffffffffULL - env->cp0.c10_itimercr));
+            }
+            break;
+        default:
+            goto unrecognized;
+        }
+        break;
+    case 12:
+        if (cop < 8) {
+            env->cp0.c12_sysu[cop] = val;
+        } else {
+            goto unrecognized;
+        }
+        break;
+    default:
+        goto unrecognized;
+    }
+    return;
+unrecognized:
+    DPRINTF("Wrong register (%" PRIx64 ") or wrong operation (%" PRIx64
+            ") in %s!\n", creg, cop, __func__);
+}
+
+#ifdef CONFIG_USER_ONLY
+void switch_mode(CPUUniCore64State *env, int mode)
+{
+    if (mode != ASR_MODE_USER) {
+        cpu_abort(env, "Tried to switch out of user mode\n");
+    }
+}
+
+void do_interrupt(CPUUniCore64State *env)
+{
+    cpu_abort(env, "NO interrupt in user mode\n");
+}
+
+int uc64_cpu_handle_mmu_fault(CPUUniCore64State *env, target_ulong address,
+                              int access_type, int mmu_idx)
+{
+    cpu_abort(env, "NO mmu fault in user mode\n");
+    return 1;
+}
+#endif
diff --git a/target-unicore64/helper.h b/target-unicore64/helper.h
new file mode 100644
index 0000000..f3966a6
--- /dev/null
+++ b/target-unicore64/helper.h
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2012 Guan Xuetao
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation, or (at your option) any
+ * later version. See the COPYING file in the top-level directory.
+ */
+
+DEF_HELPER_1(cp1_putc, void, i64)
+DEF_HELPER_1(cp1_putx, void, i64)
+DEF_HELPER_0(ocd_output, void)
+DEF_HELPER_1(halt, void, i32)
+DEF_HELPER_3(cp0_get, i64, env, i64, i64)
+DEF_HELPER_4(cp0_set, void, env, i64, i64, i64)
+
+DEF_HELPER_1(exception, void, i32)
+DEF_HELPER_0(afr_read, i64)
+DEF_HELPER_0(asr_read, i64)
+DEF_HELPER_1(afr_write, void, i64)
+DEF_HELPER_1(asr_write, void, i64)
+DEF_HELPER_1(clz_i32, i32, i32)
+DEF_HELPER_1(clz_i64, i64, i64)
+DEF_HELPER_1(clo_i32, i32, i32)
+DEF_HELPER_1(clo_i64, i64, i64)
+DEF_HELPER_2(sub_cc_i32, i32, i32, i32)
+DEF_HELPER_2(sub_cc_i64, i64, i64, i64)
+DEF_HELPER_2(add_cc_i32, i32, i32, i32)
+DEF_HELPER_2(add_cc_i64, i64, i64, i64)
+DEF_HELPER_2(sbc_cc_i32, i32, i32, i32)
+DEF_HELPER_2(sbc_cc_i64, i64, i64, i64)
+DEF_HELPER_2(adc_cc_i32, i32, i32, i32)
+DEF_HELPER_2(adc_cc_i64, i64, i64, i64)
+
+DEF_HELPER_1(ucf64_get_fpsr, i64, env)
+DEF_HELPER_2(ucf64_set_fpsr, void, env, i64)
+DEF_HELPER_1(ucf64_get_fpfr, i64, env)
+DEF_HELPER_2(ucf64_set_fpfr, void, env, i64)
+
+DEF_HELPER_4(ucf64_movts, f32, f32, f32, i32, env)
+DEF_HELPER_4(ucf64_movtd, f64, f64, f64, i32, env)
+DEF_HELPER_4(ucf64_movtw, f64, f64, f64, i32, env)
+
+DEF_HELPER_3(ucf64_adds, f32, f32, f32, env)
+DEF_HELPER_3(ucf64_addd, f64, f64, f64, env)
+DEF_HELPER_3(ucf64_subs, f32, f32, f32, env)
+DEF_HELPER_3(ucf64_subd, f64, f64, f64, env)
+DEF_HELPER_3(ucf64_muls, f32, f32, f32, env)
+DEF_HELPER_3(ucf64_muld, f64, f64, f64, env)
+DEF_HELPER_3(ucf64_divs, f32, f32, f32, env)
+DEF_HELPER_3(ucf64_divd, f64, f64, f64, env)
+DEF_HELPER_1(ucf64_negs, f32, f32)
+DEF_HELPER_1(ucf64_negd, f64, f64)
+DEF_HELPER_1(ucf64_abss, f32, f32)
+DEF_HELPER_1(ucf64_absd, f64, f64)
+
+DEF_HELPER_2(ucf64_sf2df, f64, f32, env)
+DEF_HELPER_2(ucf64_df2sf, f32, f64, env)
+
+DEF_HELPER_2(ucf64_si2sf, f32, f32, env)
+DEF_HELPER_2(ucf64_si2df, f64, f32, env)
+
+DEF_HELPER_2(ucf64_sf2si, f32, f32, env)
+DEF_HELPER_2(ucf64_df2si, f32, f64, env)
+
+DEF_HELPER_4(ucf64_cmps, void, f32, f32, i32, env)
+DEF_HELPER_4(ucf64_cmpd, void, f64, f64, i32, env)
diff --git a/target-unicore64/machine.c b/target-unicore64/machine.c
new file mode 100644
index 0000000..2553299
--- /dev/null
+++ b/target-unicore64/machine.c
@@ -0,0 +1,23 @@
+/*
+ * Generic machine functions for UniCore64 ISA
+ *
+ * Copyright (C) 2012 Guan Xuetao
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation, or any later version.
+ * See the COPYING file in the top-level directory.
+ */
+#include "hw/hw.h"
+
+void cpu_save(QEMUFile *f, void *opaque)
+{
+    hw_error("%s not supported yet.\n", __func__);
+}
+
+int cpu_load(QEMUFile *f, void *opaque, int version_id)
+{
+    hw_error("%s not supported yet.\n", __func__);
+
+    return 0;
+}
diff --git a/target-unicore64/softmmu.c b/target-unicore64/softmmu.c
new file mode 100644
index 0000000..5dc0ab9
--- /dev/null
+++ b/target-unicore64/softmmu.c
@@ -0,0 +1,322 @@
+/*
+ * Softmmu related functions
+ *
+ * Copyright (C) 2012 Guan Xuetao
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation, or any later version.
+ * See the COPYING file in the top-level directory.
+ */
+#include "cpu.h"
+#include "dyngen-exec.h"
+#include "helper.h"
+#include "trace.h"
+
+#ifdef CONFIG_USER_ONLY
+#error This file only exist under softmmu circumstance
+#endif
+
+#define SUPERPAGE_SIZE             (1 << 20)
+#define UC64_PAGETABLE_READ        (1 << 7)
+#define UC64_PAGETABLE_WRITE       (1 << 6)
+#define UC64_PAGETABLE_EXEC        (1 << 5)
+#define UC64_PAGETABLE_EXIST       (1 << 2)
+#define UC64_PAGETABLE_USER        (1 << 1)
+
+#define MMUSUFFIX _mmu
+
+/* Unaligned data must raise the data-abort in UniCore64 */
+#define ALIGNED_ONLY
+static void do_unaligned_access(target_ulong addr, int is_write,
+                                int is_user, uintptr_t retaddr)
+{
+    TranslationBlock *tb;
+
+    trace_uc64_do_unaligned_access(addr, retaddr);
+
+    env->cp0.c3_dfaultstatus = 0x09;
+    env->cp0.c4_dtrapaddr = addr;
+    env->exception_index = UC64_EXCP_DTRAP;
+
+    if (retaddr) {
+        tb = tb_find_pc(retaddr);
+        if (tb) {
+            cpu_restore_state(tb, env, retaddr);
+        }
+    }
+    cpu_loop_exit(env);
+}
+
+#define SHIFT 0
+#include "softmmu_template.h"
+
+#define SHIFT 1
+#include "softmmu_template.h"
+
+#define SHIFT 2
+#include "softmmu_template.h"
+
+#define SHIFT 3
+#include "softmmu_template.h"
+
+void tlb_fill(CPUUniCore64State *env1, target_ulong addr, int is_write,
+        int mmu_idx, uintptr_t retaddr)
+{
+    TranslationBlock *tb;
+    CPUUniCore64State *saved_env;
+    int ret;
+
+    saved_env = env;
+    env = env1;
+
+    ret = uc64_cpu_handle_mmu_fault(env, addr, is_write, mmu_idx);
+    if (unlikely(ret)) {
+        if (retaddr) {
+            /* now we have a real cpu fault */
+            tb = tb_find_pc(retaddr);
+            if (tb) {
+                /* the PC is inside the translated code.
+                   It means that we have a virtual CPU fault */
+                cpu_restore_state(tb, env, retaddr);
+            }
+        }
+        cpu_loop_exit(env);
+    }
+    env = saved_env;
+}
+
+void switch_mode(CPUUniCore64State *env, int mode)
+{
+    int old_mode_idx;
+    int mode_idx;
+
+    old_mode_idx = ((env->uncached_asr & ASR_MODE_SELECT) == ASR_MODE_PRIV) ?
+                    ASR_IDX_PRIV : ASR_IDX_USER;
+    mode_idx = (mode == ASR_MODE_PRIV) ? ASR_IDX_PRIV : ASR_IDX_USER;
+
+    if (mode_idx != old_mode_idx) {
+        env->banked_r29[old_mode_idx] = env->regs[29];
+        env->banked_r30[old_mode_idx] = env->regs[30];
+        env->regs[29] = env->banked_r29[mode_idx];
+        env->regs[30] = env->banked_r30[mode_idx];
+    }
+}
+
+static void special_ipi_handler(CPUUniCore64State *env)
+{
+    switch_mode(env, ASR_MODE_PRIV);
+    env->bsr = env->uncached_asr;
+    env->bfr = AFR_READ(env);
+    env->uncached_asr = (env->uncached_asr & ~ASR_MODE_SELECT) | ASR_MODE_PRIV;
+    env->uncached_asr |= ASR_INTR_SELECT;
+    /* the PC already points to the proper instruction. */
+    env->cp0.c4_epc = env->regs[31];
+    env->regs[31] = share_io_reg;
+    env->interrupt_request |= CPU_INTERRUPT_EXITTB;
+}
+
+void do_interrupt(CPUUniCore64State *env)
+{
+    static int ipi_flag;
+    switch (env->exception_index) {
+    case UC64_INTR_IPI:
+        {
+            trace_uc64_do_interrupt("IPI", env->uncached_asr);
+            if (ipi_flag) {
+                break;
+            } else {
+                ipi_flag = 1;
+                special_ipi_handler(env);
+                return;
+            }
+        }
+    case UC64_EXCP_ITRAP:
+        trace_uc64_do_interrupt("ITRAP", env->uncached_asr);
+        break;
+    case UC64_EXCP_DTRAP:
+        trace_uc64_do_interrupt("DTRAP", env->uncached_asr);
+        break;
+    case UC64_INTR_ITIMER:
+        trace_uc64_do_interrupt("ITIMER", env->uncached_asr);
+        break;
+    case UC64_INTR_PUV4:
+        trace_uc64_do_interrupt("DEVICE", env->uncached_asr);
+        break;
+    case UC64_EXCP_PRIV:
+        trace_uc64_do_interrupt("SYSCALL", env->uncached_asr);
+        break;
+    case UC64_INTR_OTIMER:
+        trace_uc64_do_interrupt("OTIMER", env->uncached_asr);
+        break;
+    default:
+        cpu_abort(env, "Unhandled exception 0x%x\n", env->exception_index);
+        return;
+    }
+
+    switch_mode(env, ASR_MODE_PRIV);
+    env->bsr = env->uncached_asr;
+    env->bfr = AFR_READ(env);
+    env->uncached_asr = (env->uncached_asr & ~ASR_MODE_SELECT) | ASR_MODE_PRIV;
+    env->uncached_asr |= ASR_INTR_SELECT;
+    /* the PC already points to the proper instruction. */
+    env->cp0.c4_epc = env->regs[31];
+    env->regs[31] = env->cp0.c9_excpbase + env->exception_index;
+    env->interrupt_request |= CPU_INTERRUPT_EXITTB;
+}
+
+static int get_phys_addr(CPUUniCore64State *env, target_ulong address,
+        int access_type, int is_user, target_phys_addr_t *phys_ptr, int *prot,
+        target_ulong *page_size)
+{
+    int code;
+    uint64_t table;
+    uint64_t desc;
+    target_phys_addr_t phys_addr;
+
+    /* Pagetable walk.  */
+    /* Lookup l1 descriptor.  */
+    table = env->cp0.c2_base & 0xffffff000ULL;
+    table |= (address >> 27) & 0xff8;
+    desc = ldq_phys(table);
+    code = 0;
+    if (!(desc & UC64_PAGETABLE_EXIST)) {
+        code = 0x02; /* second pagetable miss */
+        goto do_fault;
+    }
+
+    /* Lookup l2 descriptor.  */
+    table = (desc & 0xffffff000ULL) | ((address >> 18) & 0xff8);
+    desc = ldq_phys(table);
+    switch (desc & 1) {
+    case 1:
+        /* Superpage  */
+        if (!(desc & UC64_PAGETABLE_EXIST)) {
+            code = 0x05; /* superpage miss */
+            goto do_fault;
+        }
+        phys_addr = (desc & 0xfffe00000ULL) | (address & 0x1fffff);
+        *page_size = SUPERPAGE_SIZE;
+        /* FIXME: superpage needs U/S check */
+        break;
+    case 0:
+        /* Lookup l3 entry.  */
+        if (!(desc & UC64_PAGETABLE_EXIST)) {
+            code = 0x03; /* third pagetable miss */
+            goto do_fault;
+        }
+        table = (desc & 0xffffff000ULL) | ((address >> 9) & 0xff8);
+        desc = ldq_phys(table);
+        /* 4k page.  */
+        if (!(desc & UC64_PAGETABLE_EXIST)) {
+            code = 0x04; /* page miss */
+            goto do_fault;
+        }
+        phys_addr = (desc & 0xffffff000ULL) | (address & 0xfff);
+        *page_size = TARGET_PAGE_SIZE;
+
+        if (is_user && !(desc & UC64_PAGETABLE_USER)) {
+            if (access_type == 2) {
+                code = 0x7;/* itrap */
+            } else {
+                code = 0x8;/* dtrap */
+            }
+            goto do_fault;
+        }
+
+        break;
+    default:
+        cpu_abort(env, "wrong page type!");
+    }
+
+    *phys_ptr = phys_addr;
+    *prot = 0;
+    /* Check access permissions.  */
+    if (desc & UC64_PAGETABLE_READ) {
+        *prot |= PAGE_READ;
+    } else {
+        if (access_type == 0) {
+            code = 0x6; /* access unreadable area */
+            goto do_fault;
+        }
+    }
+
+    if (desc & UC64_PAGETABLE_WRITE) {
+        *prot |= PAGE_WRITE;
+    } else {
+        if (access_type == 1) {
+            code = 0x7; /* access unwritable area */
+            goto do_fault;
+        }
+    }
+
+    if (desc & UC64_PAGETABLE_EXEC) {
+        *prot |= PAGE_EXEC;
+    } else {
+        if (access_type == 2) {
+            code = 0x6; /* access unexecutable area */
+            goto do_fault;
+        }
+    }
+
+do_fault:
+    if (code) {
+        trace_uc64_get_phys_addr(address, desc, code, is_user);
+
+        if (access_type == 2) {
+            env->cp0.c3_ifaultstatus = code;
+            env->exception_index = UC64_EXCP_ITRAP;
+        } else {
+            env->cp0.c3_dfaultstatus = code;
+            env->cp0.c4_dtrapaddr = address;
+            env->exception_index = UC64_EXCP_DTRAP;
+        }
+    }
+    return code;
+}
+
+int uc64_cpu_handle_mmu_fault(CPUUniCore64State *env, target_ulong address,
+                              int access_type, int mmu_idx)
+{
+    target_phys_addr_t phys_addr;
+    target_ulong page_size;
+    int prot;
+    int ret, is_user;
+
+    is_user = mmu_idx == MMU_USER_IDX;
+    if ((env->cp0.c1_sys & 1) == 0) {
+        /* MMU disabled.  */
+        phys_addr = address;
+        prot = PAGE_READ | PAGE_WRITE | PAGE_EXEC;
+        page_size = TARGET_PAGE_SIZE;
+        ret = 0;
+    } else {
+        ret = get_phys_addr(env, address, access_type, is_user, &phys_addr,
+                &prot, &page_size);
+    }
+
+    if (ret == 0) {
+        /* Map a single page.  */
+        phys_addr &= TARGET_PAGE_MASK;
+        address &= TARGET_PAGE_MASK;
+        tlb_set_page(env, address, phys_addr, prot, mmu_idx, page_size);
+    }
+
+    return ret;
+}
+
+target_phys_addr_t cpu_get_phys_page_debug(CPUUniCore64State *env,
+        target_ulong addr)
+{
+    target_phys_addr_t phys_addr;
+    target_ulong page_size;
+    int prot;
+    int ret;
+    ret = get_phys_addr(env, addr, 0, 0, &phys_addr, &prot, &page_size);
+
+    if (ret != 0) {
+        return -1;
+    }
+
+    return phys_addr;
+}
diff --git a/target-unicore64/translate.c b/target-unicore64/translate.c
new file mode 100644
index 0000000..ebe4110
--- /dev/null
+++ b/target-unicore64/translate.c
@@ -0,0 +1,1714 @@
+/*
+ *  UniCore64 translation
+ *
+ * Copyright (C) 2012 Guan Xuetao
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation, or (at your option) any
+ * later version. See the COPYING file in the top-level directory.
+ */
+#include <stdarg.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <inttypes.h>
+
+#include "cpu.h"
+#include "disas.h"
+#include "tcg-op.h"
+#include "qemu-log.h"
+
+#include "helper.h"
+#define GEN_HELPER 1
+#include "helper.h"
+
+static TCGv_ptr cpu_env;
+static TCGv_i64 cpu_R[32];
+static TCGv_i64 cpu_R29[3];
+static TCGv_i64 cpu_R30[3];
+
+static TCGv_i64 LLSC_ex_addr; /* exclusive address for LLSC */
+static TCGv_i64 LLSC_ex_lock; /* exclusive lock for LLSC */
+static TCGv_i64 LLSC_ex_val;  /* exclusive value for LLSC */
+
+#include "gen-icount.h"
+
+static const char *regnames[] = {
+      "r00", "r01", "r02", "r03", "r04", "r05", "r06", "r07",
+      "r08", "r09", "r10", "r11", "r12", "r13", "r14", "r15",
+      "r16", "r17", "r18", "r19", "r20", "r21", "r22", "r23",
+      "r24", "r25", "r26", "r27", "r28", "r29", "r30", "pc" };
+
+static const char *r29names[] = {"r29_user", "r29_priv", "r29_debug"};
+static const char *r30names[] = {"r30_user", "r30_priv", "r30_debug"};
+
+/* initialize TCG globals.  */
+void uc64_translate_init(void)
+{
+    int i;
+
+    cpu_env = tcg_global_reg_new_ptr(TCG_AREG0, "env");
+
+    for (i = 0; i < 32; i++) {
+        cpu_R[i] = tcg_global_mem_new_i64(TCG_AREG0,
+                           offsetof(CPUUniCore64State, regs[i]), regnames[i]);
+    }
+
+    for (i = 0; i < 3; i++) {
+        cpu_R29[i] = tcg_global_mem_new_i64(TCG_AREG0,
+                     offsetof(CPUUniCore64State, banked_r29[i]), r29names[i]);
+        cpu_R30[i] = tcg_global_mem_new_i64(TCG_AREG0,
+                     offsetof(CPUUniCore64State, banked_r30[i]), r30names[i]);
+    }
+
+    LLSC_ex_addr = tcg_global_mem_new_i64(TCG_AREG0,
+           offsetof(CPUUniCore64State, llsc_exclusive_addr), "llsc_ex_addr");
+    LLSC_ex_lock = tcg_global_mem_new_i64(TCG_AREG0,
+           offsetof(CPUUniCore64State, llsc_exclusive_lock), "llsc_ex_lock");
+    LLSC_ex_val = tcg_global_mem_new_i64(TCG_AREG0,
+           offsetof(CPUUniCore64State, llsc_exclusive_val), "llsc_ex_val");
+
+#define GEN_HELPER 2
+#include "helper.h"
+}
+
+#define ILLEGAL_INSN(cond)                                                   \
+        if (cond) {                                                          \
+            cpu_abort(env, "Illegal UniCore64 instruction %08x at line %d!", \
+                insn, __LINE__);                                             \
+        }
+
+#define UNHANDLED_FLOW(cond)                                                 \
+        if (cond) {                                                          \
+            cpu_abort(env, "Unhandled control flow at line %d in %s!",       \
+                __LINE__, __FILE__);                                         \
+        }
+
+#define UCOP_REG_D              (((insn) >> 16) & 0x1f)
+#define UCOP_REG_S1             (((insn) >> 11) & 0x1f)
+#define UCOP_REG_S2             (((insn) >>  6) & 0x1f)
+#define UCOP_OPCODE             (((insn) >> 24) & 0x0f)
+#define UCOP_SHIFT              (((insn) >> 24) & 0x03)
+#define UCOP_IMM11              (((insn) >>  0) & 0x7ff)
+#define UCOP_IMM_6              (((insn) >>  0) & 0x3f)
+#define UCOP_IMM_9              (((insn) >>  2) & 0x1ff)
+#define UCOP_CPNUM              (((insn) >> 21) & 0xf)
+#define UCOP_LDST_BHD           (((insn) >> 22) & 0x7)
+#define UCOP_CMOV_COND          (((insn) >> 12) & 0xf)
+
+#define UCOP_SET(i)             ((insn) & (1 << (i)))
+
+/* internal defines */
+typedef struct DisasContext {
+    int dc_jmp;
+    int dc_singlestep;
+    target_ulong dc_pc;
+    struct TranslationBlock *dc_tb;
+    int dc_condinsn; /* If the insn has conditional test */
+    int dc_condlabel; /* Label for next instruction */
+    int dc_user;
+} DisasContext;
+
+#ifndef CONFIG_USER_ONLY
+#define IS_USER(s)      (s->dc_user)
+#else
+#define IS_USER(s)      1
+#endif
+
+#define gen_load_cpu_field(t_op_64, name)               \
+    tcg_gen_ld_i64(t_op_64, cpu_env, offsetof(CPUUniCore64State, name))
+
+#define gen_store_cpu_field(t_op_64, name)               \
+    tcg_gen_st_i64(t_op_64, cpu_env, offsetof(CPUUniCore64State, name))
+
+static inline void gen_set_pc_im(uint64_t val)
+{
+    tcg_gen_movi_i64(cpu_R[31], val);
+}
+
+static void gen_exception(int excp)
+{
+    TCGv_i32 tmp = tcg_temp_new_i32();
+    tcg_gen_movi_i32(tmp, excp);
+    gen_helper_exception(tmp);
+    tcg_temp_free_i32(tmp);
+}
+
+/* Set flags from result.  */
+static inline void gen_flags_logic(TCGv_i64 var_rd)
+{
+    TCGv_i64 t_flag = tcg_temp_new_i64();
+
+    tcg_gen_st_i64(var_rd, cpu_env, offsetof(CPUUniCore64State, NF));
+    tcg_gen_st_i64(var_rd, cpu_env, offsetof(CPUUniCore64State, ZF));
+
+    tcg_gen_movi_i64(t_flag, 0);
+    tcg_gen_st_i64(t_flag, cpu_env, offsetof(CPUUniCore64State, CF));
+    tcg_gen_st_i64(t_flag, cpu_env, offsetof(CPUUniCore64State, VF));
+
+    tcg_temp_free_i64(t_flag);
+}
+
+static void gen_test_cond(int cond, int label)
+{
+    TCGv_i64 t_f1_64, t_f2_64;
+    int t_label;
+
+    t_f1_64 = tcg_temp_new_i64();
+
+    switch (cond) {
+    case 0x0: /* eq: Z */
+        gen_load_cpu_field(t_f1_64, ZF);
+        tcg_gen_brcondi_i64(TCG_COND_EQ, t_f1_64, 0, label);
+        break;
+    case 0x1: /* ne: !Z */
+        gen_load_cpu_field(t_f1_64, ZF);
+        tcg_gen_brcondi_i64(TCG_COND_NE, t_f1_64, 0, label);
+        break;
+    case 0x2: /* cs: C */
+        gen_load_cpu_field(t_f1_64, CF);
+        tcg_gen_brcondi_i64(TCG_COND_NE, t_f1_64, 0, label);
+        break;
+    case 0x3: /* cc: !C */
+        gen_load_cpu_field(t_f1_64, CF);
+        tcg_gen_brcondi_i64(TCG_COND_EQ, t_f1_64, 0, label);
+        break;
+    case 0x4: /* mi: N */
+        gen_load_cpu_field(t_f1_64, NF);
+        tcg_gen_brcondi_i64(TCG_COND_LT, t_f1_64, 0, label);
+        break;
+    case 0x5: /* pl: !N */
+        gen_load_cpu_field(t_f1_64, NF);
+        tcg_gen_brcondi_i64(TCG_COND_GE, t_f1_64, 0, label);
+        break;
+    case 0x6: /* vs: V */
+        gen_load_cpu_field(t_f1_64, VF);
+        tcg_gen_brcondi_i64(TCG_COND_LT, t_f1_64, 0, label);
+        break;
+    case 0x7: /* vc: !V */
+        gen_load_cpu_field(t_f1_64, VF);
+        tcg_gen_brcondi_i64(TCG_COND_GE, t_f1_64, 0, label);
+        break;
+    case 0x8: /* hi: C && !Z */
+        t_f2_64 = tcg_temp_new_i64();
+        t_label = gen_new_label();
+        gen_load_cpu_field(t_f1_64, CF);
+        tcg_gen_brcondi_i64(TCG_COND_EQ, t_f1_64, 0, t_label);
+        gen_load_cpu_field(t_f2_64, ZF);
+        tcg_gen_brcondi_i64(TCG_COND_NE, t_f2_64, 0, label);
+        gen_set_label(t_label);
+        tcg_temp_free_i64(t_f2_64);
+        break;
+    case 0x9: /* ls: !C || Z */
+        t_f2_64 = tcg_temp_new_i64();
+        gen_load_cpu_field(t_f1_64, CF);
+        tcg_gen_brcondi_i64(TCG_COND_EQ, t_f1_64, 0, label);
+        gen_load_cpu_field(t_f2_64, ZF);
+        tcg_gen_brcondi_i64(TCG_COND_EQ, t_f2_64, 0, label);
+        tcg_temp_free_i64(t_f2_64);
+        break;
+    case 0xa: /* ge: N == V -> N ^ V == 0 */
+        t_f2_64 = tcg_temp_new_i64();
+        gen_load_cpu_field(t_f1_64, VF);
+        gen_load_cpu_field(t_f2_64, NF);
+        tcg_gen_xor_i64(t_f1_64, t_f1_64, t_f2_64);
+        tcg_gen_brcondi_i64(TCG_COND_GE, t_f1_64, 0, label);
+        tcg_temp_free_i64(t_f2_64);
+        break;
+    case 0xb: /* lt: N != V -> N ^ V != 0 */
+        t_f2_64 = tcg_temp_new_i64();
+        gen_load_cpu_field(t_f1_64, VF);
+        gen_load_cpu_field(t_f2_64, NF);
+        tcg_gen_xor_i64(t_f1_64, t_f1_64, t_f2_64);
+        tcg_gen_brcondi_i64(TCG_COND_LT, t_f1_64, 0, label);
+        tcg_temp_free_i64(t_f2_64);
+        break;
+    case 0xc: /* gt: !Z && N == V */
+        t_label = gen_new_label();
+        t_f2_64 = tcg_temp_new_i64();
+        gen_load_cpu_field(t_f1_64, ZF);
+        tcg_gen_brcondi_i64(TCG_COND_EQ, t_f1_64, 0, t_label);
+        gen_load_cpu_field(t_f1_64, VF);
+        gen_load_cpu_field(t_f2_64, NF);
+        tcg_gen_xor_i64(t_f1_64, t_f1_64, t_f2_64);
+        tcg_gen_brcondi_i64(TCG_COND_GE, t_f1_64, 0, label);
+        gen_set_label(t_label);
+        tcg_temp_free_i64(t_f2_64);
+        break;
+    case 0xd: /* le: Z || N != V */
+        t_f2_64 = tcg_temp_new_i64();
+        gen_load_cpu_field(t_f1_64, ZF);
+        tcg_gen_brcondi_i64(TCG_COND_EQ, t_f1_64, 0, label);
+        gen_load_cpu_field(t_f1_64, VF);
+        gen_load_cpu_field(t_f2_64, NF);
+        tcg_gen_xor_i64(t_f1_64, t_f1_64, t_f2_64);
+        tcg_gen_brcondi_i64(TCG_COND_LT, t_f1_64, 0, label);
+        tcg_temp_free_i64(t_f2_64);
+        break;
+    default:
+        fprintf(stderr, "Bad condition code 0x%x\n", cond);
+        abort();
+    }
+
+    tcg_temp_free_i64(t_f1_64);
+}
+
+/* dest = T0 + T1 + CF. */
+static void gen_add_carry_i32(TCGv_i32 dest, TCGv_i32 t0, TCGv_i32 t1)
+{
+    TCGv_i32 tmp_32;
+    TCGv_i64 tmp_64;
+    tmp_32 = tcg_temp_new_i32();
+    tmp_64 = tcg_temp_new_i64();
+
+    tcg_gen_add_i32(dest, t0, t1);
+    gen_load_cpu_field(tmp_64, CF);
+    tcg_gen_trunc_i64_i32(tmp_32, tmp_64);
+    tcg_gen_add_i32(dest, dest, tmp_32);
+
+    tcg_temp_free_i32(tmp_32);
+    tcg_temp_free_i64(tmp_64);
+}
+
+/* dest = T0 - T1 + CF - 1.  */
+static void gen_sub_carry_i32(TCGv_i32 dest, TCGv_i32 t0, TCGv_i32 t1)
+{
+    TCGv_i32 tmp_32;
+    TCGv_i64 tmp_64;
+    tmp_32 = tcg_temp_new_i32();
+    tmp_64 = tcg_temp_new_i64();
+
+    tcg_gen_sub_i32(dest, t0, t1);
+    gen_load_cpu_field(tmp_64, CF);
+    tcg_gen_trunc_i64_i32(tmp_32, tmp_64);
+    tcg_gen_add_i32(dest, dest, tmp_32);
+    tcg_gen_subi_i32(dest, dest, 1);
+
+    tcg_temp_free_i32(tmp_32);
+    tcg_temp_free_i64(tmp_64);
+}
+
+/* dest = T0 + T1 + CF. */
+static void gen_add_carry_i64(TCGv_i64 dest, TCGv_i64 t0, TCGv_i64 t1)
+{
+    TCGv_i64 tmp_64;
+    tmp_64 = tcg_temp_new_i64();
+
+    tcg_gen_add_i64(dest, t0, t1);
+    gen_load_cpu_field(tmp_64, CF);
+    tcg_gen_add_i64(dest, dest, tmp_64);
+
+    tcg_temp_free_i64(tmp_64);
+}
+
+/* dest = T0 - T1 + CF - 1.  */
+static void gen_sub_carry_i64(TCGv_i64 dest, TCGv_i64 t0, TCGv_i64 t1)
+{
+    TCGv_i64 tmp_64;
+    tmp_64 = tcg_temp_new_i64();
+
+    tcg_gen_sub_i64(dest, t0, t1);
+    gen_load_cpu_field(tmp_64, CF);
+    tcg_gen_add_i64(dest, dest, tmp_64);
+    tcg_gen_subi_i64(dest, dest, 1);
+
+    tcg_temp_free_i64(tmp_64);
+}
+
+static inline void gen_goto_tb(DisasContext *s, int n, target_ulong dest)
+{
+    TranslationBlock *tb;
+
+    tb = s->dc_tb;
+    if ((tb->pc & TARGET_PAGE_MASK) == (dest & TARGET_PAGE_MASK)) {
+        tcg_gen_goto_tb(n);
+        tcg_gen_movi_i64(cpu_R[31], dest);
+        tcg_gen_exit_tb((tcg_target_long)tb + n);
+    } else {
+        tcg_gen_movi_i64(cpu_R[31], dest);
+        tcg_gen_exit_tb(0);
+    }
+}
+
+static void do_shift(CPUUniCore64State *env, DisasContext *s, uint32_t insn)
+{
+    TCGv_i64 t_op1_64, t_op2_64;
+    TCGv_i32 t_op1_32, t_op2_32;
+
+    ILLEGAL_INSN(UCOP_SET(23));
+    ILLEGAL_INSN(UCOP_REG_D == 31);
+
+    /* Prepare op1 */
+    ILLEGAL_INSN(UCOP_REG_S1 == 31);
+
+    t_op1_64 = tcg_temp_new_i64();
+    tcg_gen_mov_i64(t_op1_64, cpu_R[UCOP_REG_S1]);
+
+    /* Prepare op2 */
+    t_op2_64 = tcg_temp_new_i64();
+    if (UCOP_SET(21)) { /* reg or imm */
+        ILLEGAL_INSN(!UCOP_SET(22) && UCOP_SET(5)); /* bits_per_word = 32 */
+
+        tcg_gen_movi_i64(t_op2_64, UCOP_IMM_6);
+    } else {
+        ILLEGAL_INSN(UCOP_REG_S2 == 31);
+        ILLEGAL_INSN(UCOP_IMM_6);
+
+        tcg_gen_mov_i64(t_op2_64, cpu_R[UCOP_REG_S2]);
+    }
+
+    if (!UCOP_SET(22)) { /* If word, not Double word */
+        t_op1_32 = tcg_temp_new_i32();
+        t_op2_32 = tcg_temp_new_i32();
+
+        tcg_gen_trunc_i64_i32(t_op1_32, t_op1_64);
+        tcg_gen_trunc_i64_i32(t_op2_32, t_op2_64);
+    }
+
+    switch (UCOP_SHIFT) {
+    case 0x00: /* insn DLSL LSL */
+        if (UCOP_SET(22)) { /* insn DLSL */
+            tcg_gen_shl_i64(t_op1_64, t_op1_64, t_op2_64);
+            tcg_gen_mov_i64(cpu_R[UCOP_REG_D], t_op1_64);
+        } else { /* insn LSL */
+            tcg_gen_shl_i32(t_op1_32, t_op1_32, t_op2_32);
+            tcg_gen_extu_i32_i64(cpu_R[UCOP_REG_D], t_op1_32);
+        }
+        break;
+    case 0x01: /* insn DLSR LSR */
+        if (UCOP_SET(22)) { /* insn DLSR */
+            tcg_gen_shr_i64(t_op1_64, t_op1_64, t_op2_64);
+            tcg_gen_mov_i64(cpu_R[UCOP_REG_D], t_op1_64);
+        } else { /* insn LSR */
+            tcg_gen_shr_i32(t_op1_32, t_op1_32, t_op2_32);
+            tcg_gen_extu_i32_i64(cpu_R[UCOP_REG_D], t_op1_32);
+        }
+        break;
+    case 0x02: /* insn DASR ASR */
+        if (UCOP_SET(22)) { /* insn DASR */
+            tcg_gen_sar_i64(t_op1_64, t_op1_64, t_op2_64);
+            tcg_gen_mov_i64(cpu_R[UCOP_REG_D], t_op1_64);
+        } else { /* insn ASR */
+            tcg_gen_sar_i32(t_op1_32, t_op1_32, t_op2_32);
+            tcg_gen_extu_i32_i64(cpu_R[UCOP_REG_D], t_op1_32);
+        }
+        break;
+    case 0x03:
+        ILLEGAL_INSN(true);
+    }
+
+    /* Free temp var */
+    if (!UCOP_SET(22)) { /* If word, not Double word */
+        tcg_temp_free_i32(t_op1_32);
+        tcg_temp_free_i32(t_op2_32);
+    }
+    tcg_temp_free_i64(t_op1_64);
+    tcg_temp_free_i64(t_op2_64);
+}
+
+static void do_clzclo(CPUUniCore64State *env, DisasContext *s, uint32_t insn)
+{
+    TCGv_i64 t_op1_64;
+    TCGv_i32 t_op1_32;
+
+    ILLEGAL_INSN(UCOP_SET(25));
+    ILLEGAL_INSN(UCOP_SET(24));
+    ILLEGAL_INSN(UCOP_SET(21));
+    ILLEGAL_INSN(UCOP_IMM11);
+
+    t_op1_64 = tcg_temp_new_i64();
+    tcg_gen_mov_i64(t_op1_64, cpu_R[UCOP_REG_S1]);
+
+    if (UCOP_SET(22)) { /* 64 bit */
+        if (UCOP_SET(23)) { /* DCNTLZ */
+            gen_helper_clz_i64(t_op1_64, t_op1_64);
+        } else { /* DCNTLO */
+            gen_helper_clo_i64(t_op1_64, t_op1_64);
+        }
+    } else {
+        t_op1_32 = tcg_temp_new_i32();
+        tcg_gen_trunc_i64_i32(t_op1_32, t_op1_64);
+        if (UCOP_SET(23)) { /* CNTLZ */
+            gen_helper_clz_i32(t_op1_32, t_op1_32);
+            tcg_gen_extu_i32_i64(t_op1_64, t_op1_32);
+        } else { /* CNTLO */
+            gen_helper_clo_i32(t_op1_32, t_op1_32);
+            tcg_gen_extu_i32_i64(t_op1_64, t_op1_32);
+        }
+    }
+
+    tcg_gen_mov_i64(cpu_R[UCOP_REG_D], t_op1_64);
+
+    if (!UCOP_SET(22)) {
+        tcg_temp_free_i32(t_op1_32);
+    }
+
+    tcg_temp_free_i64(t_op1_64);
+}
+
+static void do_condmove(CPUUniCore64State *env, DisasContext *s, uint32_t insn)
+{
+    TCGv_i64 t_op2_64;
+    TCGv_i32 t_op2_32;
+
+    ILLEGAL_INSN(UCOP_REG_D == 31);
+    ILLEGAL_INSN(!UCOP_SET(24));
+    ILLEGAL_INSN(UCOP_SET(11));
+    ILLEGAL_INSN((UCOP_CMOV_COND == 0xe) || (UCOP_CMOV_COND == 0xf));
+
+    /* Two branches */
+    s->dc_condlabel = gen_new_label(); /* label for next instruction */
+    gen_test_cond(UCOP_CMOV_COND ^ 1, s->dc_condlabel);
+    s->dc_condinsn = true;
+
+    /* Prepare op2 */
+    t_op2_64 = tcg_temp_new_i64();
+    if (UCOP_SET(21)) { /* reg or imm */
+        tcg_gen_movi_i64(t_op2_64, UCOP_IMM11);
+    } else {
+        ILLEGAL_INSN(UCOP_IMM_6);
+        if (UCOP_REG_S2 == 31) {
+            tcg_gen_movi_i64(t_op2_64, s->dc_pc);
+        } else {
+            tcg_gen_mov_i64(t_op2_64, cpu_R[UCOP_REG_S2]);
+        }
+    }
+
+    if (!UCOP_SET(22)) { /* If word, not Double word */
+        t_op2_32 = tcg_temp_new_i32();
+        tcg_gen_trunc_i64_i32(t_op2_32, t_op2_64);
+    }
+
+    if (UCOP_SET(25)) { /* DCNOT CNOT */
+        if (UCOP_SET(22)) { /* insn DCNOT */
+            tcg_gen_not_i64(cpu_R[UCOP_REG_D], t_op2_64);
+        } else { /* insn CNOT */
+            tcg_gen_not_i32(t_op2_32, t_op2_32);
+            tcg_gen_extu_i32_i64(cpu_R[UCOP_REG_D], t_op2_32);
+        }
+    } else { /* DCMOV CMOV */
+        if (UCOP_SET(22)) { /* insn DCMOV */
+            tcg_gen_mov_i64(cpu_R[UCOP_REG_D], t_op2_64);
+        } else { /* insn CMOV */
+            tcg_gen_extu_i32_i64(cpu_R[UCOP_REG_D], t_op2_32);
+        }
+    }
+
+    if (UCOP_SET(23)) { /* S bit */
+        if (!UCOP_SET(22)) { /* word */
+            tcg_gen_ext_i32_i64(t_op2_64, t_op2_32); /* Signed extend */
+        }
+        gen_flags_logic(t_op2_64);
+    }
+
+    /* Free temp variables */
+    tcg_temp_free_i64(t_op2_64);
+    if (!UCOP_SET(22)) {
+        tcg_temp_free_i32(t_op2_32);
+    }
+}
+
+static void do_datap(CPUUniCore64State *env, DisasContext *s, uint32_t insn)
+{
+    TCGv_i64 t_op1_64, t_op2_64;
+    TCGv_i32 t_op1_32, t_op2_32;
+    int logic_flag = false;
+
+    ILLEGAL_INSN(UCOP_REG_D == 31);
+
+    /* Prepare op1 if two operands */
+    if ((UCOP_OPCODE != 0x0d) && (UCOP_OPCODE != 0x0f)) {
+        t_op1_64 = tcg_temp_new_i64();
+        if (UCOP_REG_S1 == 31) {
+            tcg_gen_movi_i64(t_op1_64, s->dc_pc);
+        } else {
+            tcg_gen_mov_i64(t_op1_64, cpu_R[UCOP_REG_S1]);
+        }
+
+        if (!UCOP_SET(22)) { /* If word, not Double word */
+            t_op1_32 = tcg_temp_new_i32();
+            tcg_gen_trunc_i64_i32(t_op1_32, t_op1_64);
+        }
+    }
+
+    /* Prepare op2 */
+    t_op2_64 = tcg_temp_new_i64();
+    if (UCOP_SET(21)) { /* reg or imm */
+        tcg_gen_movi_i64(t_op2_64, UCOP_IMM11);
+    } else {
+        ILLEGAL_INSN(UCOP_IMM_6);
+        if (UCOP_REG_S2 == 31) {
+            tcg_gen_movi_i64(t_op2_64, s->dc_pc);
+        } else {
+            tcg_gen_mov_i64(t_op2_64, cpu_R[UCOP_REG_S2]);
+        }
+    }
+
+    if (!UCOP_SET(22)) { /* If word, not Double word */
+        t_op2_32 = tcg_temp_new_i32();
+        tcg_gen_trunc_i64_i32(t_op2_32, t_op2_64);
+    }
+
+    switch (UCOP_OPCODE) {
+    case 0x00: /* insn and dand */
+        if (UCOP_SET(22)) { /* insn dand */
+            tcg_gen_and_i64(t_op2_64, t_op1_64, t_op2_64);
+        } else { /* insn and */
+            tcg_gen_and_i32(t_op2_32, t_op1_32, t_op2_32);
+        }
+        logic_flag = true;
+        break;
+    case 0x01: /* insn xor dxor */
+        if (UCOP_SET(22)) { /* insn dxor */
+            tcg_gen_xor_i64(t_op2_64, t_op1_64, t_op2_64);
+        } else { /* insn xor */
+            tcg_gen_xor_i32(t_op2_32, t_op1_32, t_op2_32);
+        }
+        logic_flag = true;
+        break;
+    case 0x02: /* insn sub dsub */
+        if (!UCOP_SET(23)) { /* S bit */
+            if (UCOP_SET(22)) { /* insn DSUB */
+                tcg_gen_sub_i64(t_op2_64, t_op1_64, t_op2_64);
+            } else { /* insn SUB */
+                tcg_gen_sub_i32(t_op2_32, t_op1_32, t_op2_32);
+            }
+        } else {
+            if (UCOP_SET(22)) { /* insn DSUB */
+                gen_helper_sub_cc_i64(t_op2_64, t_op1_64, t_op2_64);
+            } else { /* insn SUB */
+                gen_helper_sub_cc_i32(t_op2_32, t_op1_32, t_op2_32);
+            }
+        }
+        break;
+    case 0x03: /* insn rsub drsub */
+        if (!UCOP_SET(23)) { /* S bit */
+            if (UCOP_SET(22)) { /* insn DRSUB */
+                tcg_gen_sub_i64(t_op2_64, t_op2_64, t_op1_64);
+            } else { /* insn RSUB */
+                tcg_gen_sub_i32(t_op2_32, t_op2_32, t_op1_32);
+            }
+        } else {
+            if (UCOP_SET(22)) { /* insn DRSUB */
+                gen_helper_sub_cc_i64(t_op2_64, t_op2_64, t_op1_64);
+            } else { /* insn RSUB */
+                gen_helper_sub_cc_i32(t_op2_32, t_op2_32, t_op1_32);
+            }
+        }
+        break;
+    case 0x04: /* insn ADD DADD */
+        if (!UCOP_SET(23)) { /* S bit */
+            if (UCOP_SET(22)) { /* insn DADD */
+                tcg_gen_add_i64(t_op2_64, t_op1_64, t_op2_64);
+            } else { /* insn ADD */
+                tcg_gen_add_i32(t_op2_32, t_op1_32, t_op2_32);
+            }
+        } else {
+            if (UCOP_SET(22)) { /* insn DADD */
+                gen_helper_add_cc_i64(t_op2_64, t_op1_64, t_op2_64);
+            } else { /* insn ADD */
+                gen_helper_add_cc_i32(t_op2_32, t_op1_32, t_op2_32);
+            }
+        }
+        break;
+    case 0x05: /* insn addc daddc */
+        if (!UCOP_SET(23)) { /* S bit */
+            if (UCOP_SET(22)) { /* insn DADDC */
+                gen_add_carry_i64(t_op2_64, t_op1_64, t_op2_64);
+            } else { /* insn ADDC */
+                gen_add_carry_i32(t_op2_32, t_op1_32, t_op2_32);
+            }
+        } else {
+            if (UCOP_SET(22)) { /* insn DADDC */
+                gen_helper_adc_cc_i64(t_op2_64, t_op1_64, t_op2_64);
+            } else { /* insn ADDC */
+                gen_helper_adc_cc_i32(t_op2_32, t_op1_32, t_op2_32);
+            }
+        }
+        break;
+    case 0x06: /* insn subc dsubc */
+        if (!UCOP_SET(23)) { /* S bit */
+            if (UCOP_SET(22)) { /* insn DSUBC */
+                gen_sub_carry_i64(t_op2_64, t_op1_64, t_op2_64);
+            } else { /* insn SUBC */
+                gen_sub_carry_i32(t_op2_32, t_op1_32, t_op2_32);
+            }
+        } else {
+            if (UCOP_SET(22)) { /* insn DSUBC */
+                gen_helper_sbc_cc_i64(t_op2_64, t_op1_64, t_op2_64);
+            } else { /* insn SUBC */
+                gen_helper_sbc_cc_i32(t_op2_32, t_op1_32, t_op2_32);
+            }
+        }
+        break;
+    case 0x07: /* insn rsubc drsubc */
+        if (!UCOP_SET(23)) { /* S bit */
+            if (UCOP_SET(22)) { /* insn DRSUBC */
+                gen_sub_carry_i64(t_op2_64, t_op2_64, t_op1_64);
+            } else { /* insn RSUBC */
+                gen_sub_carry_i32(t_op2_32, t_op2_32, t_op1_32);
+            }
+        } else {
+            if (UCOP_SET(22)) { /* insn DRSUBC */
+                gen_helper_sbc_cc_i64(t_op2_64, t_op2_64, t_op1_64);
+            } else { /* insn RSUBC */
+                gen_helper_sbc_cc_i32(t_op2_32, t_op2_32, t_op1_32);
+            }
+        }
+        break;
+    case 0x08: /* insn CMPAND DCMPAND */
+        ILLEGAL_INSN(!UCOP_SET(23)); /* S bit */
+        ILLEGAL_INSN(UCOP_REG_D);
+
+        if (UCOP_SET(22)) { /* insn DCMPAND */
+            tcg_gen_and_i64(t_op2_64, t_op1_64, t_op2_64);
+        } else { /* insn CMPAND */
+            tcg_gen_and_i32(t_op2_32, t_op1_32, t_op2_32);
+        }
+        logic_flag = true;
+        break;
+    case 0x09: /* insn CMPXOR DCMPXOR */
+        ILLEGAL_INSN(!UCOP_SET(23)); /* S bit */
+        ILLEGAL_INSN(UCOP_REG_D);
+
+        if (UCOP_SET(22)) { /* insn DCMPXOR */
+            tcg_gen_xor_i64(t_op2_64, t_op1_64, t_op2_64);
+        } else { /* insn XOR */
+            tcg_gen_xor_i32(t_op2_32, t_op1_32, t_op2_32);
+        }
+        logic_flag = true;
+        break;
+    case 0x0a: /* insn CMPSUB.A DCMPSUB.A */
+        ILLEGAL_INSN(!UCOP_SET(23)); /* S bit */
+        ILLEGAL_INSN(UCOP_REG_D);
+
+        if (UCOP_SET(22)) { /* insn DCMPSUB.A */
+            gen_helper_sub_cc_i64(t_op2_64, t_op1_64, t_op2_64);
+        } else { /* insn CMPSUB.A */
+            gen_helper_sub_cc_i32(t_op2_32, t_op1_32, t_op2_32);
+        }
+        break;
+    case 0x0b: /* insn cmpadd dcmpadd */
+        ILLEGAL_INSN(!UCOP_SET(23)); /* S bit */
+        ILLEGAL_INSN(UCOP_REG_D);
+
+        if (UCOP_SET(22)) { /* insn DCMPADD */
+            gen_helper_add_cc_i64(t_op2_64, t_op1_64, t_op2_64);
+        } else { /* insn CMPADD */
+            gen_helper_add_cc_i32(t_op2_32, t_op1_32, t_op2_32);
+        }
+        break;
+    case 0x0c: /* insn or dor */
+        if (UCOP_SET(22)) { /* insn dor */
+            tcg_gen_or_i64(t_op2_64, t_op1_64, t_op2_64);
+        } else { /* insn or */
+            tcg_gen_or_i32(t_op2_32, t_op1_32, t_op2_32);
+        }
+        logic_flag = true;
+        break;
+    case 0x0d: /* insn MOV DMOV */
+        ILLEGAL_INSN(UCOP_REG_S1);
+        ILLEGAL_INSN(UCOP_SET(23)); /* S bit, NO mov.a/dmov.a in UniCore64 */
+        /* Just write the result */
+        break;
+    case 0x0e: /* insn andn dandn */
+        if (UCOP_SET(22)) { /* insn dandn */
+            tcg_gen_andc_i64(t_op2_64, t_op1_64, t_op2_64);
+        } else { /* insn andn */
+            tcg_gen_andc_i32(t_op2_32, t_op1_32, t_op2_32);
+        }
+        logic_flag = true;
+        break;
+    case 0x0f: /* insn NOT DNOT */
+        ILLEGAL_INSN(UCOP_REG_S1);
+        ILLEGAL_INSN(UCOP_SET(23)); /* S bit, NO not.a/dnot.a in UniCore64 */
+
+        if (UCOP_SET(22)) { /* insn DNOT */
+            tcg_gen_not_i64(t_op2_64, t_op2_64);
+        } else { /* insn NOT */
+            tcg_gen_not_i32(t_op2_32, t_op2_32);
+        }
+        break;
+    default:
+        ILLEGAL_INSN(true);
+    }
+
+    /* Write result */
+    if ((UCOP_OPCODE & 0xc) != 0x8) {
+        if (UCOP_SET(22)) { /* Double word */
+            tcg_gen_mov_i64(cpu_R[UCOP_REG_D], t_op2_64);
+        } else { /* Word */
+            tcg_gen_extu_i32_i64(cpu_R[UCOP_REG_D], t_op2_32);
+        }
+    }
+
+    /* Write flags logic */
+    if (UCOP_SET(23) && logic_flag) { /* S bit */
+        if (!UCOP_SET(22)) { /* word */
+            tcg_gen_ext_i32_i64(t_op2_64, t_op2_32); /* Signed extend */
+        }
+        gen_flags_logic(t_op2_64);
+    }
+
+    /* Free temp variables */
+    if ((UCOP_OPCODE != 0x0d) && (UCOP_OPCODE != 0x0f)) { /* if two ops */
+        tcg_temp_free_i64(t_op1_64);
+        if (!UCOP_SET(22)) {
+            tcg_temp_free_i32(t_op1_32);
+        }
+    }
+    tcg_temp_free_i64(t_op2_64);
+    if (!UCOP_SET(22)) {
+        tcg_temp_free_i32(t_op2_32);
+    }
+}
+
+static void do_srfr(CPUUniCore64State *env, DisasContext *s, uint32_t insn)
+{
+    TCGv_i64 t_flag_64;
+
+    t_flag_64 = tcg_temp_new_i64();
+
+    if ((insn & 0xfbfffff0) == 0x38200000) { /* insn mov afr/bfr, imm */
+        tcg_gen_movi_i64(t_flag_64, (uint64_t)insn & 0xf);
+        if (UCOP_SET(26)) { /* C bit: insn mov afr, imm*/
+            gen_helper_afr_write(t_flag_64);
+        } else {/* insn mov bfr, imm */
+            gen_store_cpu_field(t_flag_64, bfr);
+        }
+
+        tcg_temp_free_i64(t_flag_64);
+        return;
+    }
+    if ((insn & 0xf3ff07ff) == 0x30000000) { /* mov reg to STATUS/FLAG */
+        ILLEGAL_INSN(UCOP_REG_S1 == 31);
+
+        tcg_gen_mov_i64(t_flag_64, cpu_R[UCOP_REG_S1]);
+
+        switch ((insn >> 26) & 0x3) {
+        case 0: /* !F && !C : bsr */
+            gen_store_cpu_field(t_flag_64, bsr);
+            break;
+        case 1: /* !F &&  C : asr */
+            gen_helper_asr_write(t_flag_64);
+            break;
+        case 2: /*  F && !C : bfr */
+            gen_store_cpu_field(t_flag_64, bfr);
+            break;
+        case 3: /*  F &&  C : afr */
+            gen_helper_afr_write(t_flag_64);
+        }
+
+        tcg_temp_free_i64(t_flag_64);
+        return;
+    }
+    if ((insn & 0xf3e0ffff) == 0x20000000) { /* mov STATUS/FLAG to reg */
+        ILLEGAL_INSN(UCOP_REG_D == 31);
+
+        switch ((insn >> 26) & 0x3) {
+        case 0: /* !F && !C : bsr */
+            gen_load_cpu_field(t_flag_64, bsr);
+            break;
+        case 1: /* !F &&  C : asr */
+            gen_helper_asr_read(t_flag_64);
+            break;
+        case 2: /*  F && !C : bfr */
+            gen_load_cpu_field(t_flag_64, bfr);
+            break;
+        case 3: /*  F &&  C : afr */
+            gen_helper_afr_read(t_flag_64);
+        }
+
+        tcg_gen_mov_i64(cpu_R[UCOP_REG_D], t_flag_64);
+        tcg_temp_free_i64(t_flag_64);
+        return;
+    }
+
+    /* otherwise */
+    ILLEGAL_INSN(true);
+}
+
+static void do_muldiv(CPUUniCore64State *env, DisasContext *s, uint32_t insn)
+{
+    TCGv_i64 t_op1_64, t_op2_64, t_rd_64;
+    TCGv_i32 t_op1_32, t_op2_32, t_rd_32;
+
+    ILLEGAL_INSN(UCOP_SET(26));
+    ILLEGAL_INSN(UCOP_SET(25));
+    ILLEGAL_INSN(UCOP_SET(24));
+    ILLEGAL_INSN(UCOP_SET(21));
+    ILLEGAL_INSN(UCOP_REG_D == 31);
+    ILLEGAL_INSN(UCOP_REG_S1 == 31);
+    ILLEGAL_INSN(UCOP_REG_S2 == 31);
+    ILLEGAL_INSN(UCOP_IMM_6);
+
+    t_op1_64 = tcg_temp_new_i64();
+    t_op2_64 = tcg_temp_new_i64();
+    t_rd_64 = tcg_temp_new_i64();
+
+    tcg_gen_mov_i64(t_op1_64, cpu_R[UCOP_REG_S1]);
+    tcg_gen_mov_i64(t_op2_64, cpu_R[UCOP_REG_S2]);
+
+    if (!UCOP_SET(22)) {
+        t_op1_32 = tcg_temp_new_i32();
+        t_op2_32 = tcg_temp_new_i32();
+        t_rd_32 = tcg_temp_new_i32();
+        tcg_gen_trunc_i64_i32(t_op1_32, t_op1_64);
+        tcg_gen_trunc_i64_i32(t_op2_32, t_op2_64);
+    }
+
+    if (UCOP_SET(28)) { /* DDIV DIV */
+        if (UCOP_SET(22)) { /* 64 bit div */
+            if (UCOP_SET(27)) {
+                tcg_gen_divu_i64(t_rd_64, t_op1_64, t_op2_64);
+            } else {
+                tcg_gen_div_i64(t_rd_64, t_op1_64, t_op2_64);
+            }
+        } else { /* 32 bit div */
+            if (UCOP_SET(27)) {
+                tcg_gen_divu_i32(t_rd_32, t_op1_32, t_op2_32);
+                tcg_gen_extu_i32_i64(t_rd_64, t_rd_32);
+            } else {
+                tcg_gen_div_i32(t_rd_32, t_op1_32, t_op2_32);
+                tcg_gen_extu_i32_i64(t_rd_64, t_rd_32);
+            }
+        }
+    } else { /* DMUL MUL */
+        if (UCOP_SET(22)) { /* 64 bit mul */
+            if (UCOP_SET(27)) { /* DMLA */
+                tcg_gen_mov_i64(t_rd_64, cpu_R[UCOP_REG_D]);
+                tcg_gen_mul_i64(t_op1_64, t_op1_64, t_op2_64);
+                tcg_gen_add_i64(t_rd_64, t_rd_64, t_op1_64);
+            } else { /* DMUL */
+                tcg_gen_mul_i64(t_rd_64, t_op1_64, t_op2_64);
+            }
+        } else { /* 32 bit mul */
+            if (UCOP_SET(27)) { /* MLA */
+                tcg_gen_mov_i64(t_rd_64, cpu_R[UCOP_REG_D]);
+                tcg_gen_trunc_i64_i32(t_rd_32, t_rd_64);
+                tcg_gen_mul_i32(t_op1_32, t_op1_32, t_op2_32);
+                tcg_gen_add_i32(t_rd_32, t_rd_32, t_op1_32);
+                tcg_gen_extu_i32_i64(t_rd_64, t_rd_32);
+            } else { /* MUL */
+                tcg_gen_mul_i32(t_rd_32, t_op1_32, t_op2_32);
+                tcg_gen_extu_i32_i64(t_rd_64, t_rd_32);
+            }
+        }
+    }
+
+    /* Write the result */
+    tcg_gen_mov_i64(cpu_R[UCOP_REG_D], t_rd_64);
+
+    if (UCOP_SET(23)) { /* S bit */
+        if (!UCOP_SET(22)) { /* word */
+            tcg_gen_ext_i32_i64(t_rd_64, t_rd_32); /* Signed extend */
+        }
+        gen_flags_logic(t_rd_64);
+    }
+
+    /* Free temp vars */
+    if (!UCOP_SET(22)) {
+        tcg_temp_free_i32(t_op1_32);
+        tcg_temp_free_i32(t_op2_32);
+        tcg_temp_free_i32(t_rd_32);
+    }
+    tcg_temp_free_i64(t_op1_64);
+    tcg_temp_free_i64(t_op2_64);
+    tcg_temp_free_i64(t_rd_64);
+}
+
+static void do_ldst(CPUUniCore64State *env, DisasContext *s, uint32_t insn)
+{
+    TCGv_i64 t_addr, t_op2_64, t_rd_64;
+
+    if (!UCOP_LDST_BHD) {
+        if (insn == 0x68000000) {
+            /* FIXME: SYNC instruction */
+            return;
+        }
+        ILLEGAL_INSN(true); /* prefetch? */
+    }
+
+    t_addr = tcg_temp_new_i64();
+    t_op2_64 = tcg_temp_new_i64();
+    t_rd_64 = tcg_temp_new_i64();
+
+    /* Prepare base address */
+    if (UCOP_REG_S1 == 31) {
+        tcg_gen_movi_i64(t_addr, s->dc_pc);
+    } else {
+        tcg_gen_mov_i64(t_addr, cpu_R[UCOP_REG_S1]);
+    }
+
+    /* Prepare op2 */
+    if (UCOP_SET(21)) { /* reg or imm */
+        tcg_gen_movi_i64(t_op2_64, UCOP_IMM11);
+    } else {
+        ILLEGAL_INSN(UCOP_IMM_6);
+
+        if (UCOP_REG_S2 == 31) {
+            tcg_gen_movi_i64(t_op2_64, s->dc_pc);
+        } else {
+            tcg_gen_mov_i64(t_op2_64, cpu_R[UCOP_REG_S2]);
+        }
+    }
+
+    if (UCOP_SET(27)) { /* pre */
+        if (UCOP_SET(28)) { /* add */
+            tcg_gen_add_i64(t_addr, t_addr, t_op2_64);
+        } else { /* sub */
+            tcg_gen_sub_i64(t_addr, t_addr, t_op2_64);
+        }
+    }
+
+    if (UCOP_SET(25)) { /* load */
+        switch (UCOP_LDST_BHD) {
+        case 0:
+            ILLEGAL_INSN(true);
+            break;
+        case 1:
+            tcg_gen_qemu_ld64(t_rd_64, t_addr, IS_USER(s));
+            break;
+        case 2:
+            tcg_gen_qemu_ld16u(t_rd_64, t_addr, IS_USER(s));
+            break;
+        case 3:
+            tcg_gen_qemu_ld16s(t_rd_64, t_addr, IS_USER(s));
+            break;
+        case 4:
+            tcg_gen_qemu_ld8u(t_rd_64, t_addr, IS_USER(s));
+            break;
+        case 5:
+            tcg_gen_qemu_ld8s(t_rd_64, t_addr, IS_USER(s));
+            break;
+        case 6:
+            tcg_gen_qemu_ld32u(t_rd_64, t_addr, IS_USER(s));
+            break;
+        case 7:
+            tcg_gen_qemu_ld32s(t_rd_64, t_addr, IS_USER(s));
+            break;
+        }
+    } else { /* store */
+        if (UCOP_REG_D == 31) {
+            tcg_gen_movi_i64(t_rd_64, s->dc_pc);
+        } else {
+            tcg_gen_mov_i64(t_rd_64, cpu_R[UCOP_REG_D]);
+        }
+
+        switch (UCOP_LDST_BHD) {
+        case 1:
+            tcg_gen_qemu_st64(t_rd_64, t_addr, IS_USER(s));
+            break;
+        case 2:
+            tcg_gen_qemu_st16(t_rd_64, t_addr, IS_USER(s));
+            break;
+        case 4:
+            tcg_gen_qemu_st8(t_rd_64, t_addr, IS_USER(s));
+            break;
+        case 6:
+            tcg_gen_qemu_st32(t_rd_64, t_addr, IS_USER(s));
+            break;
+        default:
+            ILLEGAL_INSN(true);
+            break;
+        }
+    }
+
+    if (!UCOP_SET(27)) { /* post */
+        ILLEGAL_INSN(!UCOP_SET(26)); /* post && !writeback is illegal */
+
+        if (UCOP_SET(28)) { /* add */
+            tcg_gen_add_i64(t_addr, t_addr, t_op2_64);
+        } else { /* sub */
+            tcg_gen_sub_i64(t_addr, t_addr, t_op2_64);
+        }
+    }
+
+    if (!UCOP_SET(27) || UCOP_SET(26)) { /* post || writeback */
+        ILLEGAL_INSN(UCOP_REG_S1 == 31);
+
+        tcg_gen_mov_i64(cpu_R[UCOP_REG_S1], t_addr);
+    }
+
+    if (UCOP_SET(25)) { /* Complete the load, in case rd==rs1 */
+        ILLEGAL_INSN(UCOP_REG_D == 31);
+        tcg_gen_mov_i64(cpu_R[UCOP_REG_D], t_rd_64);
+    }
+
+    tcg_temp_free_i64(t_addr);
+    tcg_temp_free_i64(t_op2_64);
+    tcg_temp_free_i64(t_rd_64);
+}
+
+static void do_ldst_user(CPUUniCore64State *env, DisasContext *s, uint32_t insn)
+{
+    TCGv_i64 t_addr, t_op2_64, t_rd_64;
+
+    ILLEGAL_INSN(!UCOP_LDST_BHD); /* prefetch or sync? */
+
+    t_addr = tcg_temp_new_i64();
+    t_op2_64 = tcg_temp_new_i64();
+    t_rd_64 = tcg_temp_new_i64();
+
+    /* Prepare base address */
+    if (UCOP_REG_S1 == 31) {
+        tcg_gen_movi_i64(t_addr, s->dc_pc);
+    } else {
+        tcg_gen_mov_i64(t_addr, cpu_R[UCOP_REG_S1]);
+    }
+
+    /* Prepare op2 */
+    if (UCOP_SET(21)) { /* reg or imm */
+        tcg_gen_movi_i64(t_op2_64, UCOP_IMM11);
+    } else {
+        ILLEGAL_INSN(UCOP_REG_S2 == 31);
+        ILLEGAL_INSN(UCOP_IMM_6);
+
+        tcg_gen_mov_i64(t_op2_64, cpu_R[UCOP_REG_S2]);
+    }
+
+    if (UCOP_SET(27)) { /* pre */
+        if (UCOP_SET(28)) { /* add */
+            tcg_gen_add_i64(t_addr, t_addr, t_op2_64);
+        } else { /* sub */
+            tcg_gen_sub_i64(t_addr, t_addr, t_op2_64);
+        }
+    }
+
+    if (UCOP_SET(25)) { /* load */
+        switch (UCOP_LDST_BHD) {
+        case 0:
+            ILLEGAL_INSN(true);
+            break;
+        case 1:
+            tcg_gen_qemu_ld64(t_rd_64, t_addr, IS_USER(s));
+            break;
+        }
+    } else { /* store */
+        if (UCOP_REG_D == 31) {
+            tcg_gen_movi_i64(t_rd_64, s->dc_pc);
+        } else {
+            if (UCOP_REG_D == 29) {
+                tcg_gen_mov_i64(t_rd_64, cpu_R29[0]);
+            } else if (UCOP_REG_D == 30) {
+                tcg_gen_mov_i64(t_rd_64, cpu_R30[0]);
+            } else {
+                tcg_gen_mov_i64(t_rd_64, cpu_R[UCOP_REG_D]);
+            }
+        }
+
+        switch (UCOP_LDST_BHD) {
+        case 1:
+            tcg_gen_qemu_st64(t_rd_64, t_addr, IS_USER(s));
+            break;
+        default:
+            ILLEGAL_INSN(true);
+            break;
+        }
+    }
+
+    if (!UCOP_SET(27)) { /* post */
+        ILLEGAL_INSN(!UCOP_SET(26)); /* post && !writeback is illegal */
+
+        if (UCOP_SET(28)) { /* add */
+            tcg_gen_add_i64(t_addr, t_addr, t_op2_64);
+        } else { /* sub */
+            tcg_gen_sub_i64(t_addr, t_addr, t_op2_64);
+        }
+    }
+
+    if (!UCOP_SET(27) || UCOP_SET(26)) { /* post || writeback */
+        ILLEGAL_INSN(UCOP_REG_S1 == 31);
+
+        tcg_gen_mov_i64(cpu_R[UCOP_REG_S1], t_addr);
+    }
+
+    if (UCOP_SET(25)) { /* Complete the load, in case rd==rs1 */
+        ILLEGAL_INSN(UCOP_REG_D == 31);
+        if (UCOP_REG_D == 29) {
+            tcg_gen_mov_i64(cpu_R29[0], t_rd_64);
+        } else if (UCOP_REG_D == 30) {
+            tcg_gen_mov_i64(cpu_R30[0], t_rd_64);
+        } else {
+            tcg_gen_mov_i64(cpu_R[UCOP_REG_D], t_rd_64);
+        }
+    }
+
+    tcg_temp_free_i64(t_addr);
+    tcg_temp_free_i64(t_op2_64);
+    tcg_temp_free_i64(t_rd_64);
+}
+
+static void do_swap(CPUUniCore64State *env, DisasContext *s, uint32_t insn)
+{
+    TCGv_i64 t_addr, t_op2_64;
+
+    ILLEGAL_INSN(insn & 0x1e000000);
+    ILLEGAL_INSN(UCOP_REG_D == 31);
+    ILLEGAL_INSN(UCOP_REG_S2 == 31);
+    ILLEGAL_INSN(UCOP_IMM_6);
+
+    t_addr = tcg_temp_new_i64();
+    t_op2_64 = tcg_temp_new_i64();
+
+    /* Prepare address */
+    if (UCOP_REG_S1 == 31) {
+        tcg_gen_movi_i64(t_addr, s->dc_pc);
+    } else {
+        tcg_gen_mov_i64(t_addr, cpu_R[UCOP_REG_S1]);
+    }
+
+    /* Prepare op2 */
+    tcg_gen_mov_i64(t_op2_64, cpu_R[UCOP_REG_S2]);
+
+    if (UCOP_SET(22)) { /* Double word */
+        ILLEGAL_INSN(UCOP_SET(21));
+
+        tcg_gen_qemu_ld64(cpu_R[UCOP_REG_D], t_addr, IS_USER(s));
+        tcg_gen_qemu_st64(t_op2_64, t_addr, IS_USER(s));
+    } else {
+        if (UCOP_SET(21)) { /* Byte */
+            tcg_gen_qemu_ld8u(cpu_R[UCOP_REG_D], t_addr, IS_USER(s));
+            tcg_gen_qemu_st8(t_op2_64, t_addr, IS_USER(s));
+        } else { /* Word */
+            tcg_gen_qemu_ld32u(cpu_R[UCOP_REG_D], t_addr, IS_USER(s));
+            tcg_gen_qemu_st32(t_op2_64, t_addr, IS_USER(s));
+        }
+    }
+
+    tcg_temp_free_i64(t_addr);
+    tcg_temp_free_i64(t_op2_64);
+}
+
+static void do_llsc(CPUUniCore64State *env, DisasContext *s, uint32_t insn)
+{
+    TCGv_i64 t_addr, t_baseaddr, t_op2_64, t_rd_64, tmp;
+    int fail_label;
+    int done_label;
+
+    ILLEGAL_INSN(UCOP_REG_D == 31);
+
+    /* post && !writeback is illegal */
+    ILLEGAL_INSN(!UCOP_SET(27) && !UCOP_SET(26));
+
+    t_addr = tcg_temp_new_i64();
+    t_baseaddr = tcg_temp_new_i64();
+    t_op2_64 = tcg_temp_new_i64();
+    t_rd_64 = tcg_temp_new_i64();
+    tmp = tcg_temp_new_i64();
+
+    /* Prepare base address */
+    if (UCOP_REG_S1 == 31) {
+        tcg_gen_movi_i64(t_baseaddr, s->dc_pc);
+    } else {
+        tcg_gen_mov_i64(t_baseaddr, cpu_R[UCOP_REG_S1]);
+    }
+
+    /* Prepare op2 */
+    if (UCOP_SET(21)) { /* reg or imm */
+        tcg_gen_movi_i64(t_op2_64, UCOP_IMM11);
+    } else {
+        ILLEGAL_INSN(UCOP_REG_S2 == 31);
+        ILLEGAL_INSN(UCOP_IMM_6);
+
+        tcg_gen_mov_i64(t_op2_64, cpu_R[UCOP_REG_S2]);
+    }
+
+    /* calculate addr */
+    if (UCOP_SET(28)) { /* add */
+        tcg_gen_add_i64(t_addr, t_baseaddr, t_op2_64);
+    } else { /* sub */
+        tcg_gen_sub_i64(t_addr, t_baseaddr, t_op2_64);
+    }
+
+    /* write back addr while post || writeback*/
+    if (!UCOP_SET(27) || UCOP_SET(26)) {
+        ILLEGAL_INSN(UCOP_REG_S1 == 31);
+        tcg_gen_mov_i64(cpu_R[UCOP_REG_S1], t_addr);
+    }
+
+    /* t_addr = t_baseaddr while post */
+    if (!UCOP_SET(27)) {
+        tcg_gen_mov_i64(t_addr, t_baseaddr);
+    }
+
+    if (UCOP_SET(25)) { /* ll */
+        if (UCOP_SET(22)) { /* double word */
+            tcg_gen_qemu_ld64(cpu_R[UCOP_REG_D], t_addr, IS_USER(s));
+        } else { /* word */
+            tcg_gen_qemu_ld32u(cpu_R[UCOP_REG_D], t_addr, IS_USER(s));
+        }
+
+        tcg_gen_mov_i64(LLSC_ex_addr, t_addr);
+        tcg_gen_movi_i64(LLSC_ex_lock, true);
+        tcg_gen_mov_i64(LLSC_ex_val, cpu_R[UCOP_REG_D]);
+    } else { /* SC */
+        fail_label = gen_new_label();
+        done_label = gen_new_label();
+
+        tcg_gen_brcond_i64(TCG_COND_NE, LLSC_ex_addr, t_addr, fail_label);
+        tcg_gen_brcondi_i64(TCG_COND_NE, LLSC_ex_lock, true, fail_label);
+        /* addr are equal && lock is true */
+        if (UCOP_SET(22)) { /* double word */
+            tcg_gen_qemu_ld64(tmp, LLSC_ex_addr, IS_USER(s));
+        } else { /* word */
+            tcg_gen_qemu_ld32u(tmp, LLSC_ex_addr, IS_USER(s));
+        }
+        tcg_gen_brcond_i64(TCG_COND_NE, LLSC_ex_val, tmp, fail_label);
+        /* the value is the same with LL */
+
+        tcg_gen_mov_i64(t_rd_64, cpu_R[UCOP_REG_D]);
+        if (UCOP_SET(22)) { /* double word */
+            tcg_gen_qemu_st64(t_rd_64, LLSC_ex_addr, IS_USER(s));
+        } else { /* word */
+            tcg_gen_qemu_st32(t_rd_64, LLSC_ex_addr, IS_USER(s));
+        }
+
+        /* Now, t_rd_64 is used for lock */
+        tcg_gen_movi_i64(cpu_R[UCOP_REG_D], true);
+        tcg_gen_movi_i64(LLSC_ex_lock, false);
+
+        tcg_gen_br(done_label);
+
+        gen_set_label(fail_label);
+        /* addr are diff || lock is false */
+        tcg_gen_movi_i64(cpu_R[UCOP_REG_D], false);
+        tcg_gen_movi_i64(LLSC_ex_lock, false);
+
+        gen_set_label(done_label);
+    }
+
+    tcg_temp_free_i64(t_addr);
+    tcg_temp_free_i64(t_baseaddr);
+    tcg_temp_free_i64(t_op2_64);
+    tcg_temp_free_i64(t_rd_64);
+    tcg_temp_free_i64(tmp);
+}
+
+static void do_branch(CPUUniCore64State *env, DisasContext *s, uint32_t insn)
+{
+    target_ulong t_addr;
+    TCGv_i64 tmp;
+
+    if (UCOP_SET(28)) { /* link */
+        /* r30 <- next_insn */
+        tcg_gen_movi_i64(cpu_R[30], s->dc_pc + 4);
+    }
+
+    if (UCOP_OPCODE == 0xf) {
+        if (!(insn & 0x00ff07ff)) { /* JUMP and CALL-R */
+            ILLEGAL_INSN(UCOP_REG_S1 == 31);
+
+            tcg_gen_mov_i64(cpu_R[31], cpu_R[UCOP_REG_S1]);
+            s->dc_jmp = DISAS_JUMP;
+        } else { /* RETURN and ERET */
+            ILLEGAL_INSN(UCOP_SET(28));
+
+            switch (insn & 0x00ffffff) {
+            case 0x00800000:
+                /* RETURN instruction: r31 <- r30 */
+                tcg_gen_mov_i64(cpu_R[31], cpu_R[30]);
+                s->dc_jmp = DISAS_JUMP;
+                break;
+            case 0x00c00000:
+                /* ERET instruction: r31 <- p0.c4_epc, ASR <- BSR */
+                tmp = tcg_temp_new_i64();
+                gen_load_cpu_field(cpu_R[31], cp0.c4_epc);
+                gen_load_cpu_field(tmp, bsr);
+                gen_helper_asr_write(tmp);
+                gen_load_cpu_field(tmp, bfr);
+                gen_helper_afr_write(tmp);
+                tcg_temp_free_i64(tmp);
+                s->dc_jmp = DISAS_JUMP;
+                break;
+            default:
+                ILLEGAL_INSN(true);
+            }
+        }
+    } else { /* This branch means IMM24 */
+        if (UCOP_OPCODE != 0xe) { /* conditional branch */
+            s->dc_condlabel = gen_new_label(); /* label for next instruction */
+            gen_test_cond(UCOP_OPCODE ^ 1, s->dc_condlabel);
+            s->dc_condinsn = true;
+        } /* else: UCOP_OPCODE == 0xe, it's insn CALL, just fall through */
+
+        /* r31 <- current_insn + (signed_offset * 4) */
+        t_addr = s->dc_pc + ((((int32_t)insn) << 8) >> 6);
+        gen_goto_tb(s, 0, t_addr);
+        s->dc_jmp = DISAS_TB_JUMP;
+    }
+}
+
+#include "ucf64_trans.h"
+
+static void do_coproc(CPUUniCore64State *env, DisasContext *s, uint32_t insn)
+{
+    TCGv_i64 t_creg_64, t_cop_64;
+
+    switch (UCOP_CPNUM) {
+    case 0: /* cp0 */
+        ILLEGAL_INSN(UCOP_REG_D == 31);
+        ILLEGAL_INSN((insn & 0xfc000003) != 0xc0000000);
+
+        t_creg_64 = tcg_temp_new_i64();
+        t_cop_64 = tcg_temp_new_i64();
+        tcg_gen_movi_i64(t_cop_64, UCOP_IMM_9);
+        if (use_icount) {
+            gen_io_start();
+        }
+
+        if (UCOP_SET(25)) { /* load */
+            tcg_gen_movi_i64(t_creg_64, UCOP_REG_S1);
+            gen_helper_cp0_get(t_creg_64, cpu_env, t_creg_64, t_cop_64);
+            tcg_gen_mov_i64(cpu_R[UCOP_REG_D], t_creg_64);
+        } else { /* store */
+            tcg_gen_movi_i64(t_creg_64, UCOP_REG_D);
+            gen_helper_cp0_set(cpu_env, cpu_R[UCOP_REG_S1], t_creg_64,
+                    t_cop_64);
+        }
+
+        if (use_icount) {
+            gen_io_end();
+        }
+
+        tcg_temp_free(t_creg_64);
+        tcg_temp_free(t_cop_64);
+        break;
+    case 1: /* fake ocd */
+        /* ONLY handle movc p1.cd, rs1, #0 */
+        ILLEGAL_INSN((insn & 0xfe0007ff) != 0xc0000000);
+        ILLEGAL_INSN(UCOP_REG_S1 == 31);
+
+        switch (UCOP_REG_D) { /* REG_D is cd */
+        case 0: /* movc p1.c0, rs1, #0 */
+            t_creg_64 = tcg_temp_new_i64();
+            tcg_gen_mov_i64(t_creg_64, cpu_R[UCOP_REG_S1]);
+            gen_helper_cp1_putc(t_creg_64);
+            tcg_temp_free(t_creg_64);
+            break;
+        case 1: /* movc p1.c1, rs1, #0 */
+            t_creg_64 = tcg_temp_new_i64();
+            tcg_gen_mov_i64(t_creg_64, cpu_R[UCOP_REG_S1]);
+            gen_helper_cp1_putx(t_creg_64);
+            tcg_temp_free(t_creg_64);
+            break;
+        default:
+            ILLEGAL_INSN(true);
+        }
+        break;
+    case 2: /* floating point insn */
+        do_ucf64(env, s, insn);
+        break;
+    default:
+        ILLEGAL_INSN(true);
+    }
+}
+
+static void do_exception(CPUUniCore64State *env, DisasContext *s, uint32_t insn)
+{
+    TCGv_i32 tmp;
+
+    if ((insn & 0xff000000) == 0xf0000000) { /* JEPRIV instruction */
+        /*
+         * NO BSR ASR BFR AFR handling
+         */
+        ILLEGAL_INSN((insn & 0x00ff0000) != 0); /* Least 16 bits available */
+
+        tmp = tcg_temp_new_i32();
+        tcg_gen_movi_i64(cpu_R[31], s->dc_pc + 4);
+        tcg_gen_movi_i32(tmp, UC64_EXCP_PRIV);
+        gen_helper_exception(tmp);
+        tcg_temp_free_i32(tmp);
+
+        s->dc_jmp = DISAS_TB_JUMP;
+        return;
+    }
+
+    if ((insn & 0xff000000) == 0xee000000) { /* BKPT */
+        gen_helper_ocd_output();
+        return;
+    }
+
+    if ((insn & 0xff000000) == 0xff000000) { /* HALT */
+        tmp = tcg_temp_new_i32();
+        tcg_gen_movi_i32(tmp, CPU_INTERRUPT_HALT);
+        gen_helper_halt(tmp);
+        tcg_temp_free_i32(tmp);
+
+        s->dc_jmp = DISAS_TB_JUMP;
+        return;
+    }
+    ILLEGAL_INSN(true);
+}
+
+static void disas_uc64_insn(CPUUniCore64State *env, DisasContext *s)
+{
+    unsigned int insn;
+
+    insn = ldl_code(s->dc_pc);
+
+    /* UniCore64 instructions class:
+     *   AAAx xxxx xxxx xxxx xxxx xxxx xxxx xxxx
+     */
+    switch (insn >> 29) {
+    case 0x0:
+        if (UCOP_SET(28)) {
+            switch ((insn >> 26) & 0x3) {
+            case 0x0:
+                do_shift(env, s, insn);
+                break;
+            case 0x1:
+                ILLEGAL_INSN(true);
+            case 0x2:
+                do_clzclo(env, s, insn);
+                break;
+            case 0x3:
+                do_condmove(env, s, insn);
+                break;
+            }
+        } else {
+            do_datap(env, s, insn);
+        }
+        break;
+    case 0x1:
+        do_srfr(env, s, insn);
+        break;
+    case 0x2:
+        do_muldiv(env, s, insn);
+        break;
+    case 0x3:
+        do_ldst(env, s, insn);
+        break;
+    case 0x4:
+        switch ((insn >> 23) & 0x3) {
+        case 0x0:
+            do_ldst_user(env, s, insn);
+            break;
+        case 0x2:
+            do_llsc(env, s, insn);
+            break;
+        case 0x3:
+            do_swap(env, s, insn);
+            break;
+        default:
+            ILLEGAL_INSN(true);
+        }
+        break;
+    case 0x5:
+        do_branch(env, s, insn);
+        break;
+    case 0x6:
+        do_coproc(env, s, insn);
+        break;
+    case 0x7:
+        do_exception(env, s, insn);
+        /* All conditions are handled, so default is not necessary */
+    }
+}
+
+/* generate intermediate code in gen_opc_buf and gen_opparam_buf for
+   basic block 'tb'. If search_pc is TRUE, also generate PC
+   information for each intermediate instruction. */
+static inline void gen_intermediate_code_internal(CPUUniCore64State *env,
+        TranslationBlock *tb, int search_pc)
+{
+    DisasContext dc1, *dc = &dc1;
+    target_ulong pc_start;
+    CPUBreakpoint *bp;
+    int j, lj;
+    int num_insns;
+    int max_insns;
+
+    pc_start = tb->pc;
+
+    dc->dc_tb = tb;
+    dc->dc_pc = pc_start;
+    dc->dc_jmp = DISAS_NEXT;
+    dc->dc_singlestep = env->singlestep_enabled;
+    dc->dc_condinsn = false;
+
+    lj = -1;
+    num_insns = 0;
+    max_insns = tb->cflags & CF_COUNT_MASK;
+    if (max_insns == 0) {
+        max_insns = CF_COUNT_MASK;
+    }
+
+#ifndef CONFIG_USER_ONLY
+    if ((env->uncached_asr & ASR_MODE_SELECT) == ASR_MODE_USER) {
+        dc->dc_user = 1;
+    } else {
+        dc->dc_user = 0;
+    }
+#endif
+
+    gen_icount_start();
+    do {
+        if (unlikely(!QTAILQ_EMPTY(&env->breakpoints))) {
+            QTAILQ_FOREACH(bp, &env->breakpoints, entry) {
+                if (bp->pc == dc->dc_pc) {
+                    gen_set_pc_im(dc->dc_pc);
+                    gen_exception(EXCP_DEBUG);
+                    dc->dc_jmp = DISAS_JUMP;
+                    /* Advance PC so that clearing the breakpoint will
+                     *                      invalidate this TB.  */
+                    dc->dc_pc += 4; /* FIXME */
+                    goto done_disas_loop;
+                    break;
+                }
+            }
+        }
+        if (search_pc) {
+            j = gen_opc_ptr - gen_opc_buf;
+            if (lj < j) {
+                lj++;
+                while (lj < j) {
+                    gen_opc_instr_start[lj++] = 0;
+                }
+            }
+            gen_opc_pc[lj] = dc->dc_pc;
+            gen_opc_instr_start[lj] = 1;
+            gen_opc_icount[lj] = num_insns;
+        }
+
+        if (num_insns + 1 == max_insns && (tb->cflags & CF_LAST_IO)) {
+            gen_io_start();
+        }
+
+        if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP | CPU_LOG_TB_OP_OPT))) {
+            tcg_gen_debug_insn_start(dc->dc_pc);
+        }
+
+        disas_uc64_insn(env, dc);
+
+        dc->dc_pc += 4;
+
+        if (dc->dc_condinsn && !dc->dc_jmp) { /* conditional instructions */
+            gen_set_label(dc->dc_condlabel);
+            dc->dc_condinsn = false;
+        }
+
+        /* Translation stops when a conditional branch is encountered.
+         * Otherwise the subsequent code could get translated several times.
+         * Also stop translation when a page boundary is reached.  This
+         * ensures prefetch aborts occur at the right place.  */
+        num_insns++;
+        if (num_insns >= max_insns) {
+            goto done_disas_loop;
+        }
+
+        if (singlestep || env->singlestep_enabled) {
+            goto done_disas_loop;
+        }
+
+        if (gen_opc_ptr >= gen_opc_buf + OPC_MAX_SIZE) {
+            goto done_disas_loop;
+        }
+
+        if (dc->dc_pc >= (pc_start & TARGET_PAGE_MASK) + TARGET_PAGE_SIZE) {
+            goto done_disas_loop;
+        }
+
+    } while (dc->dc_jmp == DISAS_NEXT);
+
+done_disas_loop:
+    if (tb->cflags & CF_LAST_IO) {
+        if (dc->dc_condinsn) {
+            /* FIXME: This can theoretically happen with self-modifying code */
+            cpu_abort(env, "IO on conditional branch instruction");
+        }
+        gen_io_end();
+    }
+
+    if (unlikely(env->singlestep_enabled)) {
+        UNHANDLED_FLOW(true);
+    } else {
+        /* While branches must always occur at the end of an IT block,
+         * there are a few other things that can cause us to terminate
+         * the TB in the middel of an IT block:
+         *  - Exception generating instructions (bkpt, swi, undefined).
+         *  - Page boundaries.
+         *  - Hardware watchpoints.
+         * Hardware breakpoints have already been handled and skip this code.
+         */
+        switch (dc->dc_jmp) {
+        case DISAS_NEXT:
+            gen_goto_tb(dc, 1, dc->dc_pc);
+            break;
+        case DISAS_TB_JUMP:
+            /* nothing more to generate */
+            break;
+        case DISAS_JUMP:
+            tcg_gen_exit_tb(0);
+            break;
+        default:
+            UNHANDLED_FLOW(true);
+        }
+
+        if (dc->dc_condinsn) { /* branch instructions */
+            gen_set_label(dc->dc_condlabel);
+            gen_goto_tb(dc, 1, dc->dc_pc);
+            dc->dc_condinsn = false;
+        }
+    }
+
+    gen_icount_end(tb, num_insns);
+    *gen_opc_ptr = INDEX_op_end;
+
+#ifdef DEBUG_DISAS
+    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {
+        qemu_log("------------------------------\n");
+        qemu_log("IN: %s\n", lookup_symbol(pc_start));
+        log_target_disas(pc_start, dc->dc_pc - pc_start, 0);
+        qemu_log("------------------------------\n");
+    }
+#endif
+
+    if (search_pc) {
+        j = gen_opc_ptr - gen_opc_buf;
+        lj++;
+        while (lj <= j) {
+            gen_opc_instr_start[lj++] = 0;
+        }
+    } else {
+        tb->size = dc->dc_pc - pc_start;
+        tb->icount = num_insns;
+    }
+}
+
+void gen_intermediate_code(CPUUniCore64State *env, TranslationBlock *tb)
+{
+    gen_intermediate_code_internal(env, tb, 0);
+}
+
+void gen_intermediate_code_pc(CPUUniCore64State *env, TranslationBlock *tb)
+{
+    gen_intermediate_code_internal(env, tb, 1);
+}
+
+void cpu_dump_state(CPUUniCore64State *env, FILE *f,
+        fprintf_function cpu_fprintf, int flags)
+{
+    int i;
+
+    for (i = 0; i < 32; i++) {
+        cpu_fprintf(f, "R%02d=%16" PRIx64, i, env->regs[i]);
+        if ((i % 4) == 3) {
+            cpu_fprintf(f, "\n");
+        } else {
+            cpu_fprintf(f, " ");
+        }
+    }
+    cpu_fprintf(f, " NF=%16" PRIx64 "  ZF=%16" PRIx64
+            "  CF=%16" PRIx64 "  VF=%16" PRIx64 "\n",
+            env->NF, env->ZF, env->CF, env->VF);
+    cpu_fprintf(f, "ASR=%16" PRIx64 " BSR=%16" PRIx64 "\n",
+            env->uncached_asr, env->bsr);
+}
+
+void restore_state_to_opc(CPUUniCore64State *env, TranslationBlock *tb,
+        int pc_pos)
+{
+    env->regs[31] = gen_opc_pc[pc_pos];
+}
diff --git a/target-unicore64/ucf64_helper.c b/target-unicore64/ucf64_helper.c
new file mode 100644
index 0000000..fb8db16
--- /dev/null
+++ b/target-unicore64/ucf64_helper.c
@@ -0,0 +1,399 @@
+/*
+ * UniCore-F64 simulation helpers for QEMU.
+ *
+ * Copyright (C) 2010-2012 Guan Xuetao
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation, or any later version.
+ * See the COPYING file in the top-level directory.
+ */
+#include "cpu.h"
+#include "helper.h"
+
+/* UniCore-F64 status register.  */
+#define UCF64_FPSR_MASK                (0xfffffff)
+#define UCF64_FPSR_RND_MASK            (0x7)
+#define UCF64_FPSR_RND(r)              (((r) >>  0) & UCF64_FPSR_RND_MASK)
+#define UCF64_FPSR_TRAPEN_MASK         (0x7f)
+#define UCF64_FPSR_TRAPEN(r)           (((r) >> 10) & UCF64_FPSR_TRAPEN_MASK)
+#define UCF64_FPSR_FLAG_MASK           (0x1ff)
+#define UCF64_FPSR_FLAG(r)             (((r) >> 17) & UCF64_FPSR_FLAG_MASK)
+#define UCF64_FPSR_FLAG_ZERO           (1 << 17)
+#define UCF64_FPSR_FLAG_INFINITY       (1 << 18)
+#define UCF64_FPSR_FLAG_INVALID        (1 << 19)
+#define UCF64_FPSR_FLAG_UNDERFLOW      (1 << 20)
+#define UCF64_FPSR_FLAG_OVERFLOW       (1 << 21)
+#define UCF64_FPSR_FLAG_INEXACT        (1 << 22)
+#define UCF64_FPSR_FLAG_HUGEINT        (1 << 23)
+#define UCF64_FPSR_FLAG_DENORMAL       (1 << 24)
+#define UCF64_FPSR_FLAG_DIVZERO        (1 << 25)
+
+/*
+ * The convention used for UniCore-F64 instructions:
+ *  Single precition routines have a "s" suffix
+ *  Double precision routines have a "d" suffix.
+ */
+
+/* Convert host exception flags to f64 form.  */
+static inline int ucf64_exceptbits_from_host(int host_bits)
+{
+    int target_bits = 0;
+
+    if (host_bits & float_flag_invalid) {
+        target_bits |= UCF64_FPSR_FLAG_INVALID;
+    }
+    if (host_bits & float_flag_divbyzero) {
+        target_bits |= UCF64_FPSR_FLAG_DIVZERO;
+    }
+    if (host_bits & float_flag_overflow) {
+        target_bits |= UCF64_FPSR_FLAG_OVERFLOW;
+    }
+    if (host_bits & float_flag_underflow) {
+        target_bits |= UCF64_FPSR_FLAG_UNDERFLOW;
+    }
+    if (host_bits & float_flag_inexact) {
+        target_bits |= UCF64_FPSR_FLAG_INEXACT;
+    }
+    return target_bits;
+}
+
+uint64_t HELPER(ucf64_get_fpsr)(CPUUniCore64State *env)
+{
+    int i;
+    uint64_t fpsr;
+
+    fpsr = (env->ucf64.fpsr & UCF64_FPSR_MASK);
+    i = get_float_exception_flags(&env->ucf64.qemu_fp_status);
+    fpsr |= (uint64_t)ucf64_exceptbits_from_host(i);
+    return fpsr;
+}
+
+/* Convert ucf64 exception flags to target form.  */
+static inline int ucf64_exceptbits_to_host(int target_bits)
+{
+    int host_bits = 0;
+
+    if (target_bits & UCF64_FPSR_FLAG_INVALID) {
+        host_bits |= float_flag_invalid;
+    }
+    if (target_bits & UCF64_FPSR_FLAG_DIVZERO) {
+        host_bits |= float_flag_divbyzero;
+    }
+    if (target_bits & UCF64_FPSR_FLAG_OVERFLOW) {
+        host_bits |= float_flag_overflow;
+    }
+    if (target_bits & UCF64_FPSR_FLAG_UNDERFLOW) {
+        host_bits |= float_flag_underflow;
+    }
+    if (target_bits & UCF64_FPSR_FLAG_INEXACT) {
+        host_bits |= float_flag_inexact;
+    }
+    return host_bits;
+}
+
+void HELPER(ucf64_set_fpsr)(CPUUniCore64State *env, uint64_t val)
+{
+    int i;
+    uint64_t changed;
+
+    changed = env->ucf64.fpsr;
+    env->ucf64.fpsr = (val & UCF64_FPSR_MASK);
+
+    changed ^= val;
+    if (changed & (UCF64_FPSR_RND_MASK)) {
+        i = UCF64_FPSR_RND(val);
+        switch (i) {
+        case 0:
+            i = float_round_nearest_even;
+            break;
+        case 1:
+            i = float_round_to_zero;
+            break;
+        case 2:
+            i = float_round_up;
+            break;
+        case 3:
+            i = float_round_down;
+            break;
+        default: /* 100 and 101 not implement */
+            cpu_abort(env, "Unsupported UniCore64-F64 round mode");
+        }
+        set_float_rounding_mode(i, &env->ucf64.qemu_fp_status);
+    }
+
+    i = ucf64_exceptbits_to_host(UCF64_FPSR_TRAPEN(val));
+    set_float_exception_flags(i, &env->ucf64.qemu_fp_status);
+}
+
+void HELPER(ucf64_set_fpfr)(CPUUniCore64State *env, uint64_t val)
+{
+    env->ucf64.fpfr = val;
+}
+
+uint64_t HELPER(ucf64_get_fpfr)(CPUUniCore64State *env)
+{
+    return env->ucf64.fpfr;
+}
+
+float32 HELPER(ucf64_adds)(float32 a, float32 b, CPUUniCore64State *env)
+{
+    return float32_add(a, b, &env->ucf64.qemu_fp_status);
+}
+
+float64 HELPER(ucf64_addd)(float64 a, float64 b, CPUUniCore64State *env)
+{
+    return float64_add(a, b, &env->ucf64.qemu_fp_status);
+}
+
+float32 HELPER(ucf64_subs)(float32 a, float32 b, CPUUniCore64State *env)
+{
+    return float32_sub(a, b, &env->ucf64.qemu_fp_status);
+}
+
+float64 HELPER(ucf64_subd)(float64 a, float64 b, CPUUniCore64State *env)
+{
+    return float64_sub(a, b, &env->ucf64.qemu_fp_status);
+}
+
+float32 HELPER(ucf64_muls)(float32 a, float32 b, CPUUniCore64State *env)
+{
+    return float32_mul(a, b, &env->ucf64.qemu_fp_status);
+}
+
+float64 HELPER(ucf64_muld)(float64 a, float64 b, CPUUniCore64State *env)
+{
+    return float64_mul(a, b, &env->ucf64.qemu_fp_status);
+}
+
+float32 HELPER(ucf64_divs)(float32 a, float32 b, CPUUniCore64State *env)
+{
+    return float32_div(a, b, &env->ucf64.qemu_fp_status);
+}
+
+float64 HELPER(ucf64_divd)(float64 a, float64 b, CPUUniCore64State *env)
+{
+    return float64_div(a, b, &env->ucf64.qemu_fp_status);
+}
+
+float32 HELPER(ucf64_negs)(float32 a)
+{
+    return float32_chs(a);
+}
+
+float64 HELPER(ucf64_negd)(float64 a)
+{
+    return float64_chs(a);
+}
+
+float32 HELPER(ucf64_abss)(float32 a)
+{
+    return float32_abs(a);
+}
+
+float64 HELPER(ucf64_absd)(float64 a)
+{
+    return float64_abs(a);
+}
+
+float32 HELPER(ucf64_movts)(float32 a, float32 b, uint32_t cond,
+                         CPUUniCore64State *env)
+{
+    if (((env->ucf64.fpfr & 0x2) && cond) ||
+        (!(env->ucf64.fpfr & 0x2) && (!cond))) {
+        return b;
+    }
+    return a;
+}
+
+float64 HELPER(ucf64_movtd)(float64 a, float64 b, uint32_t cond,
+                         CPUUniCore64State *env)
+{
+    if (((env->ucf64.fpfr & 0x2) && cond) ||
+        (!(env->ucf64.fpfr & 0x2) && (!cond))) {
+        return b;
+    }
+    return a;
+}
+
+float64 HELPER(ucf64_movtw)(float64 a, float64 b, uint32_t cond,
+                         CPUUniCore64State *env)
+{
+    if (((env->ucf64.fpfr & 0x2) && cond) ||
+        (!(env->ucf64.fpfr & 0x2) && (!cond))) {
+        return b;
+    }
+    return a;
+}
+
+void HELPER(ucf64_cmps)(float32 a, float32 b, uint32_t c,
+        CPUUniCore64State *env)
+{
+    int flag;
+    flag = float32_compare_quiet(a, b, &env->ucf64.qemu_fp_status);
+    env->ucf64.fpfr &= 0xd;
+    switch (c & 0x7) {
+    case 0: /* F */
+        break;
+    case 1: /* UN */
+        if (flag == 2) {
+            env->ucf64.fpfr |= 0x2;
+        }
+        break;
+    case 2: /* EQ */
+        if (flag == 0) {
+            env->ucf64.fpfr |= 0x2;
+        }
+        break;
+    case 3: /* UEQ */
+        if ((flag == 0) || (flag == 2)) {
+            env->ucf64.fpfr |= 0x2;
+        }
+        break;
+    case 4: /* OLT */
+        if (flag == -1) {
+            env->ucf64.fpfr |= 0x2;
+        }
+        break;
+    case 5: /* ULT */
+        if ((flag == -1) || (flag == 2)) {
+            env->ucf64.fpfr |= 0x2;
+        }
+        break;
+    case 6: /* OLE */
+        if ((flag == -1) || (flag == 0)) {
+            env->ucf64.fpfr |= 0x2;
+        }
+        break;
+    case 7: /* ULE */
+        if (flag != 1) {
+            env->ucf64.fpfr |= 0x2;
+        }
+        break;
+    }
+}
+
+void HELPER(ucf64_cmpd)(float64 a, float64 b, uint32_t c,
+        CPUUniCore64State *env)
+{
+    int flag;
+    flag = float64_compare_quiet(a, b, &env->ucf64.qemu_fp_status);
+    env->ucf64.fpfr &= 0xd;
+    switch (c & 0x7) {
+    case 0: /* F */
+        break;
+    case 1: /* UN */
+        if (flag == 2) {
+            env->ucf64.fpfr |= 0x2;
+        }
+        break;
+    case 2: /* EQ */
+        if (flag == 0) {
+            env->ucf64.fpfr |= 0x2;
+        }
+        break;
+    case 3: /* UEQ */
+        if ((flag == 0) || (flag == 2)) {
+            env->ucf64.fpfr |= 0x2;
+        }
+        break;
+    case 4: /* OLT */
+        if (flag == -1) {
+            env->ucf64.fpfr |= 0x2;
+        }
+        break;
+    case 5: /* ULT */
+        if ((flag == -1) || (flag == 2)) {
+            env->ucf64.fpfr |= 0x2;
+        }
+        break;
+    case 6: /* OLE */
+        if ((flag == -1) || (flag == 0)) {
+            env->ucf64.fpfr |= 0x2;
+        }
+        break;
+    case 7: /* ULE */
+        if (flag != 1) {
+            env->ucf64.fpfr |= 0x2;
+        }
+        break;
+    }
+}
+
+/* Helper routines to perform bitwise copies between float and int.  */
+static inline float32 ucf64_itos(uint32_t i)
+{
+    union {
+        uint32_t i;
+        float32 s;
+    } v;
+
+    v.i = i;
+    return v.s;
+}
+
+static inline uint32_t ucf64_stoi(float32 s)
+{
+    union {
+        uint32_t i;
+        float32 s;
+    } v;
+
+    v.s = s;
+    return v.i;
+}
+
+static inline float64 ucf64_itod(uint64_t i)
+{
+    union {
+        uint64_t i;
+        float64 d;
+    } v;
+
+    v.i = i;
+    return v.d;
+}
+
+static inline uint64_t ucf64_dtoi(float64 d)
+{
+    union {
+        uint64_t i;
+        float64 d;
+    } v;
+
+    v.d = d;
+    return v.i;
+}
+
+/* Integer to float conversion.  */
+float32 HELPER(ucf64_si2sf)(float32 x, CPUUniCore64State *env)
+{
+    return int32_to_float32(ucf64_stoi(x), &env->ucf64.qemu_fp_status);
+}
+
+float64 HELPER(ucf64_si2df)(float32 x, CPUUniCore64State *env)
+{
+    return int32_to_float64(ucf64_stoi(x), &env->ucf64.qemu_fp_status);
+}
+
+/* Float to integer conversion.  */
+float32 HELPER(ucf64_sf2si)(float32 x, CPUUniCore64State *env)
+{
+    return ucf64_itos(float32_to_int32(x, &env->ucf64.qemu_fp_status));
+}
+
+float32 HELPER(ucf64_df2si)(float64 x, CPUUniCore64State *env)
+{
+    return ucf64_itos(float64_to_int32(x, &env->ucf64.qemu_fp_status));
+}
+
+/* floating point conversion */
+float64 HELPER(ucf64_sf2df)(float32 x, CPUUniCore64State *env)
+{
+    return float32_to_float64(x, &env->ucf64.qemu_fp_status);
+}
+
+float32 HELPER(ucf64_df2sf)(float64 x, CPUUniCore64State *env)
+{
+    return float64_to_float32(x, &env->ucf64.qemu_fp_status);
+}
diff --git a/target-unicore64/ucf64_trans.h b/target-unicore64/ucf64_trans.h
new file mode 100644
index 0000000..7e95205
--- /dev/null
+++ b/target-unicore64/ucf64_trans.h
@@ -0,0 +1,439 @@
+/*
+ *  UniCore64 translation
+ *
+ * Copyright (C) 2012 Guan Xuetao
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation, or (at your option) any
+ * later version. See the COPYING file in the top-level directory.
+ */
+
+#define UCOP_UCF64_FMT          (((insn) >> 25) & 0x03)
+
+static inline long ucf64_reg_offset(int reg)
+{
+    if (reg & 1) {
+        return offsetof(CPUUniCore64State, ucf64.regs[reg >> 1])
+          + offsetof(CPU_DoubleU, l.upper);
+    } else {
+        return offsetof(CPUUniCore64State, ucf64.regs[reg >> 1])
+          + offsetof(CPU_DoubleU, l.lower);
+    }
+}
+
+static void do_ucf64_trans(CPUUniCore64State *env, DisasContext *s,
+                           uint32_t insn)
+{
+    TCGv_i64 tmp;
+
+    tmp = tcg_temp_new_i64();
+    if ((insn & 0xfde007ff) == 0xc0400000) { /* insn MFF MTF */
+        ILLEGAL_INSN(UCOP_REG_D == 31);
+        if (UCOP_SET(25)) { /* MFF */
+            tcg_gen_ld_i64(tmp, cpu_env, ucf64_reg_offset(UCOP_REG_S1));
+            tcg_gen_mov_i64(cpu_R[UCOP_REG_D], tmp);
+        } else { /* MTF */
+            tcg_gen_mov_i64(tmp, cpu_R[UCOP_REG_D]);
+            tcg_gen_st_i64(tmp, cpu_env, ucf64_reg_offset(UCOP_REG_S1));
+        }
+        return;
+    }
+
+    if ((insn & 0xfde0ffff) == 0xc4400000) { /* insn CFF CTF */
+        if (UCOP_SET(25)) { /* CFF */
+            if (UCOP_REG_D != 31) {
+                gen_helper_ucf64_get_fpsr(tmp, cpu_env);
+                tcg_gen_mov_i64(cpu_R[UCOP_REG_D], tmp);
+            } else { /* FLAG = FPU.FLAG*/
+                gen_helper_ucf64_get_fpfr(tmp, cpu_env);
+                gen_helper_afr_write(tmp);
+            }
+        } else { /* CTF */
+            if (UCOP_REG_D != 31) {
+                tcg_gen_mov_i64(tmp, cpu_R[UCOP_REG_D]);
+                gen_helper_ucf64_set_fpsr(cpu_env, tmp);
+            } else { /* FPU.FLAG = FLAG */
+                gen_helper_afr_read(tmp);
+                gen_helper_ucf64_set_fpfr(cpu_env, tmp);
+            }
+        }
+        return;
+    }
+
+    tcg_temp_free(tmp);
+    ILLEGAL_INSN(true);
+}
+
+static void do_ucf64_fcvt(CPUUniCore64State *env, DisasContext *s,
+                          uint32_t insn)
+{
+    TCGv_i32 t_F0s;
+    TCGv_i64 t_F0d, t_F1d;
+
+    t_F0s = tcg_temp_new_i32();
+    t_F0d = tcg_temp_new_i64();
+    t_F1d = tcg_temp_new_i64();
+
+    ILLEGAL_INSN(UCOP_UCF64_FMT == 3); /* 26 and 25 bits cannot be 0x3 */
+    ILLEGAL_INSN(UCOP_REG_S1); /* UCOP_REG_S1 must be 0 */
+
+    switch ((insn >> 2) & 0xf) { /* op2 */
+    case 0: /* cvt.s */
+        switch (UCOP_UCF64_FMT) {
+        case 1: /* d */
+            tcg_gen_ld_i64(t_F0d, cpu_env, ucf64_reg_offset(UCOP_REG_S2));
+            gen_helper_ucf64_df2sf(t_F0s, t_F0d, cpu_env);
+            tcg_gen_extu_i32_i64(t_F1d, t_F0s);
+            tcg_gen_st_i64(t_F1d, cpu_env, ucf64_reg_offset(UCOP_REG_D));
+            break;
+        case 2: /* w */
+            tcg_gen_ld_i32(t_F0s, cpu_env, ucf64_reg_offset(UCOP_REG_S2));
+            gen_helper_ucf64_si2sf(t_F0s, t_F0s, cpu_env);
+            tcg_gen_extu_i32_i64(t_F1d, t_F0s);
+            tcg_gen_st_i64(t_F1d, cpu_env, ucf64_reg_offset(UCOP_REG_D));
+            break;
+        default: /* undefined */
+            ILLEGAL_INSN(true);
+        }
+        break;
+    case 1: /* cvt.d */
+        switch (UCOP_UCF64_FMT) {
+        case 0: /* s */
+            tcg_gen_ld_i32(t_F0s, cpu_env, ucf64_reg_offset(UCOP_REG_S2));
+            gen_helper_ucf64_sf2df(t_F0d, t_F0s, cpu_env);
+            tcg_gen_st_i64(t_F0d, cpu_env, ucf64_reg_offset(UCOP_REG_D));
+            break;
+        case 2: /* w */
+            tcg_gen_ld_i32(t_F0s, cpu_env, ucf64_reg_offset(UCOP_REG_S2));
+            gen_helper_ucf64_si2df(t_F0d, t_F0s, cpu_env);
+            tcg_gen_st_i64(t_F0d, cpu_env, ucf64_reg_offset(UCOP_REG_D));
+            break;
+        default: /* undefined */
+            ILLEGAL_INSN(true);
+        }
+        break;
+    case 4: /* cvt.w */
+        switch (UCOP_UCF64_FMT) {
+        case 0: /* s */
+            tcg_gen_ld_i32(t_F0s, cpu_env, ucf64_reg_offset(UCOP_REG_S2));
+            gen_helper_ucf64_sf2si(t_F0s, t_F0s, cpu_env);
+            tcg_gen_extu_i32_i64(t_F1d, t_F0s);
+            tcg_gen_st_i64(t_F1d, cpu_env, ucf64_reg_offset(UCOP_REG_D));
+            break;
+        case 1: /* d */
+            tcg_gen_ld_i64(t_F0d, cpu_env, ucf64_reg_offset(UCOP_REG_S2));
+            gen_helper_ucf64_df2si(t_F0s, t_F0d, cpu_env);
+            tcg_gen_extu_i32_i64(t_F1d, t_F0s);
+            tcg_gen_st_i64(t_F1d, cpu_env, ucf64_reg_offset(UCOP_REG_D));
+            break;
+        default: /* undefined */
+           ILLEGAL_INSN(true);
+        }
+        break;
+    default:
+        ILLEGAL_INSN(true);
+    }
+    tcg_temp_free_i32(t_F0s);
+    tcg_temp_free_i64(t_F0d);
+    tcg_temp_free_i64(t_F1d);
+}
+
+static void do_ucf64_fcmp(CPUUniCore64State *env, DisasContext *s,
+                          uint32_t insn)
+{
+    TCGv_i32 t_F0s;
+    TCGv_i64 t_F0d;
+    TCGv_i32 t_F1s;
+    TCGv_i64 t_F1d;
+
+    TCGv_i32 cond;
+
+    t_F0s = tcg_temp_new_i32();
+    t_F0d = tcg_temp_new_i64();
+    t_F1s = tcg_temp_new_i32();
+    t_F1d = tcg_temp_new_i64();
+
+    cond = tcg_temp_new_i32();
+
+    ILLEGAL_INSN(UCOP_SET(26));
+
+    tcg_gen_movi_i32(cond, ((insn >> 2) & 0xf));
+
+    if (UCOP_SET(25)) {
+        tcg_gen_ld_i64(t_F0d, cpu_env, ucf64_reg_offset(UCOP_REG_S1));
+        tcg_gen_ld_i64(t_F1d, cpu_env, ucf64_reg_offset(UCOP_REG_S2));
+        gen_helper_ucf64_cmpd(t_F0d, t_F1d, cond, cpu_env);
+    } else {
+        tcg_gen_ld_i32(t_F0s, cpu_env, ucf64_reg_offset(UCOP_REG_S1));
+        tcg_gen_ld_i32(t_F1s, cpu_env, ucf64_reg_offset(UCOP_REG_S2));
+        gen_helper_ucf64_cmps(t_F0s, t_F1s, cond, cpu_env);
+    }
+    tcg_temp_free_i32(t_F0s);
+    tcg_temp_free_i64(t_F0d);
+    tcg_temp_free_i32(t_F1s);
+    tcg_temp_free_i64(t_F1d);
+
+    tcg_temp_free_i32(cond);
+}
+
+#define UCF64_OP1(name)    do {                           \
+        ILLEGAL_INSN(UCOP_REG_S1);                        \
+        switch (UCOP_UCF64_FMT) {                         \
+        case 0 /* s */:                                   \
+            tcg_gen_ld_i32(t_F0s, cpu_env,                \
+                           ucf64_reg_offset(UCOP_REG_S2));\
+            gen_helper_ucf64_##name##s(t_F0s, t_F0s);     \
+            tcg_gen_st_i32(t_F0s, cpu_env,                \
+                           ucf64_reg_offset(UCOP_REG_D)); \
+            break;                                        \
+        case 1 /* d */:                                   \
+            tcg_gen_ld_i64(t_F0d, cpu_env,                \
+                           ucf64_reg_offset(UCOP_REG_S2));\
+            gen_helper_ucf64_##name##d(t_F0d, t_F0d);     \
+            tcg_gen_st_i64(t_F0d, cpu_env,                \
+                           ucf64_reg_offset(UCOP_REG_D)); \
+            break;                                        \
+        case 2 /* w */:                                   \
+            ILLEGAL_INSN(true);                           \
+            break;                                        \
+        }                                                 \
+    } while (0)
+
+#define UCF64_OP2(name)    do {                           \
+        switch (UCOP_UCF64_FMT) {                         \
+        case 0 /* s */:                                   \
+            tcg_gen_ld_i32(t_F0s, cpu_env,                \
+                           ucf64_reg_offset(UCOP_REG_S1));\
+            tcg_gen_ld_i32(t_F1s, cpu_env,                \
+                           ucf64_reg_offset(UCOP_REG_S2));\
+            gen_helper_ucf64_##name##s(t_F0s,             \
+                           t_F0s, t_F1s, cpu_env);        \
+            tcg_gen_st_i32(t_F0s, cpu_env,                \
+                           ucf64_reg_offset(UCOP_REG_D)); \
+            break;                                        \
+        case 1 /* d */:                                   \
+            tcg_gen_ld_i64(t_F0d, cpu_env,                \
+                           ucf64_reg_offset(UCOP_REG_S1));\
+            tcg_gen_ld_i64(t_F1d, cpu_env,                \
+                           ucf64_reg_offset(UCOP_REG_S2));\
+            gen_helper_ucf64_##name##d(t_F0d,             \
+                           t_F0d, t_F1d, cpu_env);        \
+            tcg_gen_st_i64(t_F0d, cpu_env,                \
+                           ucf64_reg_offset(UCOP_REG_D)); \
+            break;                                        \
+        case 2 /* w */:                                   \
+            ILLEGAL_INSN(true);                           \
+            break;                                        \
+        }                                                 \
+    } while (0)
+
+static void do_ucf64_datap(CPUUniCore64State *env, DisasContext *s,
+                           uint32_t insn)
+{
+    TCGv_i32 t_F0s;
+    TCGv_i64 t_F0d;
+    TCGv_i32 t_F1s;
+    TCGv_i64 t_F1d;
+    TCGv_i32 t_cond;
+
+    t_F0s = tcg_temp_new_i32();
+    t_F0d = tcg_temp_new_i64();
+    t_F1s = tcg_temp_new_i32();
+    t_F1d = tcg_temp_new_i64();
+    t_cond = tcg_temp_new_i32();
+
+    ILLEGAL_INSN(UCOP_UCF64_FMT == 3);
+
+    switch ((insn >> 2) & 0xf) { /* op2 */
+    case 0: /* add */
+        UCF64_OP2(add);
+        break;
+    case 1: /* sub */
+        UCF64_OP2(sub);
+        break;
+    case 2: /* mul */
+        UCF64_OP2(mul);
+        break;
+    case 4: /* div */
+        UCF64_OP2(div);
+        break;
+    case 5: /* abs */
+        UCF64_OP1(abs);
+        break;
+    case 6: /* mov */
+        ILLEGAL_INSN(UCOP_REG_S1);
+        switch (UCOP_UCF64_FMT) {
+        case 0 /* s */:
+            tcg_gen_ld_i32(t_F0s, cpu_env, ucf64_reg_offset(UCOP_REG_S2));
+            tcg_gen_st_i32(t_F0s, cpu_env, ucf64_reg_offset(UCOP_REG_D));
+            break;
+        case 1 /* d */:
+            tcg_gen_ld_i64(t_F0d, cpu_env, ucf64_reg_offset(UCOP_REG_S2));
+            tcg_gen_st_i64(t_F0d, cpu_env, ucf64_reg_offset(UCOP_REG_D));
+            break;
+        case 2 /* w */:
+            tcg_gen_ld_i64(t_F0d, cpu_env, ucf64_reg_offset(UCOP_REG_S2));
+            tcg_gen_st_i64(t_F0d, cpu_env, ucf64_reg_offset(UCOP_REG_D));
+            break;
+        default:
+            ILLEGAL_INSN(true);
+        }
+        break;
+    case 7: /* neg */
+        UCF64_OP1(neg);
+        break;
+    case 9: /* mov.t mov.f */
+        ILLEGAL_INSN((insn >> 12) & 0xf);
+        if (UCOP_SET(11)) {
+            tcg_gen_movi_i32(t_cond, 1);
+        } else {
+            tcg_gen_movi_i32(t_cond, 0);
+        }
+        switch (UCOP_UCF64_FMT) {
+        case 0 /* s */:
+            tcg_gen_ld_i32(t_F0s, cpu_env, ucf64_reg_offset(UCOP_REG_S2));
+            tcg_gen_ld_i32(t_F1s, cpu_env, ucf64_reg_offset(UCOP_REG_D));
+            gen_helper_ucf64_movts(t_F1s, t_F1s, t_F0s, t_cond, cpu_env);
+            tcg_gen_st_i32(t_F1s, cpu_env, ucf64_reg_offset(UCOP_REG_D));
+            break;
+        case 1 /* d */:
+            tcg_gen_ld_i64(t_F0d, cpu_env, ucf64_reg_offset(UCOP_REG_S2));
+            tcg_gen_ld_i64(t_F1d, cpu_env, ucf64_reg_offset(UCOP_REG_D));
+            gen_helper_ucf64_movtd(t_F1d, t_F1d, t_F0d, t_cond, cpu_env);
+            tcg_gen_st_i64(t_F1d, cpu_env, ucf64_reg_offset(UCOP_REG_D));
+            break;
+        case 2 /* w */:
+            tcg_gen_ld_i64(t_F0d, cpu_env, ucf64_reg_offset(UCOP_REG_S2));
+            tcg_gen_ld_i64(t_F1d, cpu_env, ucf64_reg_offset(UCOP_REG_D));
+            gen_helper_ucf64_movtw(t_F1d, t_F1d, t_F0d, t_cond, cpu_env);
+            tcg_gen_st_i64(t_F1d, cpu_env, ucf64_reg_offset(UCOP_REG_D));
+            break;
+        default:
+            ILLEGAL_INSN(true);
+        }
+        break;
+    default:
+        ILLEGAL_INSN(true);
+    }
+    tcg_temp_free_i32(t_F0s);
+    tcg_temp_free_i64(t_F0d);
+    tcg_temp_free_i32(t_F1s);
+    tcg_temp_free_i64(t_F1d);
+    tcg_temp_free_i32(t_cond);
+}
+
+static void do_ucf64_ldst(CPUUniCore64State *env, DisasContext *s,
+                          uint32_t insn)
+{
+    TCGv_i64 t_addr, t_addrh, t_rd_64;
+    TCGv_i32 t_rd_32;
+    int offset, freg;
+
+    t_addr = tcg_temp_new_i64();
+    t_addrh = tcg_temp_new_i64();
+    t_rd_64 = tcg_temp_new_i64();
+    t_rd_32 = tcg_temp_new_i32();
+
+    /* Prepare base address */
+    if (UCOP_REG_S1 == 31) {
+        tcg_gen_movi_i64(t_addr, s->dc_pc);
+    } else {
+        tcg_gen_mov_i64(t_addr, cpu_R[UCOP_REG_S1]);
+    }
+
+    /* Prepare offset */
+    offset = UCOP_IMM_9 << 2;
+
+    if (UCOP_SET(27)) { /* pre */
+        if (UCOP_SET(28)) { /* add */
+            tcg_gen_addi_i64(t_addr, t_addr, offset);
+        } else { /* sub */
+            tcg_gen_subi_i64(t_addr, t_addr, offset);
+        }
+    }
+
+    if (UCOP_SET(25)) { /* load */
+        if (UCOP_SET(0)) { /* dword */
+            freg = UCOP_REG_D & 0x1e; /* rd should be 0, 2, 4... */
+
+            tcg_gen_qemu_ld32u(t_rd_64, t_addr, 1);
+            tcg_gen_trunc_i64_i32(t_rd_32, t_rd_64);
+            tcg_gen_st_i32(t_rd_32, cpu_env, ucf64_reg_offset(freg));
+
+            tcg_gen_addi_i64(t_addrh, t_addr, 4);
+
+            tcg_gen_qemu_ld32u(t_rd_64, t_addrh, 1);
+            tcg_gen_trunc_i64_i32(t_rd_32, t_rd_64);
+            tcg_gen_st_i32(t_rd_32, cpu_env, ucf64_reg_offset(freg + 1));
+        } else { /* word */
+            tcg_gen_qemu_ld32u(t_rd_64, t_addr, 1);
+            tcg_gen_trunc_i64_i32(t_rd_32, t_rd_64);
+            tcg_gen_st_i32(t_rd_32, cpu_env, ucf64_reg_offset(UCOP_REG_D));
+        }
+
+    } else { /* store */
+        if (UCOP_SET(0)) { /* dword */
+           freg = UCOP_REG_D & 0x1e; /* rd should be 0, 2, 4... */
+
+            tcg_gen_ld_i32(t_rd_32, cpu_env, ucf64_reg_offset(freg));
+            tcg_gen_extu_i32_i64(t_rd_64, t_rd_32);
+            tcg_gen_qemu_st32(t_rd_64, t_addr, 1);
+
+            tcg_gen_addi_i64(t_addrh, t_addr, 4);
+
+            tcg_gen_ld_i32(t_rd_32, cpu_env, ucf64_reg_offset(freg + 1));
+            tcg_gen_extu_i32_i64(t_rd_64, t_rd_32);
+            tcg_gen_qemu_st32(t_rd_64, t_addrh, 1);
+        } else { /* word */
+            tcg_gen_ld_i32(t_rd_32, cpu_env, ucf64_reg_offset(UCOP_REG_D));
+            tcg_gen_extu_i32_i64(t_rd_64, t_rd_32);
+            tcg_gen_qemu_st32(t_rd_64, t_addr, 1);
+        }
+    }
+
+    if (!UCOP_SET(27)) { /* post */
+        if (UCOP_SET(28)) { /* add */
+            tcg_gen_addi_i64(t_addr, t_addr, offset);
+        } else { /* sub */
+            tcg_gen_subi_i64(t_addr, t_addr, offset);
+        }
+    }
+
+    if (UCOP_SET(26)) { /* writeback */
+        ILLEGAL_INSN(UCOP_REG_S1 == 31);
+        tcg_gen_mov_i64(cpu_R[UCOP_REG_S1], t_addr);
+    }
+
+    tcg_temp_free_i64(t_addr);
+    tcg_temp_free_i64(t_addrh);
+    tcg_temp_free_i64(t_rd_64);
+    tcg_temp_free_i32(t_rd_32);
+}
+
+static void do_ucf64(CPUUniCore64State *env, DisasContext *s, uint32_t insn)
+{
+    switch (insn & 0x3) {
+    case 0: /* reg trans*/
+        do_ucf64_trans(env, s, insn);
+        break;
+    case 1: /* data proc */
+        switch ((insn >> 27) & 0x3) {
+        case 0:
+            do_ucf64_datap(env, s, insn);
+            break;
+        case 1:
+            ILLEGAL_INSN(true);
+        case 2:
+            do_ucf64_fcvt(env, s, insn);
+            break;
+        case 3:
+            do_ucf64_fcmp(env, s, insn);
+        }
+        break;
+    case 2: /* ls word*/
+    case 3: /* ls dword*/
+        do_ucf64_ldst(env, s, insn);
+        break;
+    }
+}
-- 
2.7.4

